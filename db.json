{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/20170223174812.png","path":"image/20170223174812.png","modified":0,"renderable":0},{"_id":"source/image/20170223175427.png","path":"image/20170223175427.png","modified":0,"renderable":0},{"_id":"source/image/20170223175801.png","path":"image/20170223175801.png","modified":0,"renderable":0},{"_id":"source/image/20170301152451.png","path":"image/20170301152451.png","modified":0,"renderable":0},{"_id":"source/image/20170301152527.png","path":"image/20170301152527.png","modified":0,"renderable":0},{"_id":"source/image/20170301153213.png","path":"image/20170301153213.png","modified":0,"renderable":0},{"_id":"source/image/20170301161732.png","path":"image/20170301161732.png","modified":0,"renderable":0},{"_id":"source/image/20170426150321.png","path":"image/20170426150321.png","modified":0,"renderable":0},{"_id":"source/image/20170426150749.png","path":"image/20170426150749.png","modified":0,"renderable":0},{"_id":"source/image/20170426150806.png","path":"image/20170426150806.png","modified":0,"renderable":0},{"_id":"source/image/20170428092530.png","path":"image/20170428092530.png","modified":0,"renderable":0},{"_id":"source/image/20170428102947.png","path":"image/20170428102947.png","modified":0,"renderable":0},{"_id":"source/image/20170428105417.png","path":"image/20170428105417.png","modified":0,"renderable":0},{"_id":"source/image/20170428111627.png","path":"image/20170428111627.png","modified":0,"renderable":0},{"_id":"source/image/20170301160933.png","path":"image/20170301160933.png","modified":0,"renderable":0},{"_id":"source/image/20170224160822.png","path":"image/20170224160822.png","modified":0,"renderable":0},{"_id":"source/image/20170505150546.gif","path":"image/20170505150546.gif","modified":0,"renderable":0},{"_id":"themes/alpha-dust/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/image/20170224163724.png","path":"image/20170224163724.png","modified":0,"renderable":0},{"_id":"source/image/20170511143232.png","path":"image/20170511143232.png","modified":0,"renderable":0},{"_id":"source/image/20170511143319.png","path":"image/20170511143319.png","modified":0,"renderable":0},{"_id":"source/image/20170511142823.png","path":"image/20170511142823.png","modified":0,"renderable":0},{"_id":"source/image/20170426171157.gif","path":"image/20170426171157.gif","modified":0,"renderable":0},{"_id":"source/image/20170426172130.gif","path":"image/20170426172130.gif","modified":0,"renderable":0},{"_id":"source/image/20170426172051.gif","path":"image/20170426172051.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/about.md","hash":"e75793b62ed63ee419006f053b344c1717b5b061","modified":1487927574256},{"_id":"source/contact.md","hash":"cd90d4181e9cc3b0371e7e1021fbe191a3100061","modified":1487927574256},{"_id":"source/hello-world.md","hash":"10d93534fe6733d4ffb81e97f82cf4971900ade1","modified":1487927574256},{"_id":"themes/alpha-dust/.gitignore","hash":"a5a49e4d5dfb97857856eb6b0cdb2c93a387718f","modified":1487927574259},{"_id":"themes/alpha-dust/LICENSE","hash":"9603ca6555bd5f0710038003b8a503bd29ca67a1","modified":1487927574259},{"_id":"themes/alpha-dust/README.md","hash":"402518c350275303ede195a62e9e05bfa236b190","modified":1487927574259},{"_id":"themes/alpha-dust/_config.yml","hash":"9ba4a7c54b4aa7d28558575cc3644aec24d66452","modified":1487927574259},{"_id":"source/_posts/2017-02-23-如何使用gitHub和Hexo搭建个人博客.md","hash":"958c959ba9d8f897880c46de98cdbb9eacf766df","modified":1493087250892},{"_id":"source/_posts/2017-02-28-一个好用的Android比例自动适配的库.md","hash":"8fb1fbe763358aa115888948da2a6d12be5d7b16","modified":1488275966594},{"_id":"source/_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译-Litho是什么.md","hash":"ae21ceb51b3af8161315be896c64bca86993d31c","modified":1494494491880},{"_id":"source/_posts/2017-03-01-为你的Github生成漂亮的徽章和进度条.md","hash":"2d2bf8637c3110504d75eece008e3c90f3dd4256","modified":1488358910710},{"_id":"source/_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译-编写动机 .md","hash":"f14647cf5b94f19bb96e6a6279e7c139f5dbeca8","modified":1494494524177},{"_id":"source/_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译-使用.md","hash":"24506da62c445bac657a446886dc685abb1fa5fe","modified":1494494547395},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-View的扁平化.md","hash":"b89a10de70862a32ca4a83dd8b1ef511db7b8a7a","modified":1494495235053},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-使用Component.md","hash":"60a1bebfa049543fd7ea405f71dd78f4de0e15cb","modified":1494494667913},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-准备工作.md","hash":"2944aac5b8607ae28958723535c9de6c5109787f","modified":1494494584702},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-代码生成器.md","hash":"6fc2921138eb1da95980c5c997d4b1cdad69ec62","modified":1494495153681},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载.md","hash":"77f1a7a5b89ee0efd4603ebebfcd642156f9cefe","modified":1494495212669},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-异步布局.md","hash":"5ab9de4147919c357ba4be368dfd182d87049546","modified":1494495186101},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-回收机制.md","hash":"d78ca6f7856b9318ba6633cbded15627bccd17be","modified":1494495250417},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-教程.md","hash":"1236ec607d5e1e474d1a7385d812f9bdbaa7b8d2","modified":1494494614622},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-编写Component.md","hash":"8c209e96ab6a49f994b55c926358b464609d4817","modified":1494494642605},{"_id":"source/_posts/2017-04-28-Facebook出品的Android声明式开源新框架Litho文档翻译-LayoutSpecs.md","hash":"d18e6296106723fd38e55a94926fa61dbd455cd9","modified":1494494701626},{"_id":"source/_posts/2017-04-28-Facebook出品的Android声明式开源新框架Litho文档翻译-MountSpecs.md","hash":"9e78afc4546f8cb11d2e6336d22dfb230aecc59d","modified":1494494724558},{"_id":"source/_posts/2017-05-02-Facebook出品的Android声明式开源新框架Litho文档翻译-Props.md","hash":"609acdecef142a4addb215b2300549c7eca44b70","modified":1494494743249},{"_id":"source/_posts/2017-05-04-Facebook出品的Android声明式开源新框架Litho文档翻译-State.md","hash":"aea2dc38abc9fc51d94977aa59ecc950a4938164","modified":1494494756077},{"_id":"source/_posts/2017-05-05-Facebook出品的Android声明式开源新框架Litho文档翻译-Layout.md","hash":"eebdcad18c48f2855976b7c2564d0828b477266f","modified":1494494779504},{"_id":"source/_posts/2017-05-04-Facebook出品的Android声明式开源新框架Litho文档翻译-总览和导航.md","hash":"59a0a65962ff083f17267427aaba8008a0ea3a62","modified":1494495569990},{"_id":"source/_posts/2017-05-05-Facebook出品的Android声明式开源新框架Litho文档翻译-Recycler.md","hash":"56f43b804f002d9ba6070d37117d98f0b9bdfe1f","modified":1494494800013},{"_id":"source/_posts/2017-05-05-Facebook出品的Android声明式开源新框架Litho文档翻译-事件处理概述.md","hash":"b0353b1c676c74b5d89fcd6b7563c59222637148","modified":1494494827793},{"_id":"source/_posts/2017-05-08-Facebook出品的Android声明式开源新框架Litho文档翻译-Styles.md","hash":"d1861560c1d3c9976e4744266c2ca60ae2190bee","modified":1494494957092},{"_id":"source/_posts/2017-05-08-Facebook出品的Android声明式开源新框架Litho文档翻译-可见性的处理.md","hash":"14e1b5c6d267b027cbe46eacb103d23718f1b790","modified":1494494881687},{"_id":"source/_posts/2017-05-08-Facebook出品的Android声明式开源新框架Litho文档翻译-触摸事件.md","hash":"542d1aaa30556a46242e3cf45603751d92ff40e7","modified":1494494858283},{"_id":"source/_posts/2017-05-09-Facebook出品的Android声明式开源新框架Litho文档翻译-RTL.md","hash":"8588bd228b6b8aae2fa825303ef5fe085b4ce0c1","modified":1494494986976},{"_id":"source/_posts/2017-05-09-Facebook出品的Android声明式开源新框架Litho文档翻译-单元测试.md","hash":"35f37984b580de55b31d59b89533ff18ad256136","modified":1494495072408},{"_id":"source/_posts/2017-05-09-Facebook出品的Android声明式开源新框架Litho文档翻译-无障碍环境.md","hash":"864ec0c3276671545504a71de585de474e36acfe","modified":1494494974147},{"_id":"source/_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-TreeProp.md","hash":"23d95c5b49921102aaa04bd0282d98ba62a9288b","modified":1494495089725},{"_id":"source/_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-创建一个ComponentTree.md","hash":"0eef5255649f20f03f57e0e8f78bd154a5aa4a1a","modified":1494495131529},{"_id":"source/_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-手动增量式挂载.md","hash":"8370faa5c1683515f8ba7aa938854247e4c8bf08","modified":1494495110744},{"_id":"source/_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-最佳实践.md","hash":"1c6f4e4157c7eab52067862795c118b57493efc4","modified":1494495270954},{"_id":"source/_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-自定义布局.md","hash":"7b9e270e80fe067008e0cbd717aefc52dc6cd4ba","modified":1494495066911},{"_id":"source/_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-仓库架构.md","hash":"416249e43afc32be95d9cfc08ae3fbffa73d7d58","modified":1494495391834},{"_id":"source/_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-开发者选项.md","hash":"090ae01de4d73eebb8e671bd0554d0560e7bde9e","modified":1494495314995},{"_id":"source/_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-如何参与.md","hash":"9619cc0691de13f53535d32fa1f2a88367815dfd","modified":1494495357243},{"_id":"source/_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-调试.md","hash":"ac9d468d76b9884dd9508b6c0f5529f47c6ce08a","modified":1494495291732},{"_id":"source/image/20170223174812.png","hash":"7c70d7271498cf2b11de6924c91a8c8e0c3e4245","modified":1487927574256},{"_id":"source/image/20170223175427.png","hash":"b3c0933df333bb88719d045ee3f2a099749aecdb","modified":1487927574256},{"_id":"source/image/20170223175801.png","hash":"96e6764bb6097dcd32c456b66fbfcd4ef9493953","modified":1487927574257},{"_id":"source/image/20170301152451.png","hash":"e6b1eb88957315ff55c8375522e1772975c2c5c2","modified":1488353110456},{"_id":"source/image/20170301152527.png","hash":"3704209e21d7f61c41216ce73bf78dccc55e5055","modified":1488353133799},{"_id":"source/image/20170301153213.png","hash":"da06ba8864110695cf3c9392b52bb234ff55ec8f","modified":1488353540712},{"_id":"source/image/20170301161732.png","hash":"296c24ee7c17bf75a6298e8df11fdbf44e746c31","modified":1488356258956},{"_id":"source/image/20170426150321.png","hash":"7a6f44b19c2879511525d3a434ed5fc03efaef1b","modified":1493190124761},{"_id":"source/image/20170426150749.png","hash":"f092255a963446010c8d52c0911e577215ab5537","modified":1493190475840},{"_id":"source/image/20170426150806.png","hash":"cdb20c98ab94e410f43379847117bd27e05b46b9","modified":1493190491751},{"_id":"source/image/20170428092530.png","hash":"5abfc4c1af4f32fc701e3824106d5e57f4c5ab2c","modified":1493342747921},{"_id":"source/image/20170428102947.png","hash":"b8b29817ff1d481d40ef573c128e8492fcfb0614","modified":1493346598682},{"_id":"source/image/20170428105417.png","hash":"fb887ae2242263691fb76ff975089974a092bbf6","modified":1493348066017},{"_id":"source/image/20170428111627.png","hash":"d10672f222e60d1a7c763554ae603874e7111336","modified":1493349394240},{"_id":"themes/alpha-dust/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1487927574260},{"_id":"themes/alpha-dust/languages/default.yml","hash":"f0e62ce15272b2c59c9ae7f7615a286c69bf7113","modified":1487927574260},{"_id":"themes/alpha-dust/languages/en.yml","hash":"f0e62ce15272b2c59c9ae7f7615a286c69bf7113","modified":1487927574260},{"_id":"themes/alpha-dust/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1487927574260},{"_id":"themes/alpha-dust/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1487927574260},{"_id":"themes/alpha-dust/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1487927574260},{"_id":"themes/alpha-dust/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1487927574261},{"_id":"themes/alpha-dust/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1487927574261},{"_id":"themes/alpha-dust/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1487927574261},{"_id":"themes/alpha-dust/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1487927574261},{"_id":"themes/alpha-dust/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1487927574261},{"_id":"themes/alpha-dust/layout/archive.ejs","hash":"30620dd5e4f24e9d624c235dd16396c5e130deef","modified":1487927574264},{"_id":"themes/alpha-dust/layout/index.ejs","hash":"0dcf6f1b66722ddadb7479f4edf20281d30a7879","modified":1487927574264},{"_id":"themes/alpha-dust/layout/layout.ejs","hash":"9d1ba5fb467ab4269cbc925b3f2122a29b821b8d","modified":1487927574264},{"_id":"themes/alpha-dust/layout/page.ejs","hash":"953256db94b3ed9ce2870d4b9203fe3a1e5b37bb","modified":1487927574265},{"_id":"themes/alpha-dust/layout/post.ejs","hash":"4030d46464fd653c0e72a7615c19e7b2d73aa21d","modified":1487927574265},{"_id":"themes/alpha-dust/template/archive.html","hash":"6152dc2e093c1431cbe2fa6bc9cb54751c2a7f86","modified":1487927574269},{"_id":"themes/alpha-dust/template/index.html","hash":"674b2011f068af9bf464ac77aafccf6867fcd7c0","modified":1487927574277},{"_id":"themes/alpha-dust/template/post.html","hash":"daed2747ec15affef2fe1d5cc05432361a2ed6f9","modified":1487927574278},{"_id":"source/image/20170301160933.png","hash":"525587c28c79b8a23be9794f18c5bc766bc9358b","modified":1488355780489},{"_id":"source/image/20170224160822.png","hash":"78a9edac5da4fb320dcabea116452c127123ecf1","modified":1487927574258},{"_id":"source/image/20170505150546.gif","hash":"9019e49498c85adcbe3158639f53cd2b7ae105e4","modified":1493967983368},{"_id":"themes/alpha-dust/layout/_partial/after-footer.ejs","hash":"43ad85ba781c3c98354e9873fe8a49fe50f08bb4","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/article-archive.ejs","hash":"f9608407a583bff104acb07c03fd8108056798c7","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/article-short.ejs","hash":"8158759b81ea61b07873f4e7360ec631ca0930ca","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/comments.ejs","hash":"b0bb9c59f517302348aafcb2b832513d53d59055","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/article-long.ejs","hash":"65df8414a4b479033c0f67e066064351f0b2216f","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/footer.ejs","hash":"b07b8f7f43811e1b6f5382f6eb4cd778a70bd3cc","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/footer_recent_posts.ejs","hash":"8c20579849498be304e47d0f10d42149971eb352","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/footer_categories.ejs","hash":"f85cb280ae965fdd1d92af8bc0ece6c4d826a449","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/gallery.ejs","hash":"63c93ed2dc9c5d9eefeaa8130e9728848731fa64","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/head.ejs","hash":"3132acfe6658f31db95a4dae6d818b09b9156d59","modified":1487927574264},{"_id":"themes/alpha-dust/layout/_partial/header.ejs","hash":"4fa635135f97eaa5f324cf83cb04b083ffdd979f","modified":1487927574264},{"_id":"themes/alpha-dust/layout/_partial/menu.ejs","hash":"760cdaf07f808c9e8637f58e412aea43c4021ec2","modified":1487927574264},{"_id":"themes/alpha-dust/layout/_partial/pagination.ejs","hash":"58982acc8dc2b83c6c2cdf64a2c4156e947254d0","modified":1487927574264},{"_id":"themes/alpha-dust/source/css/style.styl","hash":"17454ba3eef92075c4848bb43fd626b53760334b","modified":1487927574267},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1487927574268},{"_id":"themes/alpha-dust/source/js/main.js","hash":"e644dd5c0742f209072c48499c1beba20bc1e496","modified":1487927574268},{"_id":"themes/alpha-dust/template/css/font-awesome.min.css","hash":"3c1d63dd1176c77f9f4cdb1616fbb08c31b9822f","modified":1487927574269},{"_id":"themes/alpha-dust/template/css/style.css","hash":"9c3710b32a4466c3ea5b6232a1af8fccc5877216","modified":1487927574270},{"_id":"themes/alpha-dust/template/css/font-awesome.css","hash":"a02674d823c7b577d38c3cdb91953993b6e4b3a0","modified":1487927574269},{"_id":"themes/alpha-dust/template/css/style.styl","hash":"a3d739266fbf9aff73443cf745e4a4d5c284cffc","modified":1487927574270},{"_id":"themes/alpha-dust/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1487927574276},{"_id":"themes/alpha-dust/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1487927574276},{"_id":"themes/alpha-dust/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1487927574276},{"_id":"themes/alpha-dust/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1487927574276},{"_id":"themes/alpha-dust/template/js/main.js","hash":"ed46e32f0bf6f4502a6558f9ad03843031dc318d","modified":1487927574277},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1487927574272},{"_id":"themes/alpha-dust/template/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1487927574271},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1487927574275},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1487927574274},{"_id":"themes/alpha-dust/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1487927574277},{"_id":"source/image/20170224163724.png","hash":"70da4674d268cc70a0ff1f4189e67dab5639563d","modified":1487927574259},{"_id":"themes/alpha-dust/source/css/_partial/archive.styl","hash":"e51d15046b9e10d4342b67bb83fd3a0c42f5d60e","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/base.styl","hash":"00300febf434b78ad93087e83481d2bf9d2c54a5","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/code.styl","hash":"6c0788e0616a366234157abd18cb6a11b4dc8bfc","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/footer.styl","hash":"a741adad7f208787c5d863a443da9a3438a01331","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/header.styl","hash":"d74c2d8968b909c4e2cdab2235b5cebf6eef91c8","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/menu.styl","hash":"7419c10bf98d059fa0263427c68e009cc0d4c4fa","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/pagination.styl","hash":"7dfcf43dd05063115f7ebf9e63219a102b35a3ba","modified":1487927574267},{"_id":"themes/alpha-dust/source/css/_partial/post-content.styl","hash":"c3f0ae13c8a953e957da23db6ef7dab2b8217352","modified":1487927574267},{"_id":"themes/alpha-dust/source/css/_partial/variables.styl","hash":"f1dbc90648d67e03ba3b311c967977aa50888b38","modified":1487927574267},{"_id":"themes/alpha-dust/source/css/_partial/post-layout.styl","hash":"bc8376e97266f047457117a965321efdd58e68a3","modified":1487927574267},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1487927574274},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1487927574273},{"_id":"source/image/20170511143232.png","hash":"bee1320ebedfbee7dc95efaecad8f06ee2db1307","modified":1494484367385},{"_id":"source/image/20170511143319.png","hash":"106200ba9af6cca206df97e131ebe82b0a59ed3a","modified":1494485641536},{"_id":"source/image/20170511142823.png","hash":"26a35a77badb9d44145cf4547ee6d1bf38749e7b","modified":1494484133961},{"_id":"source/image/20170426171157.gif","hash":"bd4dfe2a3d2ffd23d444cfe97ea847041716b4d3","modified":1493109084536},{"_id":"source/image/20170426172130.gif","hash":"119c6cdd9b78eec8c7d5e16488b786eb3039d13f","modified":1493112975924},{"_id":"source/image/20170426172051.gif","hash":"7e4ac1c0cc36974a196e2bcee8a12bc9a1277889","modified":1493112978032},{"_id":"public/about.html","hash":"f6927ef5fc5a93308050b23015722229eed9ed66","modified":1494495583685},{"_id":"public/contact.html","hash":"2d590477bae73a47e830495cba93f0262180b05a","modified":1494495583685},{"_id":"public/hello-world.html","hash":"f067f6ec879a266c7c2f757c505b0ffb1d20bf59","modified":1494495583685},{"_id":"public/2017/05/11/Facebook出品的Android声明式开源新框架Litho文档翻译-开发者选项/index.html","hash":"86da048ba9db156a0cbf454019ad46bf3f65b030","modified":1494495583685},{"_id":"public/2017/05/11/Facebook出品的Android声明式开源新框架Litho文档翻译-调试/index.html","hash":"ea1cd3b8fc95c88ae0863f6f04fc2e04aad0e390","modified":1494495583685},{"_id":"public/2017/05/10/Facebook出品的Android声明式开源新框架Litho文档翻译-创建一个ComponentTree/index.html","hash":"3871879f0cf4484748282fb0621b276c0446bd7c","modified":1494495583686},{"_id":"public/2017/05/10/Facebook出品的Android声明式开源新框架Litho文档翻译-手动增量式挂载/index.html","hash":"b1cf777d1162af2fdfdfa615e03f48d0e4e3a362","modified":1494495583685},{"_id":"public/2017/05/10/Facebook出品的Android声明式开源新框架Litho文档翻译-TreeProp/index.html","hash":"cb5eb890077ad2d53256941f2e04d0ee8f557114","modified":1494495583685},{"_id":"public/2017/05/09/Facebook出品的Android声明式开源新框架Litho文档翻译-RTL/index.html","hash":"efc5c80502a78dbdcec36cf183201997d2c49aff","modified":1494495583685},{"_id":"public/2017/05/08/Facebook出品的Android声明式开源新框架Litho文档翻译-Styles/index.html","hash":"edc27ddde57eacda9ca5558a1532cef8e7c9f520","modified":1494495583686},{"_id":"public/2017/05/08/Facebook出品的Android声明式开源新框架Litho文档翻译-可见性的处理/index.html","hash":"9470d3d5b79d982d6e75fe4f518b225cf507ec57","modified":1494495583686},{"_id":"public/2017/05/08/Facebook出品的Android声明式开源新框架Litho文档翻译-触摸事件/index.html","hash":"cccebe3832668745d3499e877e388194903c6275","modified":1494495583686},{"_id":"public/2017/05/05/Facebook出品的Android声明式开源新框架Litho文档翻译-Layout/index.html","hash":"40aa376e355faf03f98deb4939a69e17fea44437","modified":1494495583686},{"_id":"public/2017/04/28/Facebook出品的Android声明式开源新框架Litho文档翻译-LayoutSpecs/index.html","hash":"8da72221a9e456f7713c3597adc6ccd18001edc4","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-编写Component/index.html","hash":"3cdc02ec07594323ca387d746f24c695b6af6cba","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-使用Component/index.html","hash":"d6d2979f6632f8f4a61427be215ca3a67e891d2f","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-View的扁平化/index.html","hash":"4f23fba38d4a7f237286d93ce28b1a20d871c639","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载/index.html","hash":"88339939d10b8ea015826365af0dfa43b10a5f70","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-代码生成器/index.html","hash":"ee6a03405d18a0b205d9b3544dc876c1486c1e48","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-回收机制/index.html","hash":"6b890912e8872e88da6ecfceed7179217979bf0a","modified":1494495583686},{"_id":"public/2017/04/25/Facebook出品的Android声明式开源新框架Litho文档翻译-编写动机 /index.html","hash":"90b8c02afaf44de5d5e971f7f4d6efdd808fc932","modified":1494495583686},{"_id":"public/2017/04/25/Facebook出品的Android声明式开源新框架Litho文档翻译-使用/index.html","hash":"5e2190268bf0f6d83bb374ecad1b75e996af479f","modified":1494495583686},{"_id":"public/2017/03/01/为你的Github生成漂亮的徽章和进度条/index.html","hash":"6c516fe80e0d31941b1889e4b3c7ea83de4584e8","modified":1494495583686},{"_id":"public/2017/04/25/Facebook出品的Android声明式开源新框架Litho文档翻译-Litho是什么/index.html","hash":"e8749088c3860140ef50ed1b924cb3d405ca49f3","modified":1494495583686},{"_id":"public/categories/其他知识/index.html","hash":"3f4aa4c9147efaced618ffe96d339d50974fa778","modified":1494494067695},{"_id":"public/categories/Web前端知识/index.html","hash":"33c5d2705b3cd1262e817b0a6434944592d10ad2","modified":1494494067695},{"_id":"public/tags/github/index.html","hash":"bb2f2c932448458a2d225d5b89b2720d12777c01","modified":1494494067695},{"_id":"public/tags/Hexo/index.html","hash":"e11092e480f86353143206754888399535e889c7","modified":1494494067695},{"_id":"public/tags/Web/index.html","hash":"f36dd99499d7316c9ad34599ae37b1c6e0a5cf54","modified":1494494067695},{"_id":"public/2017/05/10/Facebook出品的Android声明式开源新框架Litho文档翻译-最佳实践/index.html","hash":"756fe2205fa692ef53d64cc8423b534d5868cafe","modified":1494495583686},{"_id":"public/2017/05/10/Facebook出品的Android声明式开源新框架Litho文档翻译-自定义布局/index.html","hash":"64ca42da2135159fe7e118af4655e062b19e6802","modified":1494495583686},{"_id":"public/2017/05/09/Facebook出品的Android声明式开源新框架Litho文档翻译-单元测试/index.html","hash":"0133efbe9b946e19f0925e6df2a782e23ef9d3d5","modified":1494495583686},{"_id":"public/2017/05/09/Facebook出品的Android声明式开源新框架Litho文档翻译-无障碍环境/index.html","hash":"9b6b4d8c46461497073801b72ff395baa9bee1f6","modified":1494495583686},{"_id":"public/2017/05/05/Facebook出品的Android声明式开源新框架Litho文档翻译-事件处理概述/index.html","hash":"c932e0c3a2efb4add574e1883c38ad35ed0fde77","modified":1494495583686},{"_id":"public/2017/05/05/Facebook出品的Android声明式开源新框架Litho文档翻译-Recycler/index.html","hash":"be07e1d568883fa7c9c934261502720918f50344","modified":1494495583686},{"_id":"public/2017/05/04/Facebook出品的Android声明式开源新框架Litho文档翻译-State/index.html","hash":"418ca3eef221f4cccb51bfc70db427fab2b6abba","modified":1494495583686},{"_id":"public/2017/05/04/Facebook出品的Android声明式开源新框架Litho文档翻译-总览和导航/index.html","hash":"96b811f69cac9d8816c342c8ee5ca81fa288cac2","modified":1494495583686},{"_id":"public/2017/05/02/Facebook出品的Android声明式开源新框架Litho文档翻译-Props/index.html","hash":"96323d43ded8abf8d69153976fd042db95a1e168","modified":1494495583686},{"_id":"public/2017/04/28/Facebook出品的Android声明式开源新框架Litho文档翻译-MountSpecs/index.html","hash":"6e632f4539e4047cca6ab6d3219cad129d31d519","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-教程/index.html","hash":"f1bf8d7b4401fd7d529d44ad7076bebd0bad9bb0","modified":1494495583686},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-准备工作/index.html","hash":"9636d3529132d1e1a6b26e498c14153970c11142","modified":1494495583687},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译-异步布局/index.html","hash":"bfbe15c15dfeb97bc604c39c8e37d0b64ca21e3f","modified":1494495583687},{"_id":"public/2017/02/28/一个好用的Android比例自动适配的库/index.html","hash":"31cf3efad3d6fa982f97f9de0d002abf522689a7","modified":1494495583687},{"_id":"public/2017/02/23/如何使用gitHub和Hexo搭建个人博客/index.html","hash":"8e7546fba768006158ee2f619b38c59f8abb95a5","modified":1494495583687},{"_id":"public/categories/Android知识/page/2/index.html","hash":"4395277b0f597bb1e4359df85fde6289e0dc159b","modified":1494494067696},{"_id":"public/categories/Android知识/index.html","hash":"aa5fd1fa7256bb070967cb648619fb23297eb90e","modified":1494494067696},{"_id":"public/categories/Android知识/page/3/index.html","hash":"4395277b0f597bb1e4359df85fde6289e0dc159b","modified":1494494067696},{"_id":"public/categories/Android知识/page/4/index.html","hash":"4395277b0f597bb1e4359df85fde6289e0dc159b","modified":1494494067696},{"_id":"public/index.html","hash":"7c3303fe481ff9d23d25085646bcf747167e5c67","modified":1494495583687},{"_id":"public/page/2/index.html","hash":"c79097f8533e47925ddfaf27f18525825ef387c6","modified":1494495583687},{"_id":"public/page/3/index.html","hash":"8cb30684e458c26e20195ebefebae4b44a7ab052","modified":1494495583687},{"_id":"public/page/4/index.html","hash":"cfe4b5a3d7fd8db5cdebbc9d6a0e16d064aa84af","modified":1494495583687},{"_id":"public/archives/index.html","hash":"aa70e740dbfbf6e4801d1a3cfff68841390520aa","modified":1494495583687},{"_id":"public/archives/page/2/index.html","hash":"97168a58bdedbc2b6beb1dab0ae819632303afe9","modified":1494495583687},{"_id":"public/archives/page/3/index.html","hash":"97168a58bdedbc2b6beb1dab0ae819632303afe9","modified":1494495583687},{"_id":"public/archives/page/4/index.html","hash":"97168a58bdedbc2b6beb1dab0ae819632303afe9","modified":1494495583687},{"_id":"public/archives/2017/index.html","hash":"df2ce8d474b58c007a76c4c4f91e082c9f2c2b57","modified":1494495583687},{"_id":"public/archives/2017/page/3/index.html","hash":"807008e64dada50dcb92786f4e576ed8f0ecb8d8","modified":1494495583687},{"_id":"public/archives/2017/page/2/index.html","hash":"807008e64dada50dcb92786f4e576ed8f0ecb8d8","modified":1494495583687},{"_id":"public/archives/2017/page/4/index.html","hash":"807008e64dada50dcb92786f4e576ed8f0ecb8d8","modified":1494495583687},{"_id":"public/archives/2017/02/index.html","hash":"ca681dce78021e5ea2060cd73cd4c28303db815e","modified":1494495583687},{"_id":"public/archives/2017/03/index.html","hash":"79b9109fc9ae609a48399b2fe9f99e801682e3b5","modified":1494495583687},{"_id":"public/archives/2017/04/index.html","hash":"103b297321e7de865f825f8a96ec82bb32964454","modified":1494495583687},{"_id":"public/archives/2017/04/page/2/index.html","hash":"c70975ca11802f1d5387f9941baf585a7f8bd391","modified":1494495583687},{"_id":"public/archives/2017/05/page/2/index.html","hash":"a384bfdfb444f14b0adf39aa6dc48aadae32568f","modified":1494495583687},{"_id":"public/archives/2017/05/index.html","hash":"cf11e91e12a4c0a7c4ccf092e4bbdf7c92c4bec1","modified":1494495583687},{"_id":"public/tags/Android/index.html","hash":"9e73241c586286dda4bb90b24275321779c1bfc3","modified":1494494067697},{"_id":"public/tags/Android/page/2/index.html","hash":"3833247b3b32dfe2053525427f3e4d30037f6f1c","modified":1494494067697},{"_id":"public/tags/Android/page/3/index.html","hash":"3833247b3b32dfe2053525427f3e4d30037f6f1c","modified":1494494067697},{"_id":"public/tags/Android/page/4/index.html","hash":"3833247b3b32dfe2053525427f3e4d30037f6f1c","modified":1494494067697},{"_id":"public/tags/实用库/page/2/index.html","hash":"4d5b09ac03f859a973d1890dbd9487ac1a9550f1","modified":1494494067697},{"_id":"public/tags/实用库/index.html","hash":"5ea9465bfa31b7b88c9a7bad4d343105e3917660","modified":1494494067697},{"_id":"public/tags/实用库/page/3/index.html","hash":"4d5b09ac03f859a973d1890dbd9487ac1a9550f1","modified":1494494067697},{"_id":"public/tags/实用库/page/4/index.html","hash":"4d5b09ac03f859a973d1890dbd9487ac1a9550f1","modified":1494494067697},{"_id":"public/tags/Litho/index.html","hash":"693ab517b455246983bb2b4a6e661138f0d6be0f","modified":1494494067698},{"_id":"public/tags/Litho/page/3/index.html","hash":"e274dd4e6259da2f7ce4a234b8044b2341100cc5","modified":1494494067698},{"_id":"public/tags/Litho/page/4/index.html","hash":"e274dd4e6259da2f7ce4a234b8044b2341100cc5","modified":1494494067698},{"_id":"public/tags/Litho/page/2/index.html","hash":"e274dd4e6259da2f7ce4a234b8044b2341100cc5","modified":1494494067698},{"_id":"public/2017/05/11/Facebook出品的Android声明式开源新框架Litho文档翻译-仓库架构/index.html","hash":"c41f3db3a29aa9b2825bccccc3b59b980b28b447","modified":1494495583685},{"_id":"public/2017/05/11/Facebook出品的Android声明式开源新框架Litho文档翻译-如何参与/index.html","hash":"20d31841afe06d1a289b58be005cc5236ac63676","modified":1494495583685},{"_id":"public/archives/2017/05/page/3/index.html","hash":"a384bfdfb444f14b0adf39aa6dc48aadae32568f","modified":1494495583687},{"_id":"public/image/20170223174812.png","hash":"7c70d7271498cf2b11de6924c91a8c8e0c3e4245","modified":1494494067705},{"_id":"public/image/20170223175801.png","hash":"96e6764bb6097dcd32c456b66fbfcd4ef9493953","modified":1494494067705},{"_id":"public/image/20170301152527.png","hash":"3704209e21d7f61c41216ce73bf78dccc55e5055","modified":1494494067705},{"_id":"public/image/20170301152451.png","hash":"e6b1eb88957315ff55c8375522e1772975c2c5c2","modified":1494494067705},{"_id":"public/image/20170301153213.png","hash":"da06ba8864110695cf3c9392b52bb234ff55ec8f","modified":1494494067705},{"_id":"public/image/20170301161732.png","hash":"296c24ee7c17bf75a6298e8df11fdbf44e746c31","modified":1494494067705},{"_id":"public/image/20170426150749.png","hash":"f092255a963446010c8d52c0911e577215ab5537","modified":1494494067705},{"_id":"public/image/20170426150321.png","hash":"7a6f44b19c2879511525d3a434ed5fc03efaef1b","modified":1494494067705},{"_id":"public/image/20170426150806.png","hash":"cdb20c98ab94e410f43379847117bd27e05b46b9","modified":1494494067705},{"_id":"public/image/20170428092530.png","hash":"5abfc4c1af4f32fc701e3824106d5e57f4c5ab2c","modified":1494494067705},{"_id":"public/image/20170428102947.png","hash":"b8b29817ff1d481d40ef573c128e8492fcfb0614","modified":1494494067705},{"_id":"public/image/20170428111627.png","hash":"d10672f222e60d1a7c763554ae603874e7111336","modified":1494494067705},{"_id":"public/image/20170428105417.png","hash":"fb887ae2242263691fb76ff975089974a092bbf6","modified":1494494067705},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1494494067705},{"_id":"public/image/20170223175427.png","hash":"b3c0933df333bb88719d045ee3f2a099749aecdb","modified":1494494067705},{"_id":"public/image/20170301160933.png","hash":"525587c28c79b8a23be9794f18c5bc766bc9358b","modified":1494494067998},{"_id":"public/css/style.css","hash":"a8b4312a0a6e600e3c1629df20e2860757370d10","modified":1494494068002},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1494494068002},{"_id":"public/image/20170505150546.gif","hash":"9019e49498c85adcbe3158639f53cd2b7ae105e4","modified":1494494068002},{"_id":"public/image/20170224160822.png","hash":"78a9edac5da4fb320dcabea116452c127123ecf1","modified":1494494068002},{"_id":"public/image/20170224163724.png","hash":"70da4674d268cc70a0ff1f4189e67dab5639563d","modified":1494494068014},{"_id":"public/image/20170511143232.png","hash":"bee1320ebedfbee7dc95efaecad8f06ee2db1307","modified":1494494068040},{"_id":"public/image/20170511143319.png","hash":"106200ba9af6cca206df97e131ebe82b0a59ed3a","modified":1494494068043},{"_id":"public/image/20170511142823.png","hash":"26a35a77badb9d44145cf4547ee6d1bf38749e7b","modified":1494494068048},{"_id":"public/image/20170426171157.gif","hash":"bd4dfe2a3d2ffd23d444cfe97ea847041716b4d3","modified":1494494068054},{"_id":"public/image/20170426172130.gif","hash":"119c6cdd9b78eec8c7d5e16488b786eb3039d13f","modified":1494494068058},{"_id":"public/image/20170426172051.gif","hash":"7e4ac1c0cc36974a196e2bcee8a12bc9a1277889","modified":1494494068073}],"Category":[{"name":"Android知识","_id":"cj2k76hpx0005ssrln7qav6z1"},{"name":"其他知识","_id":"cj2k76hq6000fssrla3wubs4m"},{"name":"Web前端知识","_id":"cj2k76hq9000nssrl1t0x5pbk"}],"Data":[],"Page":[{"title":"ABOUT","_content":"\nHi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.\n\n本博客使用[Hexo](https://hexo.io/)搭建,部署在[GitHub Pages](https://pages.github.com/)上.使用[alpha-dust](https://github.com/klugjo/hexo-theme-alpha-dust)主题.\n\n感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢[klugjo](https://github.com/klugjo)提供了这个充满科技感的Hexo主题.","source":"about.md","raw":"---\ntitle: ABOUT\n---\n\nHi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.\n\n本博客使用[Hexo](https://hexo.io/)搭建,部署在[GitHub Pages](https://pages.github.com/)上.使用[alpha-dust](https://github.com/klugjo/hexo-theme-alpha-dust)主题.\n\n感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢[klugjo](https://github.com/klugjo)提供了这个充满科技感的Hexo主题.","date":"2017-03-02T09:55:40.727Z","updated":"2017-02-24T09:12:54.256Z","path":"about.html","comments":1,"layout":"page","_id":"cj2k76hp20000ssrlh4iom2st","content":"<p>Hi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.</p>\n<p>本博客使用<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>搭建,部署在<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a>上.使用<a href=\"https://github.com/klugjo/hexo-theme-alpha-dust\" target=\"_blank\" rel=\"external\">alpha-dust</a>主题.</p>\n<p>感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢<a href=\"https://github.com/klugjo\" target=\"_blank\" rel=\"external\">klugjo</a>提供了这个充满科技感的Hexo主题.</p>\n","excerpt":"","more":"<p>Hi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.</p>\n<p>本博客使用<a href=\"https://hexo.io/\">Hexo</a>搭建,部署在<a href=\"https://pages.github.com/\">GitHub Pages</a>上.使用<a href=\"https://github.com/klugjo/hexo-theme-alpha-dust\">alpha-dust</a>主题.</p>\n<p>感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢<a href=\"https://github.com/klugjo\">klugjo</a>提供了这个充满科技感的Hexo主题.</p>\n"},{"title":"CONTACT","_content":"\n- Email : [515073770@qq.com](mailto:515073770@qq.com)\n- GitHub : [https://github.com/ShikiEiki](https://github.com/ShikiEiki)\n- Weibo : [猫山四季](http://weibo.com/fhshiki)\n- QQ : 515073770","source":"contact.md","raw":"---\ntitle: CONTACT\n---\n\n- Email : [515073770@qq.com](mailto:515073770@qq.com)\n- GitHub : [https://github.com/ShikiEiki](https://github.com/ShikiEiki)\n- Weibo : [猫山四季](http://weibo.com/fhshiki)\n- QQ : 515073770","date":"2017-03-02T09:55:40.728Z","updated":"2017-02-24T09:12:54.256Z","path":"contact.html","comments":1,"layout":"page","_id":"cj2k76hp30001ssrlnmy2pkcn","content":"<ul>\n<li>Email : <a href=\"mailto:515073770@qq.com\" target=\"_blank\" rel=\"external\">515073770@qq.com</a></li>\n<li>GitHub : <a href=\"https://github.com/ShikiEiki\" target=\"_blank\" rel=\"external\">https://github.com/ShikiEiki</a></li>\n<li>Weibo : <a href=\"http://weibo.com/fhshiki\" target=\"_blank\" rel=\"external\">猫山四季</a></li>\n<li>QQ : 515073770</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>Email : <a href=\"mailto:515073770@qq.com\">515073770@qq.com</a></li>\n<li>GitHub : <a href=\"https://github.com/ShikiEiki\">https://github.com/ShikiEiki</a></li>\n<li>Weibo : <a href=\"http://weibo.com/fhshiki\">猫山四季</a></li>\n<li>QQ : 515073770</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n$ hexo sadfdsaf\n$ hexo sdfsadfs\n```\n\n``` java\nint i = 0;\nint j = 0;\nbreak;\nObject o = new Object(this);\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n$ hexo sadfdsaf\n$ hexo sdfsadfs\n```\n\n``` java\nint i = 0;\nint j = 0;\nbreak;\nObject o = new Object(this);\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","date":"2017-03-02T09:55:40.730Z","updated":"2017-02-24T09:12:54.256Z","path":"hello-world.html","comments":1,"layout":"page","_id":"cj2k76hp40002ssrljkid116j","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div><div class=\"line\">$ hexo sadfdsaf</div><div class=\"line\">$ hexo sdfsadfs</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">break</span>;</div><div class=\"line\">Object o = <span class=\"keyword\">new</span> Object(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div><div class=\"line\">$ hexo sadfdsaf</div><div class=\"line\">$ hexo sdfsadfs</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">break</span>;</div><div class=\"line\">Object o = <span class=\"keyword\">new</span> Object(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"Post":[{"title":"一个好用的Android比例自动适配的库","date":"2017-02-28T07:59:42.000Z","_content":"\n今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.\n刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.\n\n### 优势\n这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.\n而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.\n\n### 原理\n简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.\n\n这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.\n\n### 使用\n1.首先添加库引用.\n\n``` gradle\ndependencies {\n    compile 'com.zhy:autolayout:1.4.5'\n} \n```\n\n2.在项目的AndroidManifest中注明设计稿的尺寸。\n\n``` xml\n<meta-data android:name=\"design_width\" android:value=\"768\">\n</meta-data>\n<meta-data android:name=\"design_height\" android:value=\"1280\">\n</meta-data>\n```\n\n3.界面的改动.\n- Activity界面的用法\n\n让Activity继承AutoLayoutActivity\n\n``` java\npublic class MainActivity extends AutoLayoutActivity {\n\n.......\n\n}\n\n```\n\n- Fragment界面的用法\n\n在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).\n\n``` java \n@Nullable\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\tView view = inflater.inflate(.......);\n\t.........\n\t.........\n\tAutoUtils.autoSize(view);\n\treturn view;\n}\n```\n\n- 动态生成的view的用法\n\n以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.\n\n``` java\n//动态生成pageBtn,并且动态设置宽高间隔等\nTextView pageBtn = new TextView(getApplicationContext());\npageBtn.setPadding(10 , 20 , 30 , 40);\npageBtn.setTextSize(25);\nLinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(40 , 40);\nlayoutParams.setMargins(10 , 20 , 30 , 40);\n\n//在全部生成完毕后,添加至容器之前调整大小.\nAutoUtils.autoSize(pageBtn);\n\npageBtnContainer.addView(pageBtn , layoutParams);\n```\n\n做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.\n集成完毕,适配完成,就这么简单~\n\n### 其他\n感谢张鸿阳大神提供这么好用的库.\n\n[AndroidAutoLayout的github](https://github.com/hongyangAndroid/AndroidAutoLayout)\n[鸿神写的AutoLayout的介绍文章](http://blog.csdn.net/lmj623565791/article/details/49990941)\n[AndroidAutoLayout的项目介绍](https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md)\n\n以上介绍中还附上了许多进阶用法,学习中...","source":"_posts/2017-02-28-一个好用的Android比例自动适配的库.md","raw":"---\ntitle: 一个好用的Android比例自动适配的库\ndate: 2017-02-28 15:59:42\ntags: [Android,实用库]\ncategory: Android知识\n---\n\n今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.\n刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.\n\n### 优势\n这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.\n而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.\n\n### 原理\n简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.\n\n这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.\n\n### 使用\n1.首先添加库引用.\n\n``` gradle\ndependencies {\n    compile 'com.zhy:autolayout:1.4.5'\n} \n```\n\n2.在项目的AndroidManifest中注明设计稿的尺寸。\n\n``` xml\n<meta-data android:name=\"design_width\" android:value=\"768\">\n</meta-data>\n<meta-data android:name=\"design_height\" android:value=\"1280\">\n</meta-data>\n```\n\n3.界面的改动.\n- Activity界面的用法\n\n让Activity继承AutoLayoutActivity\n\n``` java\npublic class MainActivity extends AutoLayoutActivity {\n\n.......\n\n}\n\n```\n\n- Fragment界面的用法\n\n在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).\n\n``` java \n@Nullable\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\tView view = inflater.inflate(.......);\n\t.........\n\t.........\n\tAutoUtils.autoSize(view);\n\treturn view;\n}\n```\n\n- 动态生成的view的用法\n\n以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.\n\n``` java\n//动态生成pageBtn,并且动态设置宽高间隔等\nTextView pageBtn = new TextView(getApplicationContext());\npageBtn.setPadding(10 , 20 , 30 , 40);\npageBtn.setTextSize(25);\nLinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(40 , 40);\nlayoutParams.setMargins(10 , 20 , 30 , 40);\n\n//在全部生成完毕后,添加至容器之前调整大小.\nAutoUtils.autoSize(pageBtn);\n\npageBtnContainer.addView(pageBtn , layoutParams);\n```\n\n做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.\n集成完毕,适配完成,就这么简单~\n\n### 其他\n感谢张鸿阳大神提供这么好用的库.\n\n[AndroidAutoLayout的github](https://github.com/hongyangAndroid/AndroidAutoLayout)\n[鸿神写的AutoLayout的介绍文章](http://blog.csdn.net/lmj623565791/article/details/49990941)\n[AndroidAutoLayout的项目介绍](https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md)\n\n以上介绍中还附上了许多进阶用法,学习中...","slug":"一个好用的Android比例自动适配的库","published":1,"updated":"2017-02-28T09:59:26.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2k76hpp0003ssrlv7bg5yhr","content":"<p>今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.<br>刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.<br>而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.</p>\n<p>这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>1.首先添加库引用.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'com.zhy:autolayout:1.4.5'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.在项目的AndroidManifest中注明设计稿的尺寸。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_width\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"768\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_height\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"1280\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>3.界面的改动.</p>\n<ul>\n<li>Activity界面的用法</li>\n</ul>\n<p>让Activity继承AutoLayoutActivity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AutoLayoutActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">.......</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Fragment界面的用法</li>\n</ul>\n<p>在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Nullable</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\tView view = inflater.inflate(.......);</div><div class=\"line\">\t.........</div><div class=\"line\">\t.........</div><div class=\"line\">\tAutoUtils.autoSize(view);</div><div class=\"line\">\t<span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>动态生成的view的用法</li>\n</ul>\n<p>以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//动态生成pageBtn,并且动态设置宽高间隔等</span></div><div class=\"line\">TextView pageBtn = <span class=\"keyword\">new</span> TextView(getApplicationContext());</div><div class=\"line\">pageBtn.setPadding(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\">pageBtn.setTextSize(<span class=\"number\">25</span>);</div><div class=\"line\">LinearLayout.LayoutParams layoutParams = <span class=\"keyword\">new</span> LinearLayout.LayoutParams(<span class=\"number\">40</span> , <span class=\"number\">40</span>);</div><div class=\"line\">layoutParams.setMargins(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在全部生成完毕后,添加至容器之前调整大小.</span></div><div class=\"line\">AutoUtils.autoSize(pageBtn);</div><div class=\"line\"></div><div class=\"line\">pageBtnContainer.addView(pageBtn , layoutParams);</div></pre></td></tr></table></figure>\n<p>做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.<br>集成完毕,适配完成,就这么简单~</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>感谢张鸿阳大神提供这么好用的库.</p>\n<p><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout\" target=\"_blank\" rel=\"external\">AndroidAutoLayout的github</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/49990941\" target=\"_blank\" rel=\"external\">鸿神写的AutoLayout的介绍文章</a><br><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md\" target=\"_blank\" rel=\"external\">AndroidAutoLayout的项目介绍</a></p>\n<p>以上介绍中还附上了许多进阶用法,学习中…</p>\n","excerpt":"","more":"<p>今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.<br>刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.<br>而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.</p>\n<p>这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>1.首先添加库引用.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'com.zhy:autolayout:1.4.5'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.在项目的AndroidManifest中注明设计稿的尺寸。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_width\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"768\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_height\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"1280\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>3.界面的改动.</p>\n<ul>\n<li>Activity界面的用法</li>\n</ul>\n<p>让Activity继承AutoLayoutActivity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AutoLayoutActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">.......</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Fragment界面的用法</li>\n</ul>\n<p>在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Nullable</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\tView view = inflater.inflate(.......);</div><div class=\"line\">\t.........</div><div class=\"line\">\t.........</div><div class=\"line\">\tAutoUtils.autoSize(view);</div><div class=\"line\">\t<span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>动态生成的view的用法</li>\n</ul>\n<p>以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//动态生成pageBtn,并且动态设置宽高间隔等</span></div><div class=\"line\">TextView pageBtn = <span class=\"keyword\">new</span> TextView(getApplicationContext());</div><div class=\"line\">pageBtn.setPadding(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\">pageBtn.setTextSize(<span class=\"number\">25</span>);</div><div class=\"line\">LinearLayout.LayoutParams layoutParams = <span class=\"keyword\">new</span> LinearLayout.LayoutParams(<span class=\"number\">40</span> , <span class=\"number\">40</span>);</div><div class=\"line\">layoutParams.setMargins(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在全部生成完毕后,添加至容器之前调整大小.</span></div><div class=\"line\">AutoUtils.autoSize(pageBtn);</div><div class=\"line\"></div><div class=\"line\">pageBtnContainer.addView(pageBtn , layoutParams);</div></pre></td></tr></table></figure>\n<p>做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.<br>集成完毕,适配完成,就这么简单~</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>感谢张鸿阳大神提供这么好用的库.</p>\n<p><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout\">AndroidAutoLayout的github</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/49990941\">鸿神写的AutoLayout的介绍文章</a><br><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md\">AndroidAutoLayout的项目介绍</a></p>\n<p>以上介绍中还附上了许多进阶用法,学习中…</p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-Litho是什么?","date":"2017-04-25T02:58:01.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/intro)\n## 介绍Litho\n### Litho是什么?\n\n</p>\n</p>\n\nLitho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架[主要是被设计](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/)用来实现在RecyclerView上构建复杂的可滚动的UI的.\n\n通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.\n\n``` java\n@LayoutSpec\nclass HelloComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String name) {\n\n    return Text.create(c)\n        .text(\"Hello, \" + name)\n        .textSizeRes(R.dimen.my_text_size)\n        .textColor(Color.BLACK)\n        .withLayout()\n        .paddingDip(ALL, 10)\n        .build();\n  }\n}\n```\n\n你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——[使用后台线程计算布局参数](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)、[自动扁平化层级结构](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/)、还有使用[增量式挂载机制](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)处理复杂的component。\n\n我们的[教程](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/)可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读\"快速开始\"来学习如何[编写](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/)和[使用](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)Litho的Component。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译-Litho是什么.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-Litho是什么?\ndate: 2017-04-25 10:58:01\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/intro)\n## 介绍Litho\n### Litho是什么?\n\n</p>\n</p>\n\nLitho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架[主要是被设计](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/)用来实现在RecyclerView上构建复杂的可滚动的UI的.\n\n通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.\n\n``` java\n@LayoutSpec\nclass HelloComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String name) {\n\n    return Text.create(c)\n        .text(\"Hello, \" + name)\n        .textSizeRes(R.dimen.my_text_size)\n        .textColor(Color.BLACK)\n        .withLayout()\n        .paddingDip(ALL, 10)\n        .build();\n  }\n}\n```\n\n你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——[使用后台线程计算布局参数](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)、[自动扁平化层级结构](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/)、还有使用[增量式挂载机制](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)处理复杂的component。\n\n我们的[教程](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/)可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读\"快速开始\"来学习如何[编写](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/)和[使用](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)Litho的Component。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-Litho是什么","published":1,"updated":"2017-05-11T09:21:31.880Z","_id":"cj2k76hpv0004ssrl3oqfdpby","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/intro\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h2><h3 id=\"Litho是什么\"><a href=\"#Litho是什么\" class=\"headerlink\" title=\"Litho是什么?\"></a>Litho是什么?</h3><p></p><br><p></p><p></p>\n<p>Litho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架<a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/\">主要是被设计</a>用来实现在RecyclerView上构建复杂的可滚动的UI的.</p>\n<p>通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String name) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> Text.create(c)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello, \"</span> + name)</div><div class=\"line\">        .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">        .textColor(Color.BLACK)</div><div class=\"line\">        .withLayout()</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">10</span>)</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">使用后台线程计算布局参数</a>、<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/\">自动扁平化层级结构</a>、还有使用<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载机制</a>处理复杂的component。</p>\n<p>我们的<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/\">教程</a>可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读”快速开始”来学习如何<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/\">编写</a>和<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用</a>Litho的Component。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/intro\">Litho-doc</a></p>\n<h2 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h2><h3 id=\"Litho是什么\"><a href=\"#Litho是什么\" class=\"headerlink\" title=\"Litho是什么?\"></a>Litho是什么?</h3><p></p><br></p></p>\n<p>Litho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架<a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/\">主要是被设计</a>用来实现在RecyclerView上构建复杂的可滚动的UI的.</p>\n<p>通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> Text.create(c)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello, \"</span> + name)</div><div class=\"line\">        .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">        .textColor(Color.BLACK)</div><div class=\"line\">        .withLayout()</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">10</span>)</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">使用后台线程计算布局参数</a>、<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/\">自动扁平化层级结构</a>、还有使用<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载机制</a>处理复杂的component。</p>\n<p>我们的<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/\">教程</a>可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读”快速开始”来学习如何<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/\">编写</a>和<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用</a>Litho的Component。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"为你的Github README生成漂亮的徽章和进度条","date":"2017-03-01T07:08:41.000Z","_content":"### github上常见的徽章标签和进度条\n平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如\n![](https://img.shields.io/github/release/qubyte/rubidium.svg)\n\n![](https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg)\n\n这样的徽章样式的标签.\n\n甚至还有些文章会有\n![](http://progressed.io/bar/28?title=progress)\n\n![](http://progressed.io/bar/91?title=done)\n这样的进度条,简直炫酷.这是怎么做到的呢?\n\n### 已有的标签小程序\n网上搜了一下,用[shields.io](http://shields.io/)就可以解决!\n但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.\n\n我的理解这个网站提供了一批\"标签小程序\",他们的作用是抓取一些动态的数据并自动生成标签图片.\n比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.\n使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.\n\n举例来说:\n![](/image/20170301152451.png)\n\n这一行的小程序功能就是用来展示某一个github项目最新的release版本号.\n\n点开你可以看到如下界面\n\n![](/image/20170301152527.png)\n\nImage这一行就是小程序的URL,前面的\n``` html\nhttps://img.shields.io/github/release/\n```\n是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目\n\n![](/image/20170301153213.png)\n\n它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成\n``` html\nhttps://img.shields.io/github/release/Tencent/tinker.svg\n```\n\n这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下\n![](https://img.shields.io/github/release/Tencent/tinker.svg)\n是不是很炫酷?\n再上[tinker-release](https://github.com/Tencent/tinker/releases)的github上看一下,果然显示的版本号就是tinker最新的版本号.\n\n等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?\n其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:\nLink后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.\n\n填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.\n\n最下方的\n```\nDocumentation\n\nIf your GitHub badge errors, it might be because you hit GitHub's rate limits.\nYou can increase Shields.io's rate limit by going to this page to add Shields as a GitHub application on your GitHub account.\n\n```\n\n的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.\n\n### 生成自定义徽章标签\n\n那么,如果我们想要生成的徽章字样和颜色[shields.io](http://shields.io/)上面没有怎么办?\n例如我们想生成一个\n![](https://img.shields.io/badge/Hey!-Bro~-red.svg)\n的徽章我们应该怎么做呢?\n\n把shields的网站拉到最后,可以看见\n\n![](/image/20170301160933.png)\n\n对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!\ncolor的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦\n\n### 生成进度条标签\n\n最后,我们想生成进度条怎么办?\n\n使用[progressed.io](https://github.com/fehmicansaglam/progressed.io)很简单就能生成!\n\n如图\n\n![](/image/20170301161732.png)\n\n只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.\n\n### 其他\n- 如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.\n\n``` markdown\n[![](徽章/进度条URL)](点击超链接)\n```\n\n- 自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.\n","source":"_posts/2017-03-01-为你的Github生成漂亮的徽章和进度条.md","raw":"---\ntitle: 为你的Github README生成漂亮的徽章和进度条\ndate: 2017-03-01 15:08:41\ntags: [github]\ncategory: 其他知识\n---\n### github上常见的徽章标签和进度条\n平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如\n![](https://img.shields.io/github/release/qubyte/rubidium.svg)\n\n![](https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg)\n\n这样的徽章样式的标签.\n\n甚至还有些文章会有\n![](http://progressed.io/bar/28?title=progress)\n\n![](http://progressed.io/bar/91?title=done)\n这样的进度条,简直炫酷.这是怎么做到的呢?\n\n### 已有的标签小程序\n网上搜了一下,用[shields.io](http://shields.io/)就可以解决!\n但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.\n\n我的理解这个网站提供了一批\"标签小程序\",他们的作用是抓取一些动态的数据并自动生成标签图片.\n比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.\n使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.\n\n举例来说:\n![](/image/20170301152451.png)\n\n这一行的小程序功能就是用来展示某一个github项目最新的release版本号.\n\n点开你可以看到如下界面\n\n![](/image/20170301152527.png)\n\nImage这一行就是小程序的URL,前面的\n``` html\nhttps://img.shields.io/github/release/\n```\n是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目\n\n![](/image/20170301153213.png)\n\n它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成\n``` html\nhttps://img.shields.io/github/release/Tencent/tinker.svg\n```\n\n这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下\n![](https://img.shields.io/github/release/Tencent/tinker.svg)\n是不是很炫酷?\n再上[tinker-release](https://github.com/Tencent/tinker/releases)的github上看一下,果然显示的版本号就是tinker最新的版本号.\n\n等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?\n其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:\nLink后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.\n\n填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.\n\n最下方的\n```\nDocumentation\n\nIf your GitHub badge errors, it might be because you hit GitHub's rate limits.\nYou can increase Shields.io's rate limit by going to this page to add Shields as a GitHub application on your GitHub account.\n\n```\n\n的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.\n\n### 生成自定义徽章标签\n\n那么,如果我们想要生成的徽章字样和颜色[shields.io](http://shields.io/)上面没有怎么办?\n例如我们想生成一个\n![](https://img.shields.io/badge/Hey!-Bro~-red.svg)\n的徽章我们应该怎么做呢?\n\n把shields的网站拉到最后,可以看见\n\n![](/image/20170301160933.png)\n\n对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!\ncolor的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦\n\n### 生成进度条标签\n\n最后,我们想生成进度条怎么办?\n\n使用[progressed.io](https://github.com/fehmicansaglam/progressed.io)很简单就能生成!\n\n如图\n\n![](/image/20170301161732.png)\n\n只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.\n\n### 其他\n- 如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.\n\n``` markdown\n[![](徽章/进度条URL)](点击超链接)\n```\n\n- 自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.\n","slug":"为你的Github生成漂亮的徽章和进度条","published":1,"updated":"2017-03-01T09:01:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2k76hpz0007ssrlc2kmhy78","content":"<h3 id=\"github上常见的徽章标签和进度条\"><a href=\"#github上常见的徽章标签和进度条\" class=\"headerlink\" title=\"github上常见的徽章标签和进度条\"></a>github上常见的徽章标签和进度条</h3><p>平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如<br><img src=\"https://img.shields.io/github/release/qubyte/rubidium.svg\" alt=\"\"></p>\n<p><img src=\"https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg\" alt=\"\"></p>\n<p>这样的徽章样式的标签.</p>\n<p>甚至还有些文章会有<br><img src=\"http://progressed.io/bar/28?title=progress\" alt=\"\"></p>\n<p><img src=\"http://progressed.io/bar/91?title=done\" alt=\"\"><br>这样的进度条,简直炫酷.这是怎么做到的呢?</p>\n<h3 id=\"已有的标签小程序\"><a href=\"#已有的标签小程序\" class=\"headerlink\" title=\"已有的标签小程序\"></a>已有的标签小程序</h3><p>网上搜了一下,用<a href=\"http://shields.io/\" target=\"_blank\" rel=\"external\">shields.io</a>就可以解决!<br>但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.</p>\n<p>我的理解这个网站提供了一批”标签小程序”,他们的作用是抓取一些动态的数据并自动生成标签图片.<br>比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.<br>使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.</p>\n<p>举例来说:<br><img src=\"/image/20170301152451.png\" alt=\"\"></p>\n<p>这一行的小程序功能就是用来展示某一个github项目最新的release版本号.</p>\n<p>点开你可以看到如下界面</p>\n<p><img src=\"/image/20170301152527.png\" alt=\"\"></p>\n<p>Image这一行就是小程序的URL,前面的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/</div></pre></td></tr></table></figure></p>\n<p>是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目</p>\n<p><img src=\"/image/20170301153213.png\" alt=\"\"></p>\n<p>它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/Tencent/tinker.svg</div></pre></td></tr></table></figure></p>\n<p>这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下<br><img src=\"https://img.shields.io/github/release/Tencent/tinker.svg\" alt=\"\"><br>是不是很炫酷?<br>再上<a href=\"https://github.com/Tencent/tinker/releases\" target=\"_blank\" rel=\"external\">tinker-release</a>的github上看一下,果然显示的版本号就是tinker最新的版本号.</p>\n<p>等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?<br>其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:<br>Link后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.</p>\n<p>填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.</p>\n<p>最下方的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Documentation</div><div class=\"line\"></div><div class=\"line\">If your GitHub badge errors, it might be because you hit GitHub&apos;s rate limits.</div><div class=\"line\">You can increase Shields.io&apos;s rate limit by going to this page to add Shields as a GitHub application on your GitHub account.</div></pre></td></tr></table></figure></p>\n<p>的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.</p>\n<h3 id=\"生成自定义徽章标签\"><a href=\"#生成自定义徽章标签\" class=\"headerlink\" title=\"生成自定义徽章标签\"></a>生成自定义徽章标签</h3><p>那么,如果我们想要生成的徽章字样和颜色<a href=\"http://shields.io/\" target=\"_blank\" rel=\"external\">shields.io</a>上面没有怎么办?<br>例如我们想生成一个<br><img src=\"https://img.shields.io/badge/Hey!-Bro~-red.svg\" alt=\"\"><br>的徽章我们应该怎么做呢?</p>\n<p>把shields的网站拉到最后,可以看见</p>\n<p><img src=\"/image/20170301160933.png\" alt=\"\"></p>\n<p>对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!<br>color的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦</p>\n<h3 id=\"生成进度条标签\"><a href=\"#生成进度条标签\" class=\"headerlink\" title=\"生成进度条标签\"></a>生成进度条标签</h3><p>最后,我们想生成进度条怎么办?</p>\n<p>使用<a href=\"https://github.com/fehmicansaglam/progressed.io\" target=\"_blank\" rel=\"external\">progressed.io</a>很简单就能生成!</p>\n<p>如图</p>\n<p><img src=\"/image/20170301161732.png\" alt=\"\"></p>\n<p>只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">![</span>](<span class=\"link\">徽章/进度条URL</span>)](<span class=\"link\">点击超链接</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"github上常见的徽章标签和进度条\"><a href=\"#github上常见的徽章标签和进度条\" class=\"headerlink\" title=\"github上常见的徽章标签和进度条\"></a>github上常见的徽章标签和进度条</h3><p>平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如<br><img src=\"https://img.shields.io/github/release/qubyte/rubidium.svg\" alt=\"\"></p>\n<p><img src=\"https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg\" alt=\"\"></p>\n<p>这样的徽章样式的标签.</p>\n<p>甚至还有些文章会有<br><img src=\"http://progressed.io/bar/28?title=progress\" alt=\"\"></p>\n<p><img src=\"http://progressed.io/bar/91?title=done\" alt=\"\"><br>这样的进度条,简直炫酷.这是怎么做到的呢?</p>\n<h3 id=\"已有的标签小程序\"><a href=\"#已有的标签小程序\" class=\"headerlink\" title=\"已有的标签小程序\"></a>已有的标签小程序</h3><p>网上搜了一下,用<a href=\"http://shields.io/\">shields.io</a>就可以解决!<br>但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.</p>\n<p>我的理解这个网站提供了一批”标签小程序”,他们的作用是抓取一些动态的数据并自动生成标签图片.<br>比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.<br>使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.</p>\n<p>举例来说:<br><img src=\"/image/20170301152451.png\" alt=\"\"></p>\n<p>这一行的小程序功能就是用来展示某一个github项目最新的release版本号.</p>\n<p>点开你可以看到如下界面</p>\n<p><img src=\"/image/20170301152527.png\" alt=\"\"></p>\n<p>Image这一行就是小程序的URL,前面的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/</div></pre></td></tr></table></figure></p>\n<p>是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目</p>\n<p><img src=\"/image/20170301153213.png\" alt=\"\"></p>\n<p>它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/Tencent/tinker.svg</div></pre></td></tr></table></figure></p>\n<p>这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下<br><img src=\"https://img.shields.io/github/release/Tencent/tinker.svg\" alt=\"\"><br>是不是很炫酷?<br>再上<a href=\"https://github.com/Tencent/tinker/releases\">tinker-release</a>的github上看一下,果然显示的版本号就是tinker最新的版本号.</p>\n<p>等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?<br>其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:<br>Link后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.</p>\n<p>填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.</p>\n<p>最下方的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Documentation</div><div class=\"line\"></div><div class=\"line\">If your GitHub badge errors, it might be because you hit GitHub&apos;s rate limits.</div><div class=\"line\">You can increase Shields.io&apos;s rate limit by going to this page to add Shields as a GitHub application on your GitHub account.</div></pre></td></tr></table></figure></p>\n<p>的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.</p>\n<h3 id=\"生成自定义徽章标签\"><a href=\"#生成自定义徽章标签\" class=\"headerlink\" title=\"生成自定义徽章标签\"></a>生成自定义徽章标签</h3><p>那么,如果我们想要生成的徽章字样和颜色<a href=\"http://shields.io/\">shields.io</a>上面没有怎么办?<br>例如我们想生成一个<br><img src=\"https://img.shields.io/badge/Hey!-Bro~-red.svg\" alt=\"\"><br>的徽章我们应该怎么做呢?</p>\n<p>把shields的网站拉到最后,可以看见</p>\n<p><img src=\"/image/20170301160933.png\" alt=\"\"></p>\n<p>对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!<br>color的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦</p>\n<h3 id=\"生成进度条标签\"><a href=\"#生成进度条标签\" class=\"headerlink\" title=\"生成进度条标签\"></a>生成进度条标签</h3><p>最后,我们想生成进度条怎么办?</p>\n<p>使用<a href=\"https://github.com/fehmicansaglam/progressed.io\">progressed.io</a>很简单就能生成!</p>\n<p>如图</p>\n<p><img src=\"/image/20170301161732.png\" alt=\"\"></p>\n<p>只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">![</span>](<span class=\"link\">徽章/进度条URL</span>)](<span class=\"link\">点击超链接</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.</li>\n</ul>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-使用","date":"2017-04-25T02:58:01.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/uses)\n## 介绍Litho\n### 使用\n\n</p>\n</p>\n\nLitho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.\n\n你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.\n\n高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译-使用.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-使用\ndate: 2017-04-25 10:58:01\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/uses)\n## 介绍Litho\n### 使用\n\n</p>\n</p>\n\nLitho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.\n\n你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.\n\n高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-使用","published":1,"updated":"2017-05-11T09:22:27.395Z","_id":"cj2k76hq00008ssrlj8yys9c0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/uses\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h2><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p></p><br><p></p><p></p>\n<p>Litho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.</p>\n<p>你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.</p>\n<p>高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/uses\">Litho-doc</a></p>\n<h2 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h2><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p></p><br></p></p>\n<p>Litho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.</p>\n<p>你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.</p>\n<p>高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-View的扁平化","date":"2017-04-27T02:09:23.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/view-flattening)\n## 架构\n### View的扁平化\n\n</p>\n</p>\n\n让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.\n\n![](/image/20170426150749.png)\n\nLitho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。\n\n我们使用两种途径来实现:\n首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。\n第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。\n\n这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点([启用了开发者选项中的显示布局边界]()).\n\n![](/image/20170426150806.png)\n\n虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构\"去扁平化\"。例如，如果要在示例中启用单击图像或文本，如果设置了[点击处理器](),框架将自动把文字或图像包装在view一个新的view中。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-View的扁平化.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-View的扁平化\ndate: 2017-04-27 10:09:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/view-flattening)\n## 架构\n### View的扁平化\n\n</p>\n</p>\n\n让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.\n\n![](/image/20170426150749.png)\n\nLitho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。\n\n我们使用两种途径来实现:\n首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。\n第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。\n\n这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点([启用了开发者选项中的显示布局边界]()).\n\n![](/image/20170426150806.png)\n\n虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构\"去扁平化\"。例如，如果要在示例中启用单击图像或文本，如果设置了[点击处理器](),框架将自动把文字或图像包装在view一个新的view中。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-View的扁平化","published":1,"updated":"2017-05-11T09:33:55.053Z","_id":"cj2k76hq10009ssrl25ckqrkz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/view-flattening\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"View的扁平化\"><a href=\"#View的扁平化\" class=\"headerlink\" title=\"View的扁平化\"></a>View的扁平化</h3><p></p><br><p></p><p></p>\n<p>让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.</p>\n<p><img src=\"/image/20170426150749.png\" alt=\"\"></p>\n<p>Litho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。</p>\n<p>我们使用两种途径来实现:<br>首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。<br>第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。</p>\n<p>这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点(<a href=\"\">启用了开发者选项中的显示布局边界</a>).</p>\n<p><img src=\"/image/20170426150806.png\" alt=\"\"></p>\n<p>虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构”去扁平化”。例如，如果要在示例中启用单击图像或文本，如果设置了<a href=\"\">点击处理器</a>,框架将自动把文字或图像包装在view一个新的view中。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/view-flattening\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"View的扁平化\"><a href=\"#View的扁平化\" class=\"headerlink\" title=\"View的扁平化\"></a>View的扁平化</h3><p></p><br></p></p>\n<p>让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.</p>\n<p><img src=\"/image/20170426150749.png\" alt=\"\"></p>\n<p>Litho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。</p>\n<p>我们使用两种途径来实现:<br>首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。<br>第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。</p>\n<p>这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点(<a href=\"\">启用了开发者选项中的显示布局边界</a>).</p>\n<p><img src=\"/image/20170426150806.png\" alt=\"\"></p>\n<p>虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构”去扁平化”。例如，如果要在示例中启用单击图像或文本，如果设置了<a href=\"\">点击处理器</a>,框架将自动把文字或图像包装在view一个新的view中。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-编写动机","date":"2017-04-25T02:58:01.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/motivation)\n## 介绍Litho\n### 编写动机\n\n</p>\n</p>\n\n在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。\n\n当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。\n\n你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.\n\n如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的\"坑\",但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.\n\n你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.\n\nLitho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译-编写动机 .md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-编写动机\ndate: 2017-04-25 10:58:01\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/motivation)\n## 介绍Litho\n### 编写动机\n\n</p>\n</p>\n\n在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。\n\n当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。\n\n你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.\n\n如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的\"坑\",但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.\n\n你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.\n\nLitho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-编写动机 ","published":1,"updated":"2017-05-11T09:22:04.177Z","_id":"cj2k76hq3000cssrluc252det","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/motivation\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h2><h3 id=\"编写动机\"><a href=\"#编写动机\" class=\"headerlink\" title=\"编写动机\"></a>编写动机</h3><p></p><br><p></p><p></p>\n<p>在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。</p>\n<p>当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。</p>\n<p>你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.</p>\n<p>如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的”坑”,但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.</p>\n<p>你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.</p>\n<p>Litho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/motivation\">Litho-doc</a></p>\n<h2 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h2><h3 id=\"编写动机\"><a href=\"#编写动机\" class=\"headerlink\" title=\"编写动机\"></a>编写动机</h3><p></p><br></p></p>\n<p>在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。</p>\n<p>当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。</p>\n<p>你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.</p>\n<p>如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的”坑”,但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.</p>\n<p>你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.</p>\n<p>Litho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"如何使用github和Hexo搭建个人博客","date":"2017-02-23T07:05:13.000Z","_content":"\n\n## 为什么要写个人博客?\n这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.\n\n之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^\n\n## 为什么要自己搭建博客系统?\n想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?\n\n所以,我果断放弃了博客平台,自己搭架子!开干!\n\n## 大体上需要做什么工作?\n博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.\n\n1. 怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?\n2. 我们的博客网页文件放在什么地方?\n\n### 博客框架介绍\n以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.\n那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.\n\n博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!\n\n\n而博客框架一般分为**动态页面框架**和**静态页面框架**两种.\n#### 动态框架\n动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.\n由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.\n\n#### 静态框架\n这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.\n这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).\n\n### 网页存放空间介绍\n我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.\n\n#### 购买VPS\nVPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.\n由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.\n\n#### 使用Github pages\nGitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.\n\n## 为什么选择GitHub pages + Hexo?\n看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!\n一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!\n对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.\n\n那么,既然方案确定了,那就剩实施了,我们一步一步来完成:\n\n\n## 如何获得github page网页空间?\n使用github我们当然需要先安装git,如果你没有用过git,请先学习一下[Git使用教程](http://www.cnblogs.com/tugenhua0707/p/4050072.html).\n获得github page空间非常简单.首先,你得有一个女朋...啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去[注册一个](https://github.com/join?source=header-home),这个网站对程序员非常有用,真的!\n\n有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).\n\n第一步我们点击sign in登录github.\n![](/image/20170223175427.png)\n\n第二步我们点击New repository建立一个新的仓库\n![](/image/20170223174812.png)\n\n第三步在仓库名称里面输入**我们的用户名.github.io**.\n注意!必须是这个名字,其他的名字不行!\n比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io\n![](/image/20170223175801.png)\n\n第四步选择public,并且点击create repository建立仓库\n\n建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过\n``` \nhttp://我们的用户名.github.io\n```\n就能访问我们的博客啦.\n\n今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.\n\n## 如何部署Hexo框架?\nHexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs\n\n在[Nodejs官网](https://nodejs.org/en/)上下载并安装Nodejs.\n\n安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog\n\n在文件夹里右键选择git bash 打开命令行\n\n使用npm安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.\n由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.\n\n由于我们要提交到github上,我们还需要安装hexo git提交插件.\n``` base\nnpm install hexo-deployer-git --save\n```\n\n下面初始化博客工程\n\n``` bash\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n上面的folder为博客的工程名,我们可以自己起,例如testBlog\n\n完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.\n\n> title: 这里填写博客的标题\n> subtitle: 这里填写博客的副标题\n> description: 这里填写博客的描述\n> author: 这里填写博客的作者\n> language: 这里填写博客的语言,如果是中文填写\"zh\"\n> url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为\"aaa\",这里就填写\"http://aaa.github.io\"\n> deploy:\n> type: 这里填写\"git\"\n> repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为\"aaa\",则此处填写\"git@github.com:aaa/aaa.github.io.git\"\n\n暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.\n如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看[官方配置说明](https://hexo.io/docs/configuration.html)\n\n此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.\n\n``` base\nhexo g -d\n```\n\n这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.\n等待命令执行完毕.\n\n好了,现在我们访问我们的博客试一下,打开浏览器输入\n```\nhttp://你的github用户名.github.io \n```\n然后回车.\n![](/image/20170224160822.png)\n哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.\n\n## 如何写文章?\n博客架好了,可是我们怎么写文章呢?\n也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例\n``` base\ncd /d/blog/testBlog\nhexo new goodDay\n```\n这样我们就建立了一篇名叫goodDay的新文章.\n\n此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\\\_posts.\n我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.\n从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看[markdown入门](http://sspai.com/25137/)\n虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如[MarkdownPad](http://markdownpad.com),来编辑,可以方便的实现边编辑边预览,非常方便.\n文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.\n\n打开goodDay.md,我们可以看到如下的内容\n```\n---\ntitle: xxx\ndate: xxx\n---\n```\n这些以---开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为\"好天气\",文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:\"前端知识\",方便以后管理.\ngoodDay.md修改如下\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n```\n\n在---下方我们可以编辑我们文章的正文了,我们简单写两句\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n\n## 好天气啊\n### What a Good Day!\n真是适合春游的好天气\n```\n\n保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?\n``` base\nhexo g -d\n```\n\n这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~\\(^o^)/~\n![](/image/20170224163724.png)\n\n好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.\n\n由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.\n\n感谢各位能看到这里.希望大家都能玩的开心.\n\n\n\n","source":"_posts/2017-02-23-如何使用gitHub和Hexo搭建个人博客.md","raw":"---\ntitle: 如何使用github和Hexo搭建个人博客\ndate: 2017-02-23 15:05:13\ntags: [Hexo,Web,github]\ncategory: Web前端知识\n---\n\n\n## 为什么要写个人博客?\n这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.\n\n之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^\n\n## 为什么要自己搭建博客系统?\n想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?\n\n所以,我果断放弃了博客平台,自己搭架子!开干!\n\n## 大体上需要做什么工作?\n博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.\n\n1. 怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?\n2. 我们的博客网页文件放在什么地方?\n\n### 博客框架介绍\n以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.\n那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.\n\n博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!\n\n\n而博客框架一般分为**动态页面框架**和**静态页面框架**两种.\n#### 动态框架\n动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.\n由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.\n\n#### 静态框架\n这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.\n这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).\n\n### 网页存放空间介绍\n我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.\n\n#### 购买VPS\nVPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.\n由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.\n\n#### 使用Github pages\nGitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.\n\n## 为什么选择GitHub pages + Hexo?\n看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!\n一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!\n对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.\n\n那么,既然方案确定了,那就剩实施了,我们一步一步来完成:\n\n\n## 如何获得github page网页空间?\n使用github我们当然需要先安装git,如果你没有用过git,请先学习一下[Git使用教程](http://www.cnblogs.com/tugenhua0707/p/4050072.html).\n获得github page空间非常简单.首先,你得有一个女朋...啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去[注册一个](https://github.com/join?source=header-home),这个网站对程序员非常有用,真的!\n\n有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).\n\n第一步我们点击sign in登录github.\n![](/image/20170223175427.png)\n\n第二步我们点击New repository建立一个新的仓库\n![](/image/20170223174812.png)\n\n第三步在仓库名称里面输入**我们的用户名.github.io**.\n注意!必须是这个名字,其他的名字不行!\n比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io\n![](/image/20170223175801.png)\n\n第四步选择public,并且点击create repository建立仓库\n\n建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过\n``` \nhttp://我们的用户名.github.io\n```\n就能访问我们的博客啦.\n\n今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.\n\n## 如何部署Hexo框架?\nHexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs\n\n在[Nodejs官网](https://nodejs.org/en/)上下载并安装Nodejs.\n\n安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog\n\n在文件夹里右键选择git bash 打开命令行\n\n使用npm安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.\n由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.\n\n由于我们要提交到github上,我们还需要安装hexo git提交插件.\n``` base\nnpm install hexo-deployer-git --save\n```\n\n下面初始化博客工程\n\n``` bash\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n上面的folder为博客的工程名,我们可以自己起,例如testBlog\n\n完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.\n\n> title: 这里填写博客的标题\n> subtitle: 这里填写博客的副标题\n> description: 这里填写博客的描述\n> author: 这里填写博客的作者\n> language: 这里填写博客的语言,如果是中文填写\"zh\"\n> url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为\"aaa\",这里就填写\"http://aaa.github.io\"\n> deploy:\n> type: 这里填写\"git\"\n> repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为\"aaa\",则此处填写\"git@github.com:aaa/aaa.github.io.git\"\n\n暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.\n如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看[官方配置说明](https://hexo.io/docs/configuration.html)\n\n此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.\n\n``` base\nhexo g -d\n```\n\n这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.\n等待命令执行完毕.\n\n好了,现在我们访问我们的博客试一下,打开浏览器输入\n```\nhttp://你的github用户名.github.io \n```\n然后回车.\n![](/image/20170224160822.png)\n哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.\n\n## 如何写文章?\n博客架好了,可是我们怎么写文章呢?\n也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例\n``` base\ncd /d/blog/testBlog\nhexo new goodDay\n```\n这样我们就建立了一篇名叫goodDay的新文章.\n\n此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\\\_posts.\n我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.\n从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看[markdown入门](http://sspai.com/25137/)\n虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如[MarkdownPad](http://markdownpad.com),来编辑,可以方便的实现边编辑边预览,非常方便.\n文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.\n\n打开goodDay.md,我们可以看到如下的内容\n```\n---\ntitle: xxx\ndate: xxx\n---\n```\n这些以---开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为\"好天气\",文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:\"前端知识\",方便以后管理.\ngoodDay.md修改如下\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n```\n\n在---下方我们可以编辑我们文章的正文了,我们简单写两句\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n\n## 好天气啊\n### What a Good Day!\n真是适合春游的好天气\n```\n\n保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?\n``` base\nhexo g -d\n```\n\n这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~\\(^o^)/~\n![](/image/20170224163724.png)\n\n好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.\n\n由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.\n\n感谢各位能看到这里.希望大家都能玩的开心.\n\n\n\n","slug":"如何使用gitHub和Hexo搭建个人博客","published":1,"updated":"2017-04-25T02:27:30.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2k76hq5000essrltlydhxkh","content":"<h2 id=\"为什么要写个人博客\"><a href=\"#为什么要写个人博客\" class=\"headerlink\" title=\"为什么要写个人博客?\"></a>为什么要写个人博客?</h2><p>这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.</p>\n<p>之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^</p>\n<h2 id=\"为什么要自己搭建博客系统\"><a href=\"#为什么要自己搭建博客系统\" class=\"headerlink\" title=\"为什么要自己搭建博客系统?\"></a>为什么要自己搭建博客系统?</h2><p>想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?</p>\n<p>所以,我果断放弃了博客平台,自己搭架子!开干!</p>\n<h2 id=\"大体上需要做什么工作\"><a href=\"#大体上需要做什么工作\" class=\"headerlink\" title=\"大体上需要做什么工作?\"></a>大体上需要做什么工作?</h2><p>博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.</p>\n<ol>\n<li>怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?</li>\n<li>我们的博客网页文件放在什么地方?</li>\n</ol>\n<h3 id=\"博客框架介绍\"><a href=\"#博客框架介绍\" class=\"headerlink\" title=\"博客框架介绍\"></a>博客框架介绍</h3><p>以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.<br>那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.</p>\n<p>博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!</p>\n<p>而博客框架一般分为<strong>动态页面框架</strong>和<strong>静态页面框架</strong>两种.</p>\n<h4 id=\"动态框架\"><a href=\"#动态框架\" class=\"headerlink\" title=\"动态框架\"></a>动态框架</h4><p>动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.<br>由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.</p>\n<h4 id=\"静态框架\"><a href=\"#静态框架\" class=\"headerlink\" title=\"静态框架\"></a>静态框架</h4><p>这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.<br>这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).</p>\n<h3 id=\"网页存放空间介绍\"><a href=\"#网页存放空间介绍\" class=\"headerlink\" title=\"网页存放空间介绍\"></a>网页存放空间介绍</h3><p>我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.</p>\n<h4 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h4><p>VPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.<br>由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.</p>\n<h4 id=\"使用Github-pages\"><a href=\"#使用Github-pages\" class=\"headerlink\" title=\"使用Github pages\"></a>使用Github pages</h4><p>GitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.</p>\n<h2 id=\"为什么选择GitHub-pages-Hexo\"><a href=\"#为什么选择GitHub-pages-Hexo\" class=\"headerlink\" title=\"为什么选择GitHub pages + Hexo?\"></a>为什么选择GitHub pages + Hexo?</h2><p>看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!<br>一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!<br>对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.</p>\n<p>那么,既然方案确定了,那就剩实施了,我们一步一步来完成:</p>\n<h2 id=\"如何获得github-page网页空间\"><a href=\"#如何获得github-page网页空间\" class=\"headerlink\" title=\"如何获得github page网页空间?\"></a>如何获得github page网页空间?</h2><p>使用github我们当然需要先安装git,如果你没有用过git,请先学习一下<a href=\"http://www.cnblogs.com/tugenhua0707/p/4050072.html\" target=\"_blank\" rel=\"external\">Git使用教程</a>.<br>获得github page空间非常简单.首先,你得有一个女朋…啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去<a href=\"https://github.com/join?source=header-home\" target=\"_blank\" rel=\"external\">注册一个</a>,这个网站对程序员非常有用,真的!</p>\n<p>有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).</p>\n<p>第一步我们点击sign in登录github.<br><img src=\"/image/20170223175427.png\" alt=\"\"></p>\n<p>第二步我们点击New repository建立一个新的仓库<br><img src=\"/image/20170223174812.png\" alt=\"\"></p>\n<p>第三步在仓库名称里面输入<strong>我们的用户名.github.io</strong>.<br>注意!必须是这个名字,其他的名字不行!<br>比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io<br><img src=\"/image/20170223175801.png\" alt=\"\"></p>\n<p>第四步选择public,并且点击create repository建立仓库</p>\n<p>建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://我们的用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>就能访问我们的博客啦.</p>\n<p>今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.</p>\n<h2 id=\"如何部署Hexo框架\"><a href=\"#如何部署Hexo框架\" class=\"headerlink\" title=\"如何部署Hexo框架?\"></a>如何部署Hexo框架?</h2><p>Hexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs</p>\n<p>在<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Nodejs官网</a>上下载并安装Nodejs.</p>\n<p>安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog</p>\n<p>在文件夹里右键选择git bash 打开命令行</p>\n<p>使用npm安装Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.<br>由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.</p>\n<p>由于我们要提交到github上,我们还需要安装hexo git提交插件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>下面初始化博客工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>上面的folder为博客的工程名,我们可以自己起,例如testBlog</p>\n<p>完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.</p>\n<blockquote>\n<p>title: 这里填写博客的标题<br>subtitle: 这里填写博客的副标题<br>description: 这里填写博客的描述<br>author: 这里填写博客的作者<br>language: 这里填写博客的语言,如果是中文填写”zh”<br>url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为”aaa”,这里就填写”<a href=\"http://aaa.github.io\" target=\"_blank\" rel=\"external\">http://aaa.github.io</a>“<br>deploy:<br>type: 这里填写”git”<br>repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为”aaa”,则此处填写”git@github.com:aaa/aaa.github.io.git”</p>\n</blockquote>\n<p>暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.<br>如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看<a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"external\">官方配置说明</a></p>\n<p>此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<p>这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.<br>等待命令执行完毕.</p>\n<p>好了,现在我们访问我们的博客试一下,打开浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://你的github用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>然后回车.<br><img src=\"/image/20170224160822.png\" alt=\"\"><br>哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.</p>\n<h2 id=\"如何写文章\"><a href=\"#如何写文章\" class=\"headerlink\" title=\"如何写文章?\"></a>如何写文章?</h2><p>博客架好了,可是我们怎么写文章呢?<br>也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /d/blog/testBlog</div><div class=\"line\">hexo new goodDay</div></pre></td></tr></table></figure></p>\n<p>这样我们就建立了一篇名叫goodDay的新文章.</p>\n<p>此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\_posts.<br>我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.<br>从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看<a href=\"http://sspai.com/25137/\" target=\"_blank\" rel=\"external\">markdown入门</a><br>虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如<a href=\"http://markdownpad.com\" target=\"_blank\" rel=\"external\">MarkdownPad</a>,来编辑,可以方便的实现边编辑边预览,非常方便.<br>文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.</p>\n<p>打开goodDay.md,我们可以看到如下的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: xxx</div><div class=\"line\">date: xxx</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>这些以—开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为”好天气”,文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:”前端知识”,方便以后管理.<br>goodDay.md修改如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>在—下方我们可以编辑我们文章的正文了,我们简单写两句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">## 好天气啊</div><div class=\"line\">### What a Good Day!</div><div class=\"line\">真是适合春游的好天气</div></pre></td></tr></table></figure></p>\n<p>保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure></p>\n<p>这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~(^o^)/~<br><img src=\"/image/20170224163724.png\" alt=\"\"></p>\n<p>好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.</p>\n<p>由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.</p>\n<p>感谢各位能看到这里.希望大家都能玩的开心.</p>\n","excerpt":"","more":"<h2 id=\"为什么要写个人博客\"><a href=\"#为什么要写个人博客\" class=\"headerlink\" title=\"为什么要写个人博客?\"></a>为什么要写个人博客?</h2><p>这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.</p>\n<p>之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^</p>\n<h2 id=\"为什么要自己搭建博客系统\"><a href=\"#为什么要自己搭建博客系统\" class=\"headerlink\" title=\"为什么要自己搭建博客系统?\"></a>为什么要自己搭建博客系统?</h2><p>想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?</p>\n<p>所以,我果断放弃了博客平台,自己搭架子!开干!</p>\n<h2 id=\"大体上需要做什么工作\"><a href=\"#大体上需要做什么工作\" class=\"headerlink\" title=\"大体上需要做什么工作?\"></a>大体上需要做什么工作?</h2><p>博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.</p>\n<ol>\n<li>怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?</li>\n<li>我们的博客网页文件放在什么地方?</li>\n</ol>\n<h3 id=\"博客框架介绍\"><a href=\"#博客框架介绍\" class=\"headerlink\" title=\"博客框架介绍\"></a>博客框架介绍</h3><p>以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.<br>那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.</p>\n<p>博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!</p>\n<p>而博客框架一般分为<strong>动态页面框架</strong>和<strong>静态页面框架</strong>两种.</p>\n<h4 id=\"动态框架\"><a href=\"#动态框架\" class=\"headerlink\" title=\"动态框架\"></a>动态框架</h4><p>动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.<br>由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.</p>\n<h4 id=\"静态框架\"><a href=\"#静态框架\" class=\"headerlink\" title=\"静态框架\"></a>静态框架</h4><p>这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.<br>这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).</p>\n<h3 id=\"网页存放空间介绍\"><a href=\"#网页存放空间介绍\" class=\"headerlink\" title=\"网页存放空间介绍\"></a>网页存放空间介绍</h3><p>我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.</p>\n<h4 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h4><p>VPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.<br>由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.</p>\n<h4 id=\"使用Github-pages\"><a href=\"#使用Github-pages\" class=\"headerlink\" title=\"使用Github pages\"></a>使用Github pages</h4><p>GitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.</p>\n<h2 id=\"为什么选择GitHub-pages-Hexo\"><a href=\"#为什么选择GitHub-pages-Hexo\" class=\"headerlink\" title=\"为什么选择GitHub pages + Hexo?\"></a>为什么选择GitHub pages + Hexo?</h2><p>看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!<br>一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!<br>对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.</p>\n<p>那么,既然方案确定了,那就剩实施了,我们一步一步来完成:</p>\n<h2 id=\"如何获得github-page网页空间\"><a href=\"#如何获得github-page网页空间\" class=\"headerlink\" title=\"如何获得github page网页空间?\"></a>如何获得github page网页空间?</h2><p>使用github我们当然需要先安装git,如果你没有用过git,请先学习一下<a href=\"http://www.cnblogs.com/tugenhua0707/p/4050072.html\">Git使用教程</a>.<br>获得github page空间非常简单.首先,你得有一个女朋…啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去<a href=\"https://github.com/join?source=header-home\">注册一个</a>,这个网站对程序员非常有用,真的!</p>\n<p>有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).</p>\n<p>第一步我们点击sign in登录github.<br><img src=\"/image/20170223175427.png\" alt=\"\"></p>\n<p>第二步我们点击New repository建立一个新的仓库<br><img src=\"/image/20170223174812.png\" alt=\"\"></p>\n<p>第三步在仓库名称里面输入<strong>我们的用户名.github.io</strong>.<br>注意!必须是这个名字,其他的名字不行!<br>比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io<br><img src=\"/image/20170223175801.png\" alt=\"\"></p>\n<p>第四步选择public,并且点击create repository建立仓库</p>\n<p>建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://我们的用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>就能访问我们的博客啦.</p>\n<p>今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.</p>\n<h2 id=\"如何部署Hexo框架\"><a href=\"#如何部署Hexo框架\" class=\"headerlink\" title=\"如何部署Hexo框架?\"></a>如何部署Hexo框架?</h2><p>Hexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs</p>\n<p>在<a href=\"https://nodejs.org/en/\">Nodejs官网</a>上下载并安装Nodejs.</p>\n<p>安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog</p>\n<p>在文件夹里右键选择git bash 打开命令行</p>\n<p>使用npm安装Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.<br>由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.</p>\n<p>由于我们要提交到github上,我们还需要安装hexo git提交插件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>下面初始化博客工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>上面的folder为博客的工程名,我们可以自己起,例如testBlog</p>\n<p>完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.</p>\n<blockquote>\n<p>title: 这里填写博客的标题<br>subtitle: 这里填写博客的副标题<br>description: 这里填写博客的描述<br>author: 这里填写博客的作者<br>language: 这里填写博客的语言,如果是中文填写”zh”<br>url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为”aaa”,这里就填写”<a href=\"http://aaa.github.io\">http://aaa.github.io</a>“<br>deploy:<br>type: 这里填写”git”<br>repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为”aaa”,则此处填写”git@github.com:aaa/aaa.github.io.git”</p>\n</blockquote>\n<p>暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.<br>如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看<a href=\"https://hexo.io/docs/configuration.html\">官方配置说明</a></p>\n<p>此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<p>这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.<br>等待命令执行完毕.</p>\n<p>好了,现在我们访问我们的博客试一下,打开浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://你的github用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>然后回车.<br><img src=\"/image/20170224160822.png\" alt=\"\"><br>哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.</p>\n<h2 id=\"如何写文章\"><a href=\"#如何写文章\" class=\"headerlink\" title=\"如何写文章?\"></a>如何写文章?</h2><p>博客架好了,可是我们怎么写文章呢?<br>也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /d/blog/testBlog</div><div class=\"line\">hexo new goodDay</div></pre></td></tr></table></figure></p>\n<p>这样我们就建立了一篇名叫goodDay的新文章.</p>\n<p>此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\_posts.<br>我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.<br>从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看<a href=\"http://sspai.com/25137/\">markdown入门</a><br>虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如<a href=\"http://markdownpad.com\">MarkdownPad</a>,来编辑,可以方便的实现边编辑边预览,非常方便.<br>文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.</p>\n<p>打开goodDay.md,我们可以看到如下的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: xxx</div><div class=\"line\">date: xxx</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>这些以—开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为”好天气”,文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:”前端知识”,方便以后管理.<br>goodDay.md修改如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>在—下方我们可以编辑我们文章的正文了,我们简单写两句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">## 好天气啊</div><div class=\"line\">### What a Good Day!</div><div class=\"line\">真是适合春游的好天气</div></pre></td></tr></table></figure></p>\n<p>保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure></p>\n<p>这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~(^o^)/~<br><img src=\"/image/20170224163724.png\" alt=\"\"></p>\n<p>好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.</p>\n<p>由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.</p>\n<p>感谢各位能看到这里.希望大家都能玩的开心.</p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-使用Component","date":"2017-04-27T08:05:10.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/using-started)\n## 快速开始\n### 使用Component\n\n</p>\n</p>\n\n生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个[LithoView](http://fblitho.com/javadoc/com/facebook/litho/LithoView),它是一个Android ViewGroup并且可以渲染component.\n\n你可以通过以下的代码制定一个LithoView来渲染一个Component.\n``` java\nfinal Component component = MyComponent.create()\n    .title(\"My title\")\n    .imageUri(Uri.parse(\"http://example.com/myimage\")\n    .build();\nLithoView view = LithoView.create(context, component);\n```\n\n在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在[教程](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/)里看到如何在一个Acitivity中使用这个LithoView.\n\n重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅[异步布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/).\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>\n","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-使用Component.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-使用Component\ndate: 2017-04-27 16:05:10\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/using-started)\n## 快速开始\n### 使用Component\n\n</p>\n</p>\n\n生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个[LithoView](http://fblitho.com/javadoc/com/facebook/litho/LithoView),它是一个Android ViewGroup并且可以渲染component.\n\n你可以通过以下的代码制定一个LithoView来渲染一个Component.\n``` java\nfinal Component component = MyComponent.create()\n    .title(\"My title\")\n    .imageUri(Uri.parse(\"http://example.com/myimage\")\n    .build();\nLithoView view = LithoView.create(context, component);\n```\n\n在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在[教程](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/)里看到如何在一个Acitivity中使用这个LithoView.\n\n重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅[异步布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/).\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-使用Component","published":1,"updated":"2017-05-11T09:24:27.913Z","_id":"cj2k76hq7000issrl4ow0mqtl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/using-started\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"使用Component\"><a href=\"#使用Component\" class=\"headerlink\" title=\"使用Component\"></a>使用Component</h3><p></p><br><p></p><p></p>\n<p>生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/LithoView\" target=\"_blank\" rel=\"external\">LithoView</a>,它是一个Android ViewGroup并且可以渲染component.</p>\n<p>你可以通过以下的代码制定一个LithoView来渲染一个Component.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component component = MyComponent.create()</div><div class=\"line\">    .title(<span class=\"string\">\"My title\"</span>)</div><div class=\"line\">    .imageUri(Uri.parse(<span class=\"string\">\"http://example.com/myimage\"</span>)</div><div class=\"line\">    .build();</div><div class=\"line\">LithoView view = LithoView.create(context, component);</div></pre></td></tr></table></figure></p>\n<p>在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/\">教程</a>里看到如何在一个Acitivity中使用这个LithoView.</p>\n<p>重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">异步布局</a>.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/using-started\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"使用Component\"><a href=\"#使用Component\" class=\"headerlink\" title=\"使用Component\"></a>使用Component</h3><p></p><br></p></p>\n<p>生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/LithoView\">LithoView</a>,它是一个Android ViewGroup并且可以渲染component.</p>\n<p>你可以通过以下的代码制定一个LithoView来渲染一个Component.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component component = MyComponent.create()</div><div class=\"line\">    .title(<span class=\"string\">\"My title\"</span>)</div><div class=\"line\">    .imageUri(Uri.parse(<span class=\"string\">\"http://example.com/myimage\"</span>)</div><div class=\"line\">    .build();</div><div class=\"line\">LithoView view = LithoView.create(context, component);</div></pre></td></tr></table></figure></p>\n<p>在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/\">教程</a>里看到如何在一个Acitivity中使用这个LithoView.</p>\n<p>重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">异步布局</a>.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-准备工作","date":"2017-04-27T08:05:10.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/getting-started)\n## 快速开始\n### 准备工作\n\n</p>\n</p>\n\n#### 集成Litho至你的工程\n---\n\n</p>\n</p>\n\n##### gradle\n\n</p>\n</p>\n\n你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.\n``` gradle\ndependencies {\n  // ...\n  // Litho\n  compile 'com.facebook.litho:litho-core:0.2.0'\n  compile 'com.facebook.litho:litho-widget:0.2.0'\n  provided 'com.facebook.litho:litho-annotations:0.2.0'\n\n  annotationProcessor 'com.facebook.litho:litho-processor:0.2.0'\n  \n  // SoLoader \n  compile 'com.facebook.soloader:soloader:0.2.0'\n\n  // 调试选项\n  debugCompile 'com.facebook.litho:litho-stetho:0.2.0'\n\n  // 集成Fresco的支持\n  compile 'com.facebook.litho:litho-fresco:0.2.0'\n\n  // 供测试\n  testCompile 'com.facebook.litho:litho-testing:0.2.0'\n}\n```\n\n</p>\n</p>\n\n##### Buck\n\n</p>\n</p>\n\n你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.\n``` buck\nandroid_prebuilt_aar(\n    name = \"litho\",\n    aar = \":litho.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-core.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-core:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-annotation\",\n    binary_jar = \":litho-annotation.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-processor.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-processor:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-processor\",\n    binary_jar = \":litho-processor.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-annotation.jar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-annotation:jar:0.2.0\",\n)\n\nandroid_prebuilt_aar(\n    name = \"litho-widget\",\n    aar = \":litho-widget.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-widget.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-widget:aar:0.2.0\",\n)\n\nlitho_android_library(\n    ...\n    # Your target here\n    ...\n    annotation_processor_deps = [\n        \":litho-annotation\",\n        \":litho-processor\",\n    ],\n    annotation_processors = [\n        \"com.facebook.litho.processor.ComponentsProcessor\",\n    ],\n    deps = [\n        \":litho\",\n        \":litho-widget\",\n        ...\n    ]\n)\n```\n\n</p>\n</p>\n\n#### 测试集成情况\n---\n你可以通过添加一个由Litho创建的view至activity来测试集成情况\n\n首先,初始化SoLoader.Litho依赖[SoLoader](https://github.com/facebook/SoLoader)来加载底层布局引擎[Yoga](https://facebook.github.io/yoga/)所需的本地库.在Application中进行这个操作比较合适.\n\n``` java\n[MyApplication.java]\npublic class MyApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\n然后,添加一个预定义的Litho Text组件至activity来显示\"Hello world\".\n\n``` java \n[MyActivity.java]\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.LithoView;\n\npublic class MyActivity extends Activity {\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    \n    final ComponentContext c = new ComponentContext(this);\n\n    final LithoView lithoView = LithoView.create(\n    \tthis /* context */, \n    \tText.create(c)\n            .text(\"Hello, World!\")\n            .textSizeDip(50)\n            .build());\n    \t\n    setContentView(lithoView);\n  }\n}\n\n```\n\n现在,当你运行app的时候,你就可以看到\"Hello World\"显示在屏幕上.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-准备工作.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-准备工作\ndate: 2017-04-27 16:05:10\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/getting-started)\n## 快速开始\n### 准备工作\n\n</p>\n</p>\n\n#### 集成Litho至你的工程\n---\n\n</p>\n</p>\n\n##### gradle\n\n</p>\n</p>\n\n你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.\n``` gradle\ndependencies {\n  // ...\n  // Litho\n  compile 'com.facebook.litho:litho-core:0.2.0'\n  compile 'com.facebook.litho:litho-widget:0.2.0'\n  provided 'com.facebook.litho:litho-annotations:0.2.0'\n\n  annotationProcessor 'com.facebook.litho:litho-processor:0.2.0'\n  \n  // SoLoader \n  compile 'com.facebook.soloader:soloader:0.2.0'\n\n  // 调试选项\n  debugCompile 'com.facebook.litho:litho-stetho:0.2.0'\n\n  // 集成Fresco的支持\n  compile 'com.facebook.litho:litho-fresco:0.2.0'\n\n  // 供测试\n  testCompile 'com.facebook.litho:litho-testing:0.2.0'\n}\n```\n\n</p>\n</p>\n\n##### Buck\n\n</p>\n</p>\n\n你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.\n``` buck\nandroid_prebuilt_aar(\n    name = \"litho\",\n    aar = \":litho.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-core.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-core:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-annotation\",\n    binary_jar = \":litho-annotation.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-processor.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-processor:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-processor\",\n    binary_jar = \":litho-processor.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-annotation.jar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-annotation:jar:0.2.0\",\n)\n\nandroid_prebuilt_aar(\n    name = \"litho-widget\",\n    aar = \":litho-widget.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-widget.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-widget:aar:0.2.0\",\n)\n\nlitho_android_library(\n    ...\n    # Your target here\n    ...\n    annotation_processor_deps = [\n        \":litho-annotation\",\n        \":litho-processor\",\n    ],\n    annotation_processors = [\n        \"com.facebook.litho.processor.ComponentsProcessor\",\n    ],\n    deps = [\n        \":litho\",\n        \":litho-widget\",\n        ...\n    ]\n)\n```\n\n</p>\n</p>\n\n#### 测试集成情况\n---\n你可以通过添加一个由Litho创建的view至activity来测试集成情况\n\n首先,初始化SoLoader.Litho依赖[SoLoader](https://github.com/facebook/SoLoader)来加载底层布局引擎[Yoga](https://facebook.github.io/yoga/)所需的本地库.在Application中进行这个操作比较合适.\n\n``` java\n[MyApplication.java]\npublic class MyApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\n然后,添加一个预定义的Litho Text组件至activity来显示\"Hello world\".\n\n``` java \n[MyActivity.java]\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.LithoView;\n\npublic class MyActivity extends Activity {\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    \n    final ComponentContext c = new ComponentContext(this);\n\n    final LithoView lithoView = LithoView.create(\n    \tthis /* context */, \n    \tText.create(c)\n            .text(\"Hello, World!\")\n            .textSizeDip(50)\n            .build());\n    \t\n    setContentView(lithoView);\n  }\n}\n\n```\n\n现在,当你运行app的时候,你就可以看到\"Hello World\"显示在屏幕上.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-准备工作","published":1,"updated":"2017-05-11T09:23:04.702Z","_id":"cj2k76hq8000lssrl43ie3ngk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/getting-started\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p></p><br><p></p><p></p>\n<h4 id=\"集成Litho至你的工程\"><a href=\"#集成Litho至你的工程\" class=\"headerlink\" title=\"集成Litho至你的工程\"></a>集成Litho至你的工程</h4><hr>\n<p></p><br><p></p><p></p>\n<h5 id=\"gradle\"><a href=\"#gradle\" class=\"headerlink\" title=\"gradle\"></a>gradle</h5><p></p><br><p></p><p></p>\n<p>你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  <span class=\"comment\">// Litho</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-core:0.2.0'</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-widget:0.2.0'</span></div><div class=\"line\">  provided <span class=\"string\">'com.facebook.litho:litho-annotations:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  annotationProcessor <span class=\"string\">'com.facebook.litho:litho-processor:0.2.0'</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// SoLoader </span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.soloader:soloader:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 调试选项</span></div><div class=\"line\">  debugCompile <span class=\"string\">'com.facebook.litho:litho-stetho:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 集成Fresco的支持</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-fresco:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 供测试</span></div><div class=\"line\">  testCompile <span class=\"string\">'com.facebook.litho:litho-testing:0.2.0'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><p></p>\n<h5 id=\"Buck\"><a href=\"#Buck\" class=\"headerlink\" title=\"Buck\"></a>Buck</h5><p></p><br><p></p><p></p>\n<p>你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho&quot;,</div><div class=\"line\">    aar = &quot;:litho.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-core.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-core:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-annotation&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-annotation.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-processor.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-processor:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-processor&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-processor.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-annotation.jar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-annotation:jar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho-widget&quot;,</div><div class=\"line\">    aar = &quot;:litho-widget.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-widget.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-widget:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">litho_android_library(</div><div class=\"line\">    ...</div><div class=\"line\">    # Your target here</div><div class=\"line\">    ...</div><div class=\"line\">    annotation_processor_deps = [</div><div class=\"line\">        &quot;:litho-annotation&quot;,</div><div class=\"line\">        &quot;:litho-processor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    annotation_processors = [</div><div class=\"line\">        &quot;com.facebook.litho.processor.ComponentsProcessor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    deps = [</div><div class=\"line\">        &quot;:litho&quot;,</div><div class=\"line\">        &quot;:litho-widget&quot;,</div><div class=\"line\">        ...</div><div class=\"line\">    ]</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"测试集成情况\"><a href=\"#测试集成情况\" class=\"headerlink\" title=\"测试集成情况\"></a>测试集成情况</h4><hr>\n<p>你可以通过添加一个由Litho创建的view至activity来测试集成情况</p>\n<p>首先,初始化SoLoader.Litho依赖<a href=\"https://github.com/facebook/SoLoader\" target=\"_blank\" rel=\"external\">SoLoader</a>来加载底层布局引擎<a href=\"https://facebook.github.io/yoga/\" target=\"_blank\" rel=\"external\">Yoga</a>所需的本地库.在Application中进行这个操作比较合适.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyApplication.java]</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后,添加一个预定义的Litho Text组件至activity来显示”Hello world”.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyActivity.java]</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.ComponentContext;</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.LithoView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> LithoView lithoView = LithoView.create(</div><div class=\"line\">    \t<span class=\"keyword\">this</span> <span class=\"comment\">/* context */</span>, </div><div class=\"line\">    \tText.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"Hello, World!\"</span>)</div><div class=\"line\">            .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    \t</div><div class=\"line\">    setContentView(lithoView);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在,当你运行app的时候,你就可以看到”Hello World”显示在屏幕上.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/getting-started\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p></p><br></p></p>\n<h4 id=\"集成Litho至你的工程\"><a href=\"#集成Litho至你的工程\" class=\"headerlink\" title=\"集成Litho至你的工程\"></a>集成Litho至你的工程</h4><hr>\n<p></p><br></p></p>\n<h5 id=\"gradle\"><a href=\"#gradle\" class=\"headerlink\" title=\"gradle\"></a>gradle</h5><p></p><br></p></p>\n<p>你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  <span class=\"comment\">// Litho</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-core:0.2.0'</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-widget:0.2.0'</span></div><div class=\"line\">  provided <span class=\"string\">'com.facebook.litho:litho-annotations:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  annotationProcessor <span class=\"string\">'com.facebook.litho:litho-processor:0.2.0'</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// SoLoader </span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.soloader:soloader:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 调试选项</span></div><div class=\"line\">  debugCompile <span class=\"string\">'com.facebook.litho:litho-stetho:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 集成Fresco的支持</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-fresco:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 供测试</span></div><div class=\"line\">  testCompile <span class=\"string\">'com.facebook.litho:litho-testing:0.2.0'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br></p></p>\n<h5 id=\"Buck\"><a href=\"#Buck\" class=\"headerlink\" title=\"Buck\"></a>Buck</h5><p></p><br></p></p>\n<p>你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho&quot;,</div><div class=\"line\">    aar = &quot;:litho.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-core.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-core:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-annotation&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-annotation.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-processor.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-processor:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-processor&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-processor.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-annotation.jar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-annotation:jar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho-widget&quot;,</div><div class=\"line\">    aar = &quot;:litho-widget.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-widget.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-widget:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">litho_android_library(</div><div class=\"line\">    ...</div><div class=\"line\">    # Your target here</div><div class=\"line\">    ...</div><div class=\"line\">    annotation_processor_deps = [</div><div class=\"line\">        &quot;:litho-annotation&quot;,</div><div class=\"line\">        &quot;:litho-processor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    annotation_processors = [</div><div class=\"line\">        &quot;com.facebook.litho.processor.ComponentsProcessor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    deps = [</div><div class=\"line\">        &quot;:litho&quot;,</div><div class=\"line\">        &quot;:litho-widget&quot;,</div><div class=\"line\">        ...</div><div class=\"line\">    ]</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p></p><br></p></p>\n<h4 id=\"测试集成情况\"><a href=\"#测试集成情况\" class=\"headerlink\" title=\"测试集成情况\"></a>测试集成情况</h4><hr>\n<p>你可以通过添加一个由Litho创建的view至activity来测试集成情况</p>\n<p>首先,初始化SoLoader.Litho依赖<a href=\"https://github.com/facebook/SoLoader\">SoLoader</a>来加载底层布局引擎<a href=\"https://facebook.github.io/yoga/\">Yoga</a>所需的本地库.在Application中进行这个操作比较合适.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyApplication.java]</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后,添加一个预定义的Litho Text组件至activity来显示”Hello world”.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyActivity.java]</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.ComponentContext;</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.LithoView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> LithoView lithoView = LithoView.create(</div><div class=\"line\">    \t<span class=\"keyword\">this</span> <span class=\"comment\">/* context */</span>, </div><div class=\"line\">    \tText.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"Hello, World!\"</span>)</div><div class=\"line\">            .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    \t</div><div class=\"line\">    setContentView(lithoView);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在,当你运行app的时候,你就可以看到”Hello World”显示在屏幕上.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-代码生成器","date":"2017-04-27T02:09:23.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/codegen)\n## 架构\n### 代码生成器\n\n</p>\n</p>\n\n正如在[编写Conponent](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/)中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——[SpecModel](http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModel)，作为中间件。\n\n代码生成过程分为三个步骤：\n- 从ComponentSpec中生成一个SpecModel。\n- 验证SpecModel的合法性\n- 从SpecModel中生成Component。\n\n</p>\n</p>\n\n#### 创建SpecModel\n---\nSpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.\n未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.\n\n</p>\n</p>\n\n#### SpecModel验证\n---\nSpecModel有一个方法叫做validate(),它返回一个包含[SpecModelValidationError(SpecModel验证错误)](http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModelValidationError)的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.\n\n</p>\n</p>\n\n#### Component生成\n---\n如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个[Javapoet](https://github.com/square/javapoet) TypeSpec(用它能够很容易的创建一个Component的class 文件).\n\n</p>\n</p>\n\n#### 给你的工程设置代码生成器\n---\n如果你根据[准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-代码生成器.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-代码生成器\ndate: 2017-04-27 10:09:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/codegen)\n## 架构\n### 代码生成器\n\n</p>\n</p>\n\n正如在[编写Conponent](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/)中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——[SpecModel](http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModel)，作为中间件。\n\n代码生成过程分为三个步骤：\n- 从ComponentSpec中生成一个SpecModel。\n- 验证SpecModel的合法性\n- 从SpecModel中生成Component。\n\n</p>\n</p>\n\n#### 创建SpecModel\n---\nSpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.\n未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.\n\n</p>\n</p>\n\n#### SpecModel验证\n---\nSpecModel有一个方法叫做validate(),它返回一个包含[SpecModelValidationError(SpecModel验证错误)](http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModelValidationError)的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.\n\n</p>\n</p>\n\n#### Component生成\n---\n如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个[Javapoet](https://github.com/square/javapoet) TypeSpec(用它能够很容易的创建一个Component的class 文件).\n\n</p>\n</p>\n\n#### 给你的工程设置代码生成器\n---\n如果你根据[准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-代码生成器","published":1,"updated":"2017-05-11T09:32:33.681Z","_id":"cj2k76hqb000qssrlabrbig9t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/codegen\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h3><p></p><br><p></p><p></p>\n<p>正如在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/\">编写Conponent</a>中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——<a href=\"http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModel\" target=\"_blank\" rel=\"external\">SpecModel</a>，作为中间件。</p>\n<p>代码生成过程分为三个步骤：</p>\n<ul>\n<li>从ComponentSpec中生成一个SpecModel。</li>\n<li>验证SpecModel的合法性</li>\n<li>从SpecModel中生成Component。</li>\n</ul>\n<p></p><br><p></p><p></p>\n<h4 id=\"创建SpecModel\"><a href=\"#创建SpecModel\" class=\"headerlink\" title=\"创建SpecModel\"></a>创建SpecModel</h4><hr>\n<p>SpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.<br>未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"SpecModel验证\"><a href=\"#SpecModel验证\" class=\"headerlink\" title=\"SpecModel验证\"></a>SpecModel验证</h4><hr>\n<p>SpecModel有一个方法叫做validate(),它返回一个包含<a href=\"http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModelValidationError\" target=\"_blank\" rel=\"external\">SpecModelValidationError(SpecModel验证错误)</a>的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"Component生成\"><a href=\"#Component生成\" class=\"headerlink\" title=\"Component生成\"></a>Component生成</h4><hr>\n<p>如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个<a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"external\">Javapoet</a> TypeSpec(用它能够很容易的创建一个Component的class 文件).</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"给你的工程设置代码生成器\"><a href=\"#给你的工程设置代码生成器\" class=\"headerlink\" title=\"给你的工程设置代码生成器\"></a>给你的工程设置代码生成器</h4><hr>\n<p>如果你根据<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a>中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/codegen\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h3><p></p><br></p></p>\n<p>正如在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/\">编写Conponent</a>中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——<a href=\"http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModel\">SpecModel</a>，作为中间件。</p>\n<p>代码生成过程分为三个步骤：</p>\n<ul>\n<li>从ComponentSpec中生成一个SpecModel。</li>\n<li>验证SpecModel的合法性</li>\n<li>从SpecModel中生成Component。</li>\n</ul>\n<p></p><br></p></p>\n<h4 id=\"创建SpecModel\"><a href=\"#创建SpecModel\" class=\"headerlink\" title=\"创建SpecModel\"></a>创建SpecModel</h4><hr>\n<p>SpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.<br>未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.</p>\n<p></p><br></p></p>\n<h4 id=\"SpecModel验证\"><a href=\"#SpecModel验证\" class=\"headerlink\" title=\"SpecModel验证\"></a>SpecModel验证</h4><hr>\n<p>SpecModel有一个方法叫做validate(),它返回一个包含<a href=\"http://fblitho.com/javadoc/com/facebook/litho/specmodels/model/SpecModelValidationError\">SpecModelValidationError(SpecModel验证错误)</a>的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.</p>\n<p></p><br></p></p>\n<h4 id=\"Component生成\"><a href=\"#Component生成\" class=\"headerlink\" title=\"Component生成\"></a>Component生成</h4><hr>\n<p>如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个<a href=\"https://github.com/square/javapoet\">Javapoet</a> TypeSpec(用它能够很容易的创建一个Component的class 文件).</p>\n<p></p><br></p></p>\n<h4 id=\"给你的工程设置代码生成器\"><a href=\"#给你的工程设置代码生成器\" class=\"headerlink\" title=\"给你的工程设置代码生成器\"></a>给你的工程设置代码生成器</h4><hr>\n<p>如果你根据<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a>中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载","date":"2017-04-27T02:09:23.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/inc-mount-architecture)\n## 架构\n### 增量式挂载\n\n</p>\n</p>\n\n虽然Component提供了扁平化的view层级结构和[主线程外的布局计算](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.\n\nLitho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.\n\n使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.\n\n![](/image/20170426150321.png)\n如果你使用Litho的[异步RecyclerView]()支持,框架将会无缝的支持增量式挂载.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载\ndate: 2017-04-27 10:09:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/inc-mount-architecture)\n## 架构\n### 增量式挂载\n\n</p>\n</p>\n\n虽然Component提供了扁平化的view层级结构和[主线程外的布局计算](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.\n\nLitho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.\n\n使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.\n\n![](/image/20170426150321.png)\n如果你使用Litho的[异步RecyclerView]()支持,框架将会无缝的支持增量式挂载.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载","published":1,"updated":"2017-05-11T09:33:32.669Z","_id":"cj2k76hqc000sssrlhexy2l6r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/inc-mount-architecture\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a>增量式挂载</h3><p></p><br><p></p><p></p>\n<p>虽然Component提供了扁平化的view层级结构和<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">主线程外的布局计算</a>功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.</p>\n<p>Litho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.</p>\n<p>使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.</p>\n<p><img src=\"/image/20170426150321.png\" alt=\"\"><br>如果你使用Litho的<a href=\"\">异步RecyclerView</a>支持,框架将会无缝的支持增量式挂载.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/inc-mount-architecture\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a>增量式挂载</h3><p></p><br></p></p>\n<p>虽然Component提供了扁平化的view层级结构和<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">主线程外的布局计算</a>功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.</p>\n<p>Litho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.</p>\n<p>使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.</p>\n<p><img src=\"/image/20170426150321.png\" alt=\"\"><br>如果你使用Litho的<a href=\"\">异步RecyclerView</a>支持,框架将会无缝的支持增量式挂载.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-异步布局","date":"2017-04-27T02:09:23.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/asynchronous-layout)\n## 架构\n### 异步布局(layout)\n\n</p>\n</p>\n\n#### 不可变性和线程安全\n---\n大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:\n``` java\n public class SomeExampleClass {\n    private int mCounter;\n\n    public String getThisOrThat() {\n      if (mCounter > 10) {\n        return \"this\":\n      } else {\n        mCounter++;\n        return \"that\";\n      }\n    }\n  }\n```\n如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.\n\n而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.\n\n让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:\n``` java\npublic static class Result {\n    public final int mCounter;\n    public final String mValue;\n\n    public Result(int counter, int value) {\n      mCounter = counter;\n      mValue = value;\n    }\n  }\n\n  public class SomeExampleClass {\n    public static Result getThisOrThat(int counterValue) {\n      if (counterValue > 10) {\n        return new Result(counterValue, \"this\"):\n      } else {\n        return new Result(counterValue + 1, \"that\");\n      }\n    }\n  }\n\n```\n我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为\"纯净方法(pure function)\",因为它的输出结果只取决于输入值并且这么做没有任何副作用.\n\n在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为\"纯净方法\"的性质.\n\n在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和[代码生成](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/)的概念来自动优化对象内存分配,使得内存分配花费降到最小.\n\n</p>\n</p>\n\n#### 同步和异步操作\n---\nLitho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.\n\n同步的布局计算能够确保一旦在[ComponentTree](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree)中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到[LithoView](http://fblitho.com/javadoc/com/facebook/litho/LithoView)上.\n\n而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.\n\n异步的布局计算将会使用Litho的\"布局线程\"来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于[RecyclerBinder]()的示例中.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-异步布局.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-异步布局\ndate: 2017-04-27 10:09:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/asynchronous-layout)\n## 架构\n### 异步布局(layout)\n\n</p>\n</p>\n\n#### 不可变性和线程安全\n---\n大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:\n``` java\n public class SomeExampleClass {\n    private int mCounter;\n\n    public String getThisOrThat() {\n      if (mCounter > 10) {\n        return \"this\":\n      } else {\n        mCounter++;\n        return \"that\";\n      }\n    }\n  }\n```\n如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.\n\n而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.\n\n让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:\n``` java\npublic static class Result {\n    public final int mCounter;\n    public final String mValue;\n\n    public Result(int counter, int value) {\n      mCounter = counter;\n      mValue = value;\n    }\n  }\n\n  public class SomeExampleClass {\n    public static Result getThisOrThat(int counterValue) {\n      if (counterValue > 10) {\n        return new Result(counterValue, \"this\"):\n      } else {\n        return new Result(counterValue + 1, \"that\");\n      }\n    }\n  }\n\n```\n我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为\"纯净方法(pure function)\",因为它的输出结果只取决于输入值并且这么做没有任何副作用.\n\n在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为\"纯净方法\"的性质.\n\n在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和[代码生成](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/)的概念来自动优化对象内存分配,使得内存分配花费降到最小.\n\n</p>\n</p>\n\n#### 同步和异步操作\n---\nLitho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.\n\n同步的布局计算能够确保一旦在[ComponentTree](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree)中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到[LithoView](http://fblitho.com/javadoc/com/facebook/litho/LithoView)上.\n\n而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.\n\n异步的布局计算将会使用Litho的\"布局线程\"来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于[RecyclerBinder]()的示例中.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-异步布局","published":1,"updated":"2017-05-11T09:33:06.101Z","_id":"cj2k76hqd000vssrlj6cblmj6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/asynchronous-layout\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"异步布局-layout\"><a href=\"#异步布局-layout\" class=\"headerlink\" title=\"异步布局(layout)\"></a>异步布局(layout)</h3><p></p><br><p></p><p></p>\n<h4 id=\"不可变性和线程安全\"><a href=\"#不可变性和线程安全\" class=\"headerlink\" title=\"不可变性和线程安全\"></a>不可变性和线程安全</h4><hr>\n<p>大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getThisOrThat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (mCounter &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"this\"</span>:</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       mCounter++;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"that\"</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.</p>\n<p>而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.</p>\n<p>让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Result</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String mValue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Result</span><span class=\"params\">(<span class=\"keyword\">int</span> counter, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">      mCounter = counter;</div><div class=\"line\">      mValue = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title\">getThisOrThat</span><span class=\"params\">(<span class=\"keyword\">int</span> counterValue)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (counterValue &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue, <span class=\"string\">\"this\"</span>):</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue + <span class=\"number\">1</span>, <span class=\"string\">\"that\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为”纯净方法(pure function)”,因为它的输出结果只取决于输入值并且这么做没有任何副作用.</p>\n<p>在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为”纯净方法”的性质.</p>\n<p>在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/\">代码生成</a>的概念来自动优化对象内存分配,使得内存分配花费降到最小.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"同步和异步操作\"><a href=\"#同步和异步操作\" class=\"headerlink\" title=\"同步和异步操作\"></a>同步和异步操作</h4><hr>\n<p>Litho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.</p>\n<p>同步的布局计算能够确保一旦在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree\" target=\"_blank\" rel=\"external\">ComponentTree</a>中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到<a href=\"http://fblitho.com/javadoc/com/facebook/litho/LithoView\" target=\"_blank\" rel=\"external\">LithoView</a>上.</p>\n<p>而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.</p>\n<p>异步的布局计算将会使用Litho的”布局线程”来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于<a href=\"\">RecyclerBinder</a>的示例中.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/asynchronous-layout\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"异步布局-layout\"><a href=\"#异步布局-layout\" class=\"headerlink\" title=\"异步布局(layout)\"></a>异步布局(layout)</h3><p></p><br></p></p>\n<h4 id=\"不可变性和线程安全\"><a href=\"#不可变性和线程安全\" class=\"headerlink\" title=\"不可变性和线程安全\"></a>不可变性和线程安全</h4><hr>\n<p>大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getThisOrThat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (mCounter &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"this\"</span>:</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       mCounter++;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"that\"</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.</p>\n<p>而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.</p>\n<p>让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Result</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String mValue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Result</span><span class=\"params\">(<span class=\"keyword\">int</span> counter, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">      mCounter = counter;</div><div class=\"line\">      mValue = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title\">getThisOrThat</span><span class=\"params\">(<span class=\"keyword\">int</span> counterValue)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (counterValue &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue, <span class=\"string\">\"this\"</span>):</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue + <span class=\"number\">1</span>, <span class=\"string\">\"that\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为”纯净方法(pure function)”,因为它的输出结果只取决于输入值并且这么做没有任何副作用.</p>\n<p>在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为”纯净方法”的性质.</p>\n<p>在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/\">代码生成</a>的概念来自动优化对象内存分配,使得内存分配花费降到最小.</p>\n<p></p><br></p></p>\n<h4 id=\"同步和异步操作\"><a href=\"#同步和异步操作\" class=\"headerlink\" title=\"同步和异步操作\"></a>同步和异步操作</h4><hr>\n<p>Litho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.</p>\n<p>同步的布局计算能够确保一旦在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree\">ComponentTree</a>中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到<a href=\"http://fblitho.com/javadoc/com/facebook/litho/LithoView\">LithoView</a>上.</p>\n<p>而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.</p>\n<p>异步的布局计算将会使用Litho的”布局线程”来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于<a href=\"\">RecyclerBinder</a>的示例中.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-回收机制","date":"2017-04-27T02:09:23.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/recycling)\n## 架构\n### 回收机制\n\n</p>\n</p>\n\n设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。\nAndroid使用[RecyclerView](https://developer.android.com/guide/topics/ui/layout/recyclerview.html)解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。\n\n![](/image/20170426171157.gif)\n\nRecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。\n\n![](/image/20170426172051.gif)\n\n</p>\n</p>\n\n#### Litho增量式回收\n---\n我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。\n\n![](/image/20170426172130.gif)\n\n回收利用像Text这样的\"原始item\"能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的\"原始item\"来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-回收机制.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-回收机制\ndate: 2017-04-27 10:09:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/recycling)\n## 架构\n### 回收机制\n\n</p>\n</p>\n\n设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。\nAndroid使用[RecyclerView](https://developer.android.com/guide/topics/ui/layout/recyclerview.html)解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。\n\n![](/image/20170426171157.gif)\n\nRecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。\n\n![](/image/20170426172051.gif)\n\n</p>\n</p>\n\n#### Litho增量式回收\n---\n我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。\n\n![](/image/20170426172130.gif)\n\n回收利用像Text这样的\"原始item\"能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的\"原始item\"来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-回收机制","published":1,"updated":"2017-05-11T09:34:10.417Z","_id":"cj2k76hqg000xssrlifz572v4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/recycling\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a>回收机制</h3><p></p><br><p></p><p></p>\n<p>设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。<br>Android使用<a href=\"https://developer.android.com/guide/topics/ui/layout/recyclerview.html\" target=\"_blank\" rel=\"external\">RecyclerView</a>解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。</p>\n<p><img src=\"/image/20170426171157.gif\" alt=\"\"></p>\n<p>RecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。</p>\n<p><img src=\"/image/20170426172051.gif\" alt=\"\"></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"Litho增量式回收\"><a href=\"#Litho增量式回收\" class=\"headerlink\" title=\"Litho增量式回收\"></a>Litho增量式回收</h4><hr>\n<p>我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。</p>\n<p><img src=\"/image/20170426172130.gif\" alt=\"\"></p>\n<p>回收利用像Text这样的”原始item”能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的”原始item”来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/recycling\">Litho-doc</a></p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a>回收机制</h3><p></p><br></p></p>\n<p>设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。<br>Android使用<a href=\"https://developer.android.com/guide/topics/ui/layout/recyclerview.html\">RecyclerView</a>解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。</p>\n<p><img src=\"/image/20170426171157.gif\" alt=\"\"></p>\n<p>RecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。</p>\n<p><img src=\"/image/20170426172051.gif\" alt=\"\"></p>\n<p></p><br></p></p>\n<h4 id=\"Litho增量式回收\"><a href=\"#Litho增量式回收\" class=\"headerlink\" title=\"Litho增量式回收\"></a>Litho增量式回收</h4><hr>\n<p>我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。</p>\n<p><img src=\"/image/20170426172130.gif\" alt=\"\"></p>\n<p>回收利用像Text这样的”原始item”能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的”原始item”来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-教程","date":"2017-04-27T08:05:10.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/tutorial)\n## 快速开始\n### 教程\n\n</p>\n</p>\n\n本教程已经假定你已经按照[准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)正确设置了Litho.\n\n在本教程中，你将首先使用Litho在屏幕上构建一个基本的\"Hello World！\"，然后再构建一个\"Hello World！\" item组成的列表。在这个过程中,你将了解到Litho的构建块：[Component](http://fblitho.com/javadoc/com/facebook/litho/Component)和[LithoView](http://fblitho.com/javadoc/com/facebook/litho/LithoView)。你将学习如何设置Component的属性。\n\n</p>\n</p>\n\n#### 1.Hello World\n---\n在最初的步骤中,你将显示一个带有\"Hello World\"的View.\n\n首先,在Application中初始化SoLoader.\n``` java\npublic class SampleApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\nLitho在后台使用[Yoga](https://facebook.github.io/yoga/)加载布局.Yoga需要依赖本地库,而我们引入[SoLoader](https://github.com/facebook/SoLoader)来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.\n\n另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装[Stetho]().\n\n下一步,添加一个Litho中预定义好的[Text](http://fblitho.com/javadoc/com/facebook/litho/widget/Text) Component到activity中:\n``` java \n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    final ComponentContext context = new ComponentContext(this);\n\n    final Component component = Text.create(context)\n        .text(\"Hello World\")\n        .textSizeDip(50)\n        .build();\n\n    setContentView(LithoView.create(context, component));\n}\n```\nLithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.\n\n那么component如何发挥作用呢?让我们看一下这段代码:\n``` java\nText.create(context)\n    .text(\"Hello World\")\n    .textSizeDip(50)\n    .build();\n```\n\nText是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从[React](https://facebook.github.io/react/)中获得灵感,这些属性我们称之为props.\n\n稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.\n\n在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.\n\n完成了!让我们运行app,你可以在屏幕上看到这样的显示.\n\n![](/image/20170428092530.png)\n\n虽然并不漂亮,但是这已经是一个好的开端了!\n\n</p>\n</p>\n\n#### 2.你的第一个自定义Component\n---\n在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!\n\n在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.\n\n准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。\n\n您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.\n\n``` java\n@LayoutSpec\npublic class ListItemSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(ComponentContext c) {\n  \n    return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(Color.WHITE)\n        .child(\n            Text.create(c)\n                .text(\"Hello world\")\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(\"Litho tutorial\")\n                .textSizeSp(20))\n        .build();\n  }\n}\n```\n\n你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个[Column](http://fblitho.com/javadoc/com/facebook/litho/Column)中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用[Yoga](https://facebook.github.io/yoga/),你可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.\n\n你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:\n\n``` java \nfinal Component text = ListItem.create(context).build();\n```\n注意:你使用的是ListItem,而不是ListItemSpec.\n\n这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.\n\n在[准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).\n\n就这么简单。运行你的app,你应该看到如下的画面:\n\n![](/image/20170428102947.png)\n\n</p>\n</p>\n\n#### 3.创建一个列表\n---\n你可以使用Litho的核心组件[Recycler](http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler) Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个[RecyclerBinder](http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder)来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.\n首先,在你的activity中,像下面这样定义Component:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(\n    context,\n    new LinearLayoutInfo(this, OrientationHelper.VERTICAL, false));\n\nfinal Component component = Recycler.create(context)\n    .binder(recyclerBinder)\n    .build();\n```\n这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.\n\n然后再创建Recycler并且把它传递给LithoView.\n\n现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:\n``` java\nprivate static void addContent(RecyclerBinder recyclerBinder, ComponentContext context) {\n    for (int i = 0; i < 32; i++) {\n      recyclerBinder.insertItemAt(\n          i,\n          ComponentInfo.create()\n              .component(ListItem.create(context).build())\n              .build());\n    }\n}    \n```\n\n在代码中,我们需要创建一个[ComponentInfo](http://fblitho.com/javadoc/com/facebook/litho/ComponentInfo)来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.\n\n最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.\n``` java\naddContent(recyclerBinder, context);\n```\n运行app,你会看见一个可以滚动的具有32个ListItem的列表.\n\n![](/image/20170428105417.png)\n\n</p>\n</p>\n\n#### 4.定义Component的属性\n---\n列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.\n\n为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.\n\n像下面这样修改ListItemSpec:\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @Prop int color,\n    @Prop String title,\n    @Prop String subtitle) {\n    \n  return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(color)\n        .child(\n            Text.create(c)\n                .text(title)\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(subtitle)\n                .textSizeSp(20))\n        .build();\n}\n```\n\n这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.\n\n神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:\n``` java\nprivate void addContent(\n    RecyclerBinder recyclerBinder, \n    ComponentContext context) {\n  for (int i = 0; i < 32; i++) {\n    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();\n    componentInfoBuilder.component(\n        ListItem.create(context)\n            .color(i % 2 == 0 ? Color.WHITE : Color.LTGRAY)\n            .title(\"Hello, world!\")\n            .subtitle(\"Litho tutorial\")\n            .build());\n    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());\n  }\n}\n```\n\n现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.\n\n运行app,你可以看到如下画面:\n\n![](/image/20170428111627.png)\n\n你可以为@Prop注释指定更多的选项.例如下面的属性:\n``` java \n@Prop(optional = true, resType = ResType.DIMEN_OFFSET) int shadowRadius,\n```\n\n它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。\n\n恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在[com.facebook.litho.widgets](http://fblitho.com/javadoc/com/facebook/litho/widget/package-frame)包中找到可以使用的预定义好的组件Component。你可以在[这里](https://github.com/facebook/litho/tree/master/sample-barebones)找到完整的教程。请务必查看[此示例](https://github.com/facebook/litho/tree/master/sample)和Litho API文档以获取更深入的代码。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-教程.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-教程\ndate: 2017-04-27 16:05:10\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/tutorial)\n## 快速开始\n### 教程\n\n</p>\n</p>\n\n本教程已经假定你已经按照[准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)正确设置了Litho.\n\n在本教程中，你将首先使用Litho在屏幕上构建一个基本的\"Hello World！\"，然后再构建一个\"Hello World！\" item组成的列表。在这个过程中,你将了解到Litho的构建块：[Component](http://fblitho.com/javadoc/com/facebook/litho/Component)和[LithoView](http://fblitho.com/javadoc/com/facebook/litho/LithoView)。你将学习如何设置Component的属性。\n\n</p>\n</p>\n\n#### 1.Hello World\n---\n在最初的步骤中,你将显示一个带有\"Hello World\"的View.\n\n首先,在Application中初始化SoLoader.\n``` java\npublic class SampleApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\nLitho在后台使用[Yoga](https://facebook.github.io/yoga/)加载布局.Yoga需要依赖本地库,而我们引入[SoLoader](https://github.com/facebook/SoLoader)来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.\n\n另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装[Stetho]().\n\n下一步,添加一个Litho中预定义好的[Text](http://fblitho.com/javadoc/com/facebook/litho/widget/Text) Component到activity中:\n``` java \n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    final ComponentContext context = new ComponentContext(this);\n\n    final Component component = Text.create(context)\n        .text(\"Hello World\")\n        .textSizeDip(50)\n        .build();\n\n    setContentView(LithoView.create(context, component));\n}\n```\nLithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.\n\n那么component如何发挥作用呢?让我们看一下这段代码:\n``` java\nText.create(context)\n    .text(\"Hello World\")\n    .textSizeDip(50)\n    .build();\n```\n\nText是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从[React](https://facebook.github.io/react/)中获得灵感,这些属性我们称之为props.\n\n稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.\n\n在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.\n\n完成了!让我们运行app,你可以在屏幕上看到这样的显示.\n\n![](/image/20170428092530.png)\n\n虽然并不漂亮,但是这已经是一个好的开端了!\n\n</p>\n</p>\n\n#### 2.你的第一个自定义Component\n---\n在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!\n\n在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.\n\n准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。\n\n您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.\n\n``` java\n@LayoutSpec\npublic class ListItemSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(ComponentContext c) {\n  \n    return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(Color.WHITE)\n        .child(\n            Text.create(c)\n                .text(\"Hello world\")\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(\"Litho tutorial\")\n                .textSizeSp(20))\n        .build();\n  }\n}\n```\n\n你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个[Column](http://fblitho.com/javadoc/com/facebook/litho/Column)中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用[Yoga](https://facebook.github.io/yoga/),你可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.\n\n你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:\n\n``` java \nfinal Component text = ListItem.create(context).build();\n```\n注意:你使用的是ListItem,而不是ListItemSpec.\n\n这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.\n\n在[准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).\n\n就这么简单。运行你的app,你应该看到如下的画面:\n\n![](/image/20170428102947.png)\n\n</p>\n</p>\n\n#### 3.创建一个列表\n---\n你可以使用Litho的核心组件[Recycler](http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler) Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个[RecyclerBinder](http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder)来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.\n首先,在你的activity中,像下面这样定义Component:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(\n    context,\n    new LinearLayoutInfo(this, OrientationHelper.VERTICAL, false));\n\nfinal Component component = Recycler.create(context)\n    .binder(recyclerBinder)\n    .build();\n```\n这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.\n\n然后再创建Recycler并且把它传递给LithoView.\n\n现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:\n``` java\nprivate static void addContent(RecyclerBinder recyclerBinder, ComponentContext context) {\n    for (int i = 0; i < 32; i++) {\n      recyclerBinder.insertItemAt(\n          i,\n          ComponentInfo.create()\n              .component(ListItem.create(context).build())\n              .build());\n    }\n}    \n```\n\n在代码中,我们需要创建一个[ComponentInfo](http://fblitho.com/javadoc/com/facebook/litho/ComponentInfo)来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.\n\n最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.\n``` java\naddContent(recyclerBinder, context);\n```\n运行app,你会看见一个可以滚动的具有32个ListItem的列表.\n\n![](/image/20170428105417.png)\n\n</p>\n</p>\n\n#### 4.定义Component的属性\n---\n列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.\n\n为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.\n\n像下面这样修改ListItemSpec:\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @Prop int color,\n    @Prop String title,\n    @Prop String subtitle) {\n    \n  return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(color)\n        .child(\n            Text.create(c)\n                .text(title)\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(subtitle)\n                .textSizeSp(20))\n        .build();\n}\n```\n\n这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.\n\n神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:\n``` java\nprivate void addContent(\n    RecyclerBinder recyclerBinder, \n    ComponentContext context) {\n  for (int i = 0; i < 32; i++) {\n    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();\n    componentInfoBuilder.component(\n        ListItem.create(context)\n            .color(i % 2 == 0 ? Color.WHITE : Color.LTGRAY)\n            .title(\"Hello, world!\")\n            .subtitle(\"Litho tutorial\")\n            .build());\n    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());\n  }\n}\n```\n\n现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.\n\n运行app,你可以看到如下画面:\n\n![](/image/20170428111627.png)\n\n你可以为@Prop注释指定更多的选项.例如下面的属性:\n``` java \n@Prop(optional = true, resType = ResType.DIMEN_OFFSET) int shadowRadius,\n```\n\n它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。\n\n恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在[com.facebook.litho.widgets](http://fblitho.com/javadoc/com/facebook/litho/widget/package-frame)包中找到可以使用的预定义好的组件Component。你可以在[这里](https://github.com/facebook/litho/tree/master/sample-barebones)找到完整的教程。请务必查看[此示例](https://github.com/facebook/litho/tree/master/sample)和Litho API文档以获取更深入的代码。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-教程","published":1,"updated":"2017-05-11T09:23:34.622Z","_id":"cj2k76hqo0011ssrluxk7acre","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/tutorial\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p></p><br><p></p><p></p>\n<p>本教程已经假定你已经按照<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a>正确设置了Litho.</p>\n<p>在本教程中，你将首先使用Litho在屏幕上构建一个基本的”Hello World！”，然后再构建一个”Hello World！” item组成的列表。在这个过程中,你将了解到Litho的构建块：<a href=\"http://fblitho.com/javadoc/com/facebook/litho/Component\" target=\"_blank\" rel=\"external\">Component</a>和<a href=\"http://fblitho.com/javadoc/com/facebook/litho/LithoView\" target=\"_blank\" rel=\"external\">LithoView</a>。你将学习如何设置Component的属性。</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"1-Hello-World\"><a href=\"#1-Hello-World\" class=\"headerlink\" title=\"1.Hello World\"></a>1.Hello World</h4><hr>\n<p>在最初的步骤中,你将显示一个带有”Hello World”的View.</p>\n<p>首先,在Application中初始化SoLoader.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Litho在后台使用<a href=\"https://facebook.github.io/yoga/\" target=\"_blank\" rel=\"external\">Yoga</a>加载布局.Yoga需要依赖本地库,而我们引入<a href=\"https://github.com/facebook/SoLoader\" target=\"_blank\" rel=\"external\">SoLoader</a>来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.</p>\n<p>另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装<a href=\"\">Stetho</a>.</p>\n<p>下一步,添加一个Litho中预定义好的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Text\" target=\"_blank\" rel=\"external\">Text</a> Component到activity中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext context = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component component = Text.create(context)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">        .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    setContentView(LithoView.create(context, component));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>LithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.</p>\n<p>那么component如何发挥作用呢?让我们看一下这段代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(context)</div><div class=\"line\">    .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">    .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>Text是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从<a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"external\">React</a>中获得灵感,这些属性我们称之为props.</p>\n<p>稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.</p>\n<p>在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.</p>\n<p>完成了!让我们运行app,你可以在屏幕上看到这样的显示.</p>\n<p><img src=\"/image/20170428092530.png\" alt=\"\"></p>\n<p>虽然并不漂亮,但是这已经是一个好的开端了!</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"2-你的第一个自定义Component\"><a href=\"#2-你的第一个自定义Component\" class=\"headerlink\" title=\"2.你的第一个自定义Component\"></a>2.你的第一个自定义Component</h4><hr>\n<p>在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!</p>\n<p>在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.</p>\n<p>准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。</p>\n<p>您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItemSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(Color.WHITE)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Hello world\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/Column\" target=\"_blank\" rel=\"external\">Column</a>中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用<a href=\"https://facebook.github.io/yoga/\" target=\"_blank\" rel=\"external\">Yoga</a>,你可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.</div></p>\n<p>你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component text = ListItem.create(context).build();</div></pre></td></tr></table></figure>\n<p>注意:你使用的是ListItem,而不是ListItemSpec.</p>\n<p>这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.</p>\n<p>在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a>中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).</p>\n<p>就这么简单。运行你的app,你应该看到如下的画面:</p>\n<p><img src=\"/image/20170428102947.png\" alt=\"\"></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"3-创建一个列表\"><a href=\"#3-创建一个列表\" class=\"headerlink\" title=\"3.创建一个列表\"></a>3.创建一个列表</h4><hr>\n<p>你可以使用Litho的核心组件<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler\" target=\"_blank\" rel=\"external\">Recycler</a> Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder\" target=\"_blank\" rel=\"external\">RecyclerBinder</a>来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.<br>首先,在你的activity中,像下面这样定义Component:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(</div><div class=\"line\">    context,</div><div class=\"line\">    <span class=\"keyword\">new</span> LinearLayoutInfo(<span class=\"keyword\">this</span>, OrientationHelper.VERTICAL, <span class=\"keyword\">false</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> Component component = Recycler.create(context)</div><div class=\"line\">    .binder(recyclerBinder)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.</p>\n<p>然后再创建Recycler并且把它传递给LithoView.</p>\n<p>现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(RecyclerBinder recyclerBinder, ComponentContext context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">      recyclerBinder.insertItemAt(</div><div class=\"line\">          i,</div><div class=\"line\">          ComponentInfo.create()</div><div class=\"line\">              .component(ListItem.create(context).build())</div><div class=\"line\">              .build());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在代码中,我们需要创建一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentInfo\" target=\"_blank\" rel=\"external\">ComponentInfo</a>来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.</p>\n<p>最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addContent(recyclerBinder, context);</div></pre></td></tr></table></figure></p>\n<p>运行app,你会看见一个可以滚动的具有32个ListItem的列表.</p>\n<p><img src=\"/image/20170428105417.png\" alt=\"\"></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"4-定义Component的属性\"><a href=\"#4-定义Component的属性\" class=\"headerlink\" title=\"4.定义Component的属性\"></a>4.定义Component的属性</h4><hr>\n<p>列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.</p>\n<p>为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.</p>\n<p>像下面这样修改ListItemSpec:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">    @Prop String title,</div><div class=\"line\">    @Prop String subtitle) &#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(color)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(title)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(subtitle)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.</p>\n<p>神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(</span></span></div><div class=\"line\">    RecyclerBinder recyclerBinder, </div><div class=\"line\">    ComponentContext context) &#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();</div><div class=\"line\">    componentInfoBuilder.component(</div><div class=\"line\">        ListItem.create(context)</div><div class=\"line\">            .color(i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? Color.WHITE : Color.LTGRAY)</div><div class=\"line\">            .title(<span class=\"string\">\"Hello, world!\"</span>)</div><div class=\"line\">            .subtitle(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.</p>\n<p>运行app,你可以看到如下画面:</p>\n<p><img src=\"/image/20170428111627.png\" alt=\"\"></p>\n<p>你可以为@Prop注释指定更多的选项.例如下面的属性:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Prop</span>(optional = <span class=\"keyword\">true</span>, resType = ResType.DIMEN_OFFSET) <span class=\"keyword\">int</span> shadowRadius,</div></pre></td></tr></table></figure></p>\n<p>它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。</p>\n<p>恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/package-frame\" target=\"_blank\" rel=\"external\">com.facebook.litho.widgets</a>包中找到可以使用的预定义好的组件Component。你可以在<a href=\"https://github.com/facebook/litho/tree/master/sample-barebones\" target=\"_blank\" rel=\"external\">这里</a>找到完整的教程。请务必查看<a href=\"https://github.com/facebook/litho/tree/master/sample\" target=\"_blank\" rel=\"external\">此示例</a>和Litho API文档以获取更深入的代码。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/tutorial\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p></p><br></p></p>\n<p>本教程已经假定你已经按照<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a>正确设置了Litho.</p>\n<p>在本教程中，你将首先使用Litho在屏幕上构建一个基本的”Hello World！”，然后再构建一个”Hello World！” item组成的列表。在这个过程中,你将了解到Litho的构建块：<a href=\"http://fblitho.com/javadoc/com/facebook/litho/Component\">Component</a>和<a href=\"http://fblitho.com/javadoc/com/facebook/litho/LithoView\">LithoView</a>。你将学习如何设置Component的属性。</p>\n<p></p><br></p></p>\n<h4 id=\"1-Hello-World\"><a href=\"#1-Hello-World\" class=\"headerlink\" title=\"1.Hello World\"></a>1.Hello World</h4><hr>\n<p>在最初的步骤中,你将显示一个带有”Hello World”的View.</p>\n<p>首先,在Application中初始化SoLoader.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Litho在后台使用<a href=\"https://facebook.github.io/yoga/\">Yoga</a>加载布局.Yoga需要依赖本地库,而我们引入<a href=\"https://github.com/facebook/SoLoader\">SoLoader</a>来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.</p>\n<p>另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装<a href=\"\">Stetho</a>.</p>\n<p>下一步,添加一个Litho中预定义好的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Text\">Text</a> Component到activity中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext context = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component component = Text.create(context)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">        .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    setContentView(LithoView.create(context, component));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>LithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.</p>\n<p>那么component如何发挥作用呢?让我们看一下这段代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(context)</div><div class=\"line\">    .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">    .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>Text是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从<a href=\"https://facebook.github.io/react/\">React</a>中获得灵感,这些属性我们称之为props.</p>\n<p>稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.</p>\n<p>在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.</p>\n<p>完成了!让我们运行app,你可以在屏幕上看到这样的显示.</p>\n<p><img src=\"/image/20170428092530.png\" alt=\"\"></p>\n<p>虽然并不漂亮,但是这已经是一个好的开端了!</p>\n<p></p><br></p></p>\n<h4 id=\"2-你的第一个自定义Component\"><a href=\"#2-你的第一个自定义Component\" class=\"headerlink\" title=\"2.你的第一个自定义Component\"></a>2.你的第一个自定义Component</h4><hr>\n<p>在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!</p>\n<p>在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.</p>\n<p>准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。</p>\n<p>您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItemSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(Color.WHITE)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Hello world\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/Column\">Column</a>中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用<a href=\"https://facebook.github.io/yoga/\">Yoga</a>,你可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.</p>\n<p>你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component text = ListItem.create(context).build();</div></pre></td></tr></table></figure>\n<p>注意:你使用的是ListItem,而不是ListItemSpec.</p>\n<p>这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.</p>\n<p>在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a>中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).</p>\n<p>就这么简单。运行你的app,你应该看到如下的画面:</p>\n<p><img src=\"/image/20170428102947.png\" alt=\"\"></p>\n<p></p><br></p></p>\n<h4 id=\"3-创建一个列表\"><a href=\"#3-创建一个列表\" class=\"headerlink\" title=\"3.创建一个列表\"></a>3.创建一个列表</h4><hr>\n<p>你可以使用Litho的核心组件<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler\">Recycler</a> Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder\">RecyclerBinder</a>来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.<br>首先,在你的activity中,像下面这样定义Component:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(</div><div class=\"line\">    context,</div><div class=\"line\">    <span class=\"keyword\">new</span> LinearLayoutInfo(<span class=\"keyword\">this</span>, OrientationHelper.VERTICAL, <span class=\"keyword\">false</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> Component component = Recycler.create(context)</div><div class=\"line\">    .binder(recyclerBinder)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.</p>\n<p>然后再创建Recycler并且把它传递给LithoView.</p>\n<p>现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(RecyclerBinder recyclerBinder, ComponentContext context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">      recyclerBinder.insertItemAt(</div><div class=\"line\">          i,</div><div class=\"line\">          ComponentInfo.create()</div><div class=\"line\">              .component(ListItem.create(context).build())</div><div class=\"line\">              .build());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在代码中,我们需要创建一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentInfo\">ComponentInfo</a>来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.</p>\n<p>最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addContent(recyclerBinder, context);</div></pre></td></tr></table></figure></p>\n<p>运行app,你会看见一个可以滚动的具有32个ListItem的列表.</p>\n<p><img src=\"/image/20170428105417.png\" alt=\"\"></p>\n<p></p><br></p></p>\n<h4 id=\"4-定义Component的属性\"><a href=\"#4-定义Component的属性\" class=\"headerlink\" title=\"4.定义Component的属性\"></a>4.定义Component的属性</h4><hr>\n<p>列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.</p>\n<p>为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.</p>\n<p>像下面这样修改ListItemSpec:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">    @Prop String title,</div><div class=\"line\">    @Prop String subtitle)</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(color)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(title)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(subtitle)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.</p>\n<p>神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(</div><div class=\"line\">    RecyclerBinder recyclerBinder, </div><div class=\"line\">    ComponentContext context)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();</div><div class=\"line\">    componentInfoBuilder.component(</div><div class=\"line\">        ListItem.create(context)</div><div class=\"line\">            .color(i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? Color.WHITE : Color.LTGRAY)</div><div class=\"line\">            .title(<span class=\"string\">\"Hello, world!\"</span>)</div><div class=\"line\">            .subtitle(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.</p>\n<p>运行app,你可以看到如下画面:</p>\n<p><img src=\"/image/20170428111627.png\" alt=\"\"></p>\n<p>你可以为@Prop注释指定更多的选项.例如下面的属性:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Prop</span>(optional = <span class=\"keyword\">true</span>, resType = ResType.DIMEN_OFFSET) <span class=\"keyword\">int</span> shadowRadius,</div></pre></td></tr></table></figure></p>\n<p>它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。</p>\n<p>恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/package-frame\">com.facebook.litho.widgets</a>包中找到可以使用的预定义好的组件Component。你可以在<a href=\"https://github.com/facebook/litho/tree/master/sample-barebones\">这里</a>找到完整的教程。请务必查看<a href=\"https://github.com/facebook/litho/tree/master/sample\">此示例</a>和Litho API文档以获取更深入的代码。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-编写Component","date":"2017-04-27T08:05:10.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/writing-components)\n## 快速开始\n### 编写Component\n\n</p>\n</p>\n\n#### Component Specs\n---\n一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:\n- Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.\n- Mount spec: 一个可以渲染view或者drawable的的组件.\n\n现在，我们来看一下布局spec的整体结构：\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String title,\n      @Prop Uri imageUri) {\n    ...\n  }\n}\n```\n有几件事需要注意:\n- Component Spec只是有着特殊注释的普通java类.\n- Component Spec是完全无状态的,并且不包含任何的成员变量.\n- 带有@Prop注释的参数将会自动的添加到Component构造器中.\n- 为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅[入门指南](),了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.\n\n</p>\n</p>\n\n#### Spec,生命周期和Component类\n---\n一个Component Spec子类将被处理用于生成一个[ComponentLifecycle](http://fblitho.com/javadoc/com/facebook/litho/ComponentLifecycle)的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.\n\n这个生成的ComponentLifeCycle类就是今后你会在你的产品中[使用](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.\n\n生成的新类暴露出来的唯一的API是一个create（...）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。\n\n在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译-编写Component.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-编写Component\ndate: 2017-04-27 16:05:10\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/writing-components)\n## 快速开始\n### 编写Component\n\n</p>\n</p>\n\n#### Component Specs\n---\n一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:\n- Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.\n- Mount spec: 一个可以渲染view或者drawable的的组件.\n\n现在，我们来看一下布局spec的整体结构：\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String title,\n      @Prop Uri imageUri) {\n    ...\n  }\n}\n```\n有几件事需要注意:\n- Component Spec只是有着特殊注释的普通java类.\n- Component Spec是完全无状态的,并且不包含任何的成员变量.\n- 带有@Prop注释的参数将会自动的添加到Component构造器中.\n- 为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅[入门指南](),了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.\n\n</p>\n</p>\n\n#### Spec,生命周期和Component类\n---\n一个Component Spec子类将被处理用于生成一个[ComponentLifecycle](http://fblitho.com/javadoc/com/facebook/litho/ComponentLifecycle)的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.\n\n这个生成的ComponentLifeCycle类就是今后你会在你的产品中[使用](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.\n\n生成的新类暴露出来的唯一的API是一个create（...）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。\n\n在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-编写Component","published":1,"updated":"2017-05-11T09:24:02.605Z","_id":"cj2k76hqp0014ssrl9bkomunl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/writing-components\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"编写Component\"><a href=\"#编写Component\" class=\"headerlink\" title=\"编写Component\"></a>编写Component</h3><p></p><br><p></p><p></p>\n<h4 id=\"Component-Specs\"><a href=\"#Component-Specs\" class=\"headerlink\" title=\"Component Specs\"></a>Component Specs</h4><hr>\n<p>一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:</p>\n<ul>\n<li>Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.</li>\n<li>Mount spec: 一个可以渲染view或者drawable的的组件.</li>\n</ul>\n<p>现在，我们来看一下布局spec的整体结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String title,</div><div class=\"line\">      @Prop Uri imageUri) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有几件事需要注意:</p>\n<ul>\n<li>Component Spec只是有着特殊注释的普通java类.</li>\n<li>Component Spec是完全无状态的,并且不包含任何的成员变量.</li>\n<li>带有@Prop注释的参数将会自动的添加到Component构造器中.</li>\n<li>为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅<a href=\"\">入门指南</a>,了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.</li>\n</ul>\n<p></p><br><p></p><p></p>\n<h4 id=\"Spec-生命周期和Component类\"><a href=\"#Spec-生命周期和Component类\" class=\"headerlink\" title=\"Spec,生命周期和Component类\"></a>Spec,生命周期和Component类</h4><hr>\n<p>一个Component Spec子类将被处理用于生成一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentLifecycle\" target=\"_blank\" rel=\"external\">ComponentLifecycle</a>的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.</p>\n<p>这个生成的ComponentLifeCycle类就是今后你会在你的产品中<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用</a>的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.</p>\n<p>生成的新类暴露出来的唯一的API是一个create（…）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。</p>\n<p>在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/writing-components\">Litho-doc</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><h3 id=\"编写Component\"><a href=\"#编写Component\" class=\"headerlink\" title=\"编写Component\"></a>编写Component</h3><p></p><br></p></p>\n<h4 id=\"Component-Specs\"><a href=\"#Component-Specs\" class=\"headerlink\" title=\"Component Specs\"></a>Component Specs</h4><hr>\n<p>一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:</p>\n<ul>\n<li>Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.</li>\n<li>Mount spec: 一个可以渲染view或者drawable的的组件.</li>\n</ul>\n<p>现在，我们来看一下布局spec的整体结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String title,</div><div class=\"line\">      @Prop Uri imageUri)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有几件事需要注意:</p>\n<ul>\n<li>Component Spec只是有着特殊注释的普通java类.</li>\n<li>Component Spec是完全无状态的,并且不包含任何的成员变量.</li>\n<li>带有@Prop注释的参数将会自动的添加到Component构造器中.</li>\n<li>为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅<a href=\"\">入门指南</a>,了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.</li>\n</ul>\n<p></p><br></p></p>\n<h4 id=\"Spec-生命周期和Component类\"><a href=\"#Spec-生命周期和Component类\" class=\"headerlink\" title=\"Spec,生命周期和Component类\"></a>Spec,生命周期和Component类</h4><hr>\n<p>一个Component Spec子类将被处理用于生成一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentLifecycle\">ComponentLifecycle</a>的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.</p>\n<p>这个生成的ComponentLifeCycle类就是今后你会在你的产品中<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用</a>的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.</p>\n<p>生成的新类暴露出来的唯一的API是一个create（…）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。</p>\n<p>在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-LayoutSpecs","date":"2017-04-28T06:12:50.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/layout-specs)\n## 参考\n### Layout Specs\n\n</p>\n</p>\n\nLayout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.\n\n实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的[ComponentLayout](http://fblitho.com/javadoc/com/facebook/litho/ComponentLayout)对象的树.\n\n让我们从一个简单的例子开始:\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop int color,\n      @Prop String title) {\n\n      return Row.create(c)\n          .alignItems(CENTER)\n          .child(\n              SolidColor.create(c)\n                  .colorRes(color)\n                  .withLayout()\n                  .widthDip(40)\n                  .heightDip(40))\n          .child(\n              Text.create(c)\n                  .text(title)\n                  .textSizeRes(R.dimen.my_text_size)\n                  .withLayout()\n                  .flexGrow(1f))\n          .build();\n  }\n}\n```\n\n正如你所见,layout spec类使用@LayoutSpec注释.\n\n用@OnCreateLayout注释标注的方法必须以[ComponentContext](http://fblitho.com/javadoc/com/facebook/litho/ComponentContext)作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.\n\n在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.\n\n第一个子节点是一个[SolidColor](http://fblitho.com/javadoc/com/facebook/litho/widget/SolidColor) component,它拥有一个colorRes的Prop和40dp的宽和高.\n\n``` java\nSolidColor.create(c)\n    .uri(imageUri)\n    .withLayout()\n    .width(40)\n    .height(40)\n```\n\n第二个子节点是一个[Text](http://fblitho.com/javadoc/com/facebook/litho/widget/Text) Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.\n``` java\nText.create(c)\n    .text(title)\n    .textSizeRes(R.dimen.my_text_size)\n    .withLayout()\n    .grow(1f)\n```\n\n你可以查看完整的[Yoga](https://facebook.github.io/yoga/docs/learn-more/)文档来获取所有框架开放出的布局特性.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-28-Facebook出品的Android声明式开源新框架Litho文档翻译-LayoutSpecs.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-LayoutSpecs\ndate: 2017-04-28 14:12:50\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/layout-specs)\n## 参考\n### Layout Specs\n\n</p>\n</p>\n\nLayout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.\n\n实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的[ComponentLayout](http://fblitho.com/javadoc/com/facebook/litho/ComponentLayout)对象的树.\n\n让我们从一个简单的例子开始:\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop int color,\n      @Prop String title) {\n\n      return Row.create(c)\n          .alignItems(CENTER)\n          .child(\n              SolidColor.create(c)\n                  .colorRes(color)\n                  .withLayout()\n                  .widthDip(40)\n                  .heightDip(40))\n          .child(\n              Text.create(c)\n                  .text(title)\n                  .textSizeRes(R.dimen.my_text_size)\n                  .withLayout()\n                  .flexGrow(1f))\n          .build();\n  }\n}\n```\n\n正如你所见,layout spec类使用@LayoutSpec注释.\n\n用@OnCreateLayout注释标注的方法必须以[ComponentContext](http://fblitho.com/javadoc/com/facebook/litho/ComponentContext)作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.\n\n在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.\n\n第一个子节点是一个[SolidColor](http://fblitho.com/javadoc/com/facebook/litho/widget/SolidColor) component,它拥有一个colorRes的Prop和40dp的宽和高.\n\n``` java\nSolidColor.create(c)\n    .uri(imageUri)\n    .withLayout()\n    .width(40)\n    .height(40)\n```\n\n第二个子节点是一个[Text](http://fblitho.com/javadoc/com/facebook/litho/widget/Text) Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.\n``` java\nText.create(c)\n    .text(title)\n    .textSizeRes(R.dimen.my_text_size)\n    .withLayout()\n    .grow(1f)\n```\n\n你可以查看完整的[Yoga](https://facebook.github.io/yoga/docs/learn-more/)文档来获取所有框架开放出的布局特性.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-LayoutSpecs","published":1,"updated":"2017-05-11T09:25:01.626Z","_id":"cj2k76hqq0018ssrlx5jt09y7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/layout-specs\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Layout-Specs\"><a href=\"#Layout-Specs\" class=\"headerlink\" title=\"Layout Specs\"></a>Layout Specs</h3><p></p><br><p></p><p></p>\n<p>Layout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.</p>\n<p>实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentLayout\" target=\"_blank\" rel=\"external\">ComponentLayout</a>对象的树.</p>\n<p>让我们从一个简单的例子开始:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">      @Prop String title) &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">          .alignItems(CENTER)</div><div class=\"line\">          .child(</div><div class=\"line\">              SolidColor.create(c)</div><div class=\"line\">                  .colorRes(color)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .widthDip(<span class=\"number\">40</span>)</div><div class=\"line\">                  .heightDip(<span class=\"number\">40</span>))</div><div class=\"line\">          .child(</div><div class=\"line\">              Text.create(c)</div><div class=\"line\">                  .text(title)</div><div class=\"line\">                  .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .flexGrow(<span class=\"number\">1f</span>))</div><div class=\"line\">          .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>正如你所见,layout spec类使用@LayoutSpec注释.</p>\n<p>用@OnCreateLayout注释标注的方法必须以<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentContext\" target=\"_blank\" rel=\"external\">ComponentContext</a>作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.</p>\n<p>在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.</p>\n<p>第一个子节点是一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/SolidColor\" target=\"_blank\" rel=\"external\">SolidColor</a> component,它拥有一个colorRes的Prop和40dp的宽和高.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SolidColor.create(c)</div><div class=\"line\">    .uri(imageUri)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .width(<span class=\"number\">40</span>)</div><div class=\"line\">    .height(<span class=\"number\">40</span>)</div></pre></td></tr></table></figure>\n<p>第二个子节点是一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Text\" target=\"_blank\" rel=\"external\">Text</a> Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .grow(<span class=\"number\">1f</span>)</div></pre></td></tr></table></figure></p>\n<p>你可以查看完整的<a href=\"https://facebook.github.io/yoga/docs/learn-more/\" target=\"_blank\" rel=\"external\">Yoga</a>文档来获取所有框架开放出的布局特性.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/layout-specs\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Layout-Specs\"><a href=\"#Layout-Specs\" class=\"headerlink\" title=\"Layout Specs\"></a>Layout Specs</h3><p></p><br></p></p>\n<p>Layout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.</p>\n<p>实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentLayout\">ComponentLayout</a>对象的树.</p>\n<p>让我们从一个简单的例子开始:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">      @Prop String title)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">          .alignItems(CENTER)</div><div class=\"line\">          .child(</div><div class=\"line\">              SolidColor.create(c)</div><div class=\"line\">                  .colorRes(color)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .widthDip(<span class=\"number\">40</span>)</div><div class=\"line\">                  .heightDip(<span class=\"number\">40</span>))</div><div class=\"line\">          .child(</div><div class=\"line\">              Text.create(c)</div><div class=\"line\">                  .text(title)</div><div class=\"line\">                  .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .flexGrow(<span class=\"number\">1f</span>))</div><div class=\"line\">          .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>正如你所见,layout spec类使用@LayoutSpec注释.</p>\n<p>用@OnCreateLayout注释标注的方法必须以<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentContext\">ComponentContext</a>作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.</p>\n<p>在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.</p>\n<p>第一个子节点是一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/SolidColor\">SolidColor</a> component,它拥有一个colorRes的Prop和40dp的宽和高.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SolidColor.create(c)</div><div class=\"line\">    .uri(imageUri)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .width(<span class=\"number\">40</span>)</div><div class=\"line\">    .height(<span class=\"number\">40</span>)</div></pre></td></tr></table></figure>\n<p>第二个子节点是一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Text\">Text</a> Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .grow(<span class=\"number\">1f</span>)</div></pre></td></tr></table></figure></p>\n<p>你可以查看完整的<a href=\"https://facebook.github.io/yoga/docs/learn-more/\">Yoga</a>文档来获取所有框架开放出的布局特性.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-MountSpecs","date":"2017-04-28T06:12:50.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/mount-specs)\n## 参考\n### Mount Specs\n\n</p>\n</p>\n\n一个Mount Spec定义了一个可以渲染Views或者drawables的component.\n\nMount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.\n\nMount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.\n\nmount spec component的生命周期如下:\n- 在布局计算之前,运行@OnPrepare一次\n- 在布局计算过程中,可选择的运行OnMeasure.\n- 在布局计算之后,运行@OnBoundsDefined一次.\n- 在component添加到托管视图之前,运行@OnCreateMountContent\n- 在component添加到托管视图之前,运行@OnMount\n- 在component添加到托管视图之后,运行@OnBind\n- 在从托管视图移除component之前,运行@OnUnBind\n- 在从托管视图移除component之前,可选择的运行@OnUnmount\n\n</p>\n</p>\n\n#### 挂载\n---\n让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @Prop String colorName) {\n    colorDrawable.setColor(Color.parseColor(colorName));\n  }\n}\n```\n- 挂载操作的API与Android的[RecyclerView Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html)非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.\n- onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。\n- 挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).\n- onCreateMountContent不能使用@Prop或任何其他带注释的参数。\n- 鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。\n\n</p>\n</p>\n\n#### 阶段之间的输入和输出\n---\n你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.\n\n假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.\n\n让我们看看ColorComponent的@OnPrepare方法:\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnPrepare\n  static void onPrepare(\n      Context context,\n      @Prop String colorName,\n      Output<Integer> color) {\n    color.set(Color.parseColor(colorName));\n  }\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @FromPrepare int color) {\n    convertDrawable.setColor(color);\n  }\n}\n```\n在@MountSpec方法中使用Output<?>会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.\n\n在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.\n\n</p>\n</p>\n\n#### 测量\n---\n如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.\n\n现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.\n``` java\n@OnMeasure\nstatic void onMeasure(\n    ComponentContext context,\n    ComponentLayout layout,\n    int widthSpec,\n    int heightSpec,\n    Size size) {\n\n  // If width is undefined, set default size.\n  if (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) {\n    size.width = 40;\n  } else {\n    size.width = SizeSpec.getSize(widthSpec);\n  }\n\n  // If height is undefined, use 1.5 aspect ratio.\n  if (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) {\n    size.height = width * 1.5;\n  } else {\n    size.height = SizeSpec.getSize(heightSpec);\n  }\n}\n```\n在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的[MeasureSpec](https://developer.android.com/reference/android/view/View.MeasureSpec.html).\n\n就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.\n\n</p>\n</p>\n\n#### ShouldUpdate\n---\nMount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。\n@ShouldUpdate的调用的前提是component是\"纯渲染函数\"。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。\n一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为\"纯渲染的\"。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：\n\n``` java\n@ShouldUpdate(onMount = true)\npublic boolean shouldUpdate(Diff<String> someStringProp) {\n  return !someStringProp.getPrevious().equals(someStringProp.getNext());\n}\n```\n\nshouldUpdate中的参数是prop或状态的[对比差异](http://fblitho.com/javadoc/com/facebook/litho/Diff)。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<String>，以便能够比较此@Prop的旧值和新值。\nshouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。\n\n@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。\n\n@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-04-28-Facebook出品的Android声明式开源新框架Litho文档翻译-MountSpecs.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-MountSpecs\ndate: 2017-04-28 14:12:50\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/mount-specs)\n## 参考\n### Mount Specs\n\n</p>\n</p>\n\n一个Mount Spec定义了一个可以渲染Views或者drawables的component.\n\nMount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.\n\nMount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.\n\nmount spec component的生命周期如下:\n- 在布局计算之前,运行@OnPrepare一次\n- 在布局计算过程中,可选择的运行OnMeasure.\n- 在布局计算之后,运行@OnBoundsDefined一次.\n- 在component添加到托管视图之前,运行@OnCreateMountContent\n- 在component添加到托管视图之前,运行@OnMount\n- 在component添加到托管视图之后,运行@OnBind\n- 在从托管视图移除component之前,运行@OnUnBind\n- 在从托管视图移除component之前,可选择的运行@OnUnmount\n\n</p>\n</p>\n\n#### 挂载\n---\n让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @Prop String colorName) {\n    colorDrawable.setColor(Color.parseColor(colorName));\n  }\n}\n```\n- 挂载操作的API与Android的[RecyclerView Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html)非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.\n- onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。\n- 挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).\n- onCreateMountContent不能使用@Prop或任何其他带注释的参数。\n- 鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。\n\n</p>\n</p>\n\n#### 阶段之间的输入和输出\n---\n你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.\n\n假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.\n\n让我们看看ColorComponent的@OnPrepare方法:\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnPrepare\n  static void onPrepare(\n      Context context,\n      @Prop String colorName,\n      Output<Integer> color) {\n    color.set(Color.parseColor(colorName));\n  }\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @FromPrepare int color) {\n    convertDrawable.setColor(color);\n  }\n}\n```\n在@MountSpec方法中使用Output<?>会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.\n\n在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.\n\n</p>\n</p>\n\n#### 测量\n---\n如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.\n\n现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.\n``` java\n@OnMeasure\nstatic void onMeasure(\n    ComponentContext context,\n    ComponentLayout layout,\n    int widthSpec,\n    int heightSpec,\n    Size size) {\n\n  // If width is undefined, set default size.\n  if (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) {\n    size.width = 40;\n  } else {\n    size.width = SizeSpec.getSize(widthSpec);\n  }\n\n  // If height is undefined, use 1.5 aspect ratio.\n  if (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) {\n    size.height = width * 1.5;\n  } else {\n    size.height = SizeSpec.getSize(heightSpec);\n  }\n}\n```\n在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的[MeasureSpec](https://developer.android.com/reference/android/view/View.MeasureSpec.html).\n\n就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.\n\n</p>\n</p>\n\n#### ShouldUpdate\n---\nMount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。\n@ShouldUpdate的调用的前提是component是\"纯渲染函数\"。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。\n一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为\"纯渲染的\"。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：\n\n``` java\n@ShouldUpdate(onMount = true)\npublic boolean shouldUpdate(Diff<String> someStringProp) {\n  return !someStringProp.getPrevious().equals(someStringProp.getNext());\n}\n```\n\nshouldUpdate中的参数是prop或状态的[对比差异](http://fblitho.com/javadoc/com/facebook/litho/Diff)。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<String>，以便能够比较此@Prop的旧值和新值。\nshouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。\n\n@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。\n\n@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-MountSpecs","published":1,"updated":"2017-05-11T09:25:24.558Z","_id":"cj2k76hqs001bssrlmq1oal9b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/mount-specs\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Mount-Specs\"><a href=\"#Mount-Specs\" class=\"headerlink\" title=\"Mount Specs\"></a>Mount Specs</h3><p></p><br><p></p><p></p>\n<p>一个Mount Spec定义了一个可以渲染Views或者drawables的component.</p>\n<p>Mount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.</p>\n<p>Mount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.</p>\n<p>mount spec component的生命周期如下:</p>\n<ul>\n<li>在布局计算之前,运行@OnPrepare一次</li>\n<li>在布局计算过程中,可选择的运行OnMeasure.</li>\n<li>在布局计算之后,运行@OnBoundsDefined一次.</li>\n<li>在component添加到托管视图之前,运行@OnCreateMountContent</li>\n<li>在component添加到托管视图之前,运行@OnMount</li>\n<li>在component添加到托管视图之后,运行@OnBind</li>\n<li>在从托管视图移除component之前,运行@OnUnBind</li>\n<li>在从托管视图移除component之前,可选择的运行@OnUnmount</li>\n</ul>\n<p></p><br><p></p><p></p>\n<h4 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h4><hr>\n<p>让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @Prop String colorName) &#123;</div><div class=\"line\">    colorDrawable.setColor(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>挂载操作的API与Android的<a href=\"https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html\" target=\"_blank\" rel=\"external\">RecyclerView Adapter</a>非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.</li>\n<li>onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。</li>\n<li>挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).</li>\n<li>onCreateMountContent不能使用@Prop或任何其他带注释的参数。</li>\n<li>鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。</li>\n</ul>\n<p></p><br><p></p><p></p>\n<h4 id=\"阶段之间的输入和输出\"><a href=\"#阶段之间的输入和输出\" class=\"headerlink\" title=\"阶段之间的输入和输出\"></a>阶段之间的输入和输出</h4><hr>\n<p>你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.</p>\n<p>假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.</p>\n<p>让我们看看ColorComponent的@OnPrepare方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnPrepare</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepare</span><span class=\"params\">(</span></span></div><div class=\"line\">      Context context,</div><div class=\"line\">      @Prop String colorName,</div><div class=\"line\">      Output&lt;Integer&gt; color) &#123;</div><div class=\"line\">    color.set(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @FromPrepare <span class=\"keyword\">int</span> color) &#123;</div><div class=\"line\">    convertDrawable.setColor(color);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@MountSpec方法中使用Output&lt;?&gt;会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.</p>\n<p>在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"测量\"><a href=\"#测量\" class=\"headerlink\" title=\"测量\"></a>测量</h4><hr>\n<p>如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.</p>\n<p>现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnMeasure</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext context,</div><div class=\"line\">    ComponentLayout layout,</div><div class=\"line\">    <span class=\"keyword\">int</span> widthSpec,</div><div class=\"line\">    <span class=\"keyword\">int</span> heightSpec,</div><div class=\"line\">    Size size) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If width is undefined, set default size.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.width = <span class=\"number\">40</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.width = SizeSpec.getSize(widthSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If height is undefined, use 1.5 aspect ratio.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.height = width * <span class=\"number\">1.5</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.height = SizeSpec.getSize(heightSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的<a href=\"https://developer.android.com/reference/android/view/View.MeasureSpec.html\" target=\"_blank\" rel=\"external\">MeasureSpec</a>.</p>\n<p>就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"ShouldUpdate\"><a href=\"#ShouldUpdate\" class=\"headerlink\" title=\"ShouldUpdate\"></a>ShouldUpdate</h4><hr>\n<p>Mount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。<br>@ShouldUpdate的调用的前提是component是”纯渲染函数”。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。<br>一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为”纯渲染的”。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@ShouldUpdate</span>(onMount = <span class=\"keyword\">true</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldUpdate</span><span class=\"params\">(Diff&lt;String&gt; someStringProp)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> !someStringProp.getPrevious().equals(someStringProp.getNext());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>shouldUpdate中的参数是prop或状态的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/Diff\" target=\"_blank\" rel=\"external\">对比差异</a>。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<string>，以便能够比较此@Prop的旧值和新值。<br>shouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。</string></p>\n<p>@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。</p>\n<p>@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/mount-specs\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Mount-Specs\"><a href=\"#Mount-Specs\" class=\"headerlink\" title=\"Mount Specs\"></a>Mount Specs</h3><p></p><br></p></p>\n<p>一个Mount Spec定义了一个可以渲染Views或者drawables的component.</p>\n<p>Mount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.</p>\n<p>Mount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.</p>\n<p>mount spec component的生命周期如下:</p>\n<ul>\n<li>在布局计算之前,运行@OnPrepare一次</li>\n<li>在布局计算过程中,可选择的运行OnMeasure.</li>\n<li>在布局计算之后,运行@OnBoundsDefined一次.</li>\n<li>在component添加到托管视图之前,运行@OnCreateMountContent</li>\n<li>在component添加到托管视图之前,运行@OnMount</li>\n<li>在component添加到托管视图之后,运行@OnBind</li>\n<li>在从托管视图移除component之前,运行@OnUnBind</li>\n<li>在从托管视图移除component之前,可选择的运行@OnUnmount</li>\n</ul>\n<p></p><br></p></p>\n<h4 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h4><hr>\n<p>让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @Prop String colorName)</span> </span>&#123;</div><div class=\"line\">    colorDrawable.setColor(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>挂载操作的API与Android的<a href=\"https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html\">RecyclerView Adapter</a>非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.</li>\n<li>onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。</li>\n<li>挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).</li>\n<li>onCreateMountContent不能使用@Prop或任何其他带注释的参数。</li>\n<li>鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。</li>\n</ul>\n<p></p><br></p></p>\n<h4 id=\"阶段之间的输入和输出\"><a href=\"#阶段之间的输入和输出\" class=\"headerlink\" title=\"阶段之间的输入和输出\"></a>阶段之间的输入和输出</h4><hr>\n<p>你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.</p>\n<p>假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.</p>\n<p>让我们看看ColorComponent的@OnPrepare方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnPrepare</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepare</span><span class=\"params\">(</div><div class=\"line\">      Context context,</div><div class=\"line\">      @Prop String colorName,</div><div class=\"line\">      Output&lt;Integer&gt; color)</span> </span>&#123;</div><div class=\"line\">    color.set(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @FromPrepare <span class=\"keyword\">int</span> color)</span> </span>&#123;</div><div class=\"line\">    convertDrawable.setColor(color);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@MountSpec方法中使用Output&lt;?&gt;会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.</p>\n<p>在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.</p>\n<p></p><br></p></p>\n<h4 id=\"测量\"><a href=\"#测量\" class=\"headerlink\" title=\"测量\"></a>测量</h4><hr>\n<p>如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.</p>\n<p>现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnMeasure</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext context,</div><div class=\"line\">    ComponentLayout layout,</div><div class=\"line\">    <span class=\"keyword\">int</span> widthSpec,</div><div class=\"line\">    <span class=\"keyword\">int</span> heightSpec,</div><div class=\"line\">    Size size)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If width is undefined, set default size.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.width = <span class=\"number\">40</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.width = SizeSpec.getSize(widthSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If height is undefined, use 1.5 aspect ratio.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.height = width * <span class=\"number\">1.5</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.height = SizeSpec.getSize(heightSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的<a href=\"https://developer.android.com/reference/android/view/View.MeasureSpec.html\">MeasureSpec</a>.</p>\n<p>就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.</p>\n<p></p><br></p></p>\n<h4 id=\"ShouldUpdate\"><a href=\"#ShouldUpdate\" class=\"headerlink\" title=\"ShouldUpdate\"></a>ShouldUpdate</h4><hr>\n<p>Mount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。<br>@ShouldUpdate的调用的前提是component是”纯渲染函数”。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。<br>一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为”纯渲染的”。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@ShouldUpdate</span>(onMount = <span class=\"keyword\">true</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldUpdate</span><span class=\"params\">(Diff&lt;String&gt; someStringProp)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> !someStringProp.getPrevious().equals(someStringProp.getNext());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>shouldUpdate中的参数是prop或状态的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/Diff\">对比差异</a>。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<String>，以便能够比较此@Prop的旧值和新值。<br>shouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。</p>\n<p>@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。</p>\n<p>@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译--Props","date":"2017-05-02T03:19:18.000Z","_content":"欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/props)\n## 参考\n### Props\n\n</p>\n</p>\n\nLitho使用不可变的输入作为单向数据流提供给Component.Component使用[React](https://facebook.github.io/react/)中提出的名称props,作为它的输入.\n\n</p>\n</p>\n\n#### 定义和使用props\n---\n一个给定component中的prop是指在你的spec方法中,所有使用@Prop注释标注的参数的集合.你可以把它作为@Prop的参数声明出来,以在所有的方法中访问它的值.\n\n在多个lifecycle方法中,我们可以定义和访问相同的prop.注释处理器会确保你在所有的spec方法中使用一致的prop类型和注释参数.\n\n以下面的Component Spec为例:\n\n``` java\n@MountSpec\nclass MyComponentSpec {\n\n  @OnPrepare\n  static void onPrepare(\n      ComponentContext c,\n      @Prop(optional = true) String prop1) {\n    ...\n  }\n\n  @OnMount\n  static SomeDrawable onMount(\n      ComponentContext c,\n      SomeDrawable convertDrawable,\n      @Prop(optional = true) String prop1,\n      @Prop int prop2) {\n    if (prop1 != null) {\n    \t...\n    }\n  }\n}\n```\n\nMyComponentSpec定义了两个Prop,一个String类型的Prop,名叫prop1,和一个int类型的prop,名叫prop2.prop1是可选的,它需要在所有定义它的方法中进行标注,否则注释处理器将会抛出一个异常.\n\n当生命周期方法被调用时,@Prop参数将保存component创建时从它们的父级传递过来的值(或者它们的默认值).\n\nProp在LayoutSpec和MountSpec中定义和使用的方法都是一样的.\n\n</p>\n</p>\n\n#### 设置Prop\n---\n对每一个在spec中定义的独立的prop,注释处理器都会创建一个与prop名称相同的构造器模式的方法在Component的Builder中,用来把传入的参数设置到对应的prop上.\n\n你可以调用自动生成的Component Builder中的对应的方法传入参数来设置prop.\n\n``` java\nMyComponent.create(c)\n    .prop1(\"My prop 1\")\n    .prop2(256)\n    .build();\n```\n\n</p>\n</p>\n\n#### Prop的默认值\n---\n对可选的prop你可以省略设置它的value的动作,它会被自动设置为它这种类型在java中的默认值.你可能也会经常需要明确的定义component prop的默认值为你想要的值,而不是简单的使用java的默认值.\n\n你可以使用@PropDefault注释在Spec类中定义一个静态的成员变量作为prop的默认值.让我们为上面例子中prop定义一个默认值:\n\n``` java\n@MountSpec\npublic class MyComponentSpec {\n  @PropDefault static final String prop1 = \"mydefaultvalue\";\n  @PropDefault static final int prop2 = -1;\n\n  ...\n}\n```\n\n</p>\n</p>\n\n#### 资源类型\n---\n当创建布局的时候,经常会使用到Android资源系统中的值,例如dimension,color,string等等.Component框架提供了一个非常方便的方法使用注释来设置Android资源系统里的值到prop中.\n\n让我们看一个简单的例子:\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext context,\n      @Prop CharSequence someString,\n      @Prop int someSize,\n      @Prop int someColor) {\n    ...\n  }\n}\n```\n\n在上面的例子中,MyComponent拥有几个prop,它们预计会被设置为一个代表color的integer(someColor),一个代表像素的dimension(someSize)和一个String(someString).通常的,你需要使用资源的值来设置它们:\n``` java\nResources res = context.getResources();\n\nMyComponent.create(c)\n    .someString(res.getString(R.string.my_string))\n    .someSize(res.getDimensionPixelSize(R.dimen.my_dimen))\n    .someColor(res.getColor(R.color.my_color))\n```\n\n而component 框架允许你使用资源类型来注释你的prop,以便你的component builder可以生成更加方便的方法来供你直接使用资源的值.\n\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext context,\n      @Prop(resType = ResType.STRING) CharSequence someString,\n      @Prop(resType = ResType.DIMEN_SIZE) int someSize,\n      @Prop(resType = ResType.COLOR) int someColor) {\n    ...\n  }\n}\n```\n\n当你做了以上的更改后,MyComponent的builder将会根据被注释的prop的资源类型自动包含响应的Res,Attr,Dip,Px方法.因此你就可以像下面这么做:\n``` java\nMyComponent.create(c)\n    .someStringRes(R.string.my_string)\n    .someSizePx(10)\n    .someSizeDip(10)\n    .someColorAttr(android.R.attr.textColorTertiary)\n```\n\n其他支持的资源类型包括 ResType.STRING_ARRAY, ResType.INT, ResType.INT_ARRAY, ResType.BOOL, ResType.COLOR, ResType.DIMEN_OFFSET, ResType.FLOAT, and ResType.DRAWABLE.\n\n</p>\n</p>\n\n#### 不可变性\n---\nComponent中的prop是只读的.当Component的父级创建Component时传递给它的prop响应的值之后,在component的生命周期中,它们的值就不能被改变了.如果prop的值必须被更新,那么它的父级创建一个新的Component并且传递将新的值传递给它的prop.prop对象必须保证是不可变的.因为在[后台布局计算](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)中prop可能被多个线程同时访问.Prop的不可变性能够确保在你的component层级中不会出现线程安全问题.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>\n\n","source":"_posts/2017-05-02-Facebook出品的Android声明式开源新框架Litho文档翻译-Props.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译--Props\ndate: 2017-05-02 11:19:18\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/props)\n## 参考\n### Props\n\n</p>\n</p>\n\nLitho使用不可变的输入作为单向数据流提供给Component.Component使用[React](https://facebook.github.io/react/)中提出的名称props,作为它的输入.\n\n</p>\n</p>\n\n#### 定义和使用props\n---\n一个给定component中的prop是指在你的spec方法中,所有使用@Prop注释标注的参数的集合.你可以把它作为@Prop的参数声明出来,以在所有的方法中访问它的值.\n\n在多个lifecycle方法中,我们可以定义和访问相同的prop.注释处理器会确保你在所有的spec方法中使用一致的prop类型和注释参数.\n\n以下面的Component Spec为例:\n\n``` java\n@MountSpec\nclass MyComponentSpec {\n\n  @OnPrepare\n  static void onPrepare(\n      ComponentContext c,\n      @Prop(optional = true) String prop1) {\n    ...\n  }\n\n  @OnMount\n  static SomeDrawable onMount(\n      ComponentContext c,\n      SomeDrawable convertDrawable,\n      @Prop(optional = true) String prop1,\n      @Prop int prop2) {\n    if (prop1 != null) {\n    \t...\n    }\n  }\n}\n```\n\nMyComponentSpec定义了两个Prop,一个String类型的Prop,名叫prop1,和一个int类型的prop,名叫prop2.prop1是可选的,它需要在所有定义它的方法中进行标注,否则注释处理器将会抛出一个异常.\n\n当生命周期方法被调用时,@Prop参数将保存component创建时从它们的父级传递过来的值(或者它们的默认值).\n\nProp在LayoutSpec和MountSpec中定义和使用的方法都是一样的.\n\n</p>\n</p>\n\n#### 设置Prop\n---\n对每一个在spec中定义的独立的prop,注释处理器都会创建一个与prop名称相同的构造器模式的方法在Component的Builder中,用来把传入的参数设置到对应的prop上.\n\n你可以调用自动生成的Component Builder中的对应的方法传入参数来设置prop.\n\n``` java\nMyComponent.create(c)\n    .prop1(\"My prop 1\")\n    .prop2(256)\n    .build();\n```\n\n</p>\n</p>\n\n#### Prop的默认值\n---\n对可选的prop你可以省略设置它的value的动作,它会被自动设置为它这种类型在java中的默认值.你可能也会经常需要明确的定义component prop的默认值为你想要的值,而不是简单的使用java的默认值.\n\n你可以使用@PropDefault注释在Spec类中定义一个静态的成员变量作为prop的默认值.让我们为上面例子中prop定义一个默认值:\n\n``` java\n@MountSpec\npublic class MyComponentSpec {\n  @PropDefault static final String prop1 = \"mydefaultvalue\";\n  @PropDefault static final int prop2 = -1;\n\n  ...\n}\n```\n\n</p>\n</p>\n\n#### 资源类型\n---\n当创建布局的时候,经常会使用到Android资源系统中的值,例如dimension,color,string等等.Component框架提供了一个非常方便的方法使用注释来设置Android资源系统里的值到prop中.\n\n让我们看一个简单的例子:\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext context,\n      @Prop CharSequence someString,\n      @Prop int someSize,\n      @Prop int someColor) {\n    ...\n  }\n}\n```\n\n在上面的例子中,MyComponent拥有几个prop,它们预计会被设置为一个代表color的integer(someColor),一个代表像素的dimension(someSize)和一个String(someString).通常的,你需要使用资源的值来设置它们:\n``` java\nResources res = context.getResources();\n\nMyComponent.create(c)\n    .someString(res.getString(R.string.my_string))\n    .someSize(res.getDimensionPixelSize(R.dimen.my_dimen))\n    .someColor(res.getColor(R.color.my_color))\n```\n\n而component 框架允许你使用资源类型来注释你的prop,以便你的component builder可以生成更加方便的方法来供你直接使用资源的值.\n\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext context,\n      @Prop(resType = ResType.STRING) CharSequence someString,\n      @Prop(resType = ResType.DIMEN_SIZE) int someSize,\n      @Prop(resType = ResType.COLOR) int someColor) {\n    ...\n  }\n}\n```\n\n当你做了以上的更改后,MyComponent的builder将会根据被注释的prop的资源类型自动包含响应的Res,Attr,Dip,Px方法.因此你就可以像下面这么做:\n``` java\nMyComponent.create(c)\n    .someStringRes(R.string.my_string)\n    .someSizePx(10)\n    .someSizeDip(10)\n    .someColorAttr(android.R.attr.textColorTertiary)\n```\n\n其他支持的资源类型包括 ResType.STRING_ARRAY, ResType.INT, ResType.INT_ARRAY, ResType.BOOL, ResType.COLOR, ResType.DIMEN_OFFSET, ResType.FLOAT, and ResType.DRAWABLE.\n\n</p>\n</p>\n\n#### 不可变性\n---\nComponent中的prop是只读的.当Component的父级创建Component时传递给它的prop响应的值之后,在component的生命周期中,它们的值就不能被改变了.如果prop的值必须被更新,那么它的父级创建一个新的Component并且传递将新的值传递给它的prop.prop对象必须保证是不可变的.因为在[后台布局计算](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)中prop可能被多个线程同时访问.Prop的不可变性能够确保在你的component层级中不会出现线程安全问题.\n\n</p>\n</p>\n</p>\n</p>\n\n[回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n\n</p>\n</p>\n</p>\n</p>\n\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-Props","published":1,"updated":"2017-05-11T09:25:43.249Z","_id":"cj2k76hqx001fssrl1mbp7you","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/props\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p></p><br><p></p><p></p>\n<p>Litho使用不可变的输入作为单向数据流提供给Component.Component使用<a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"external\">React</a>中提出的名称props,作为它的输入.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"定义和使用props\"><a href=\"#定义和使用props\" class=\"headerlink\" title=\"定义和使用props\"></a>定义和使用props</h4><hr>\n<p>一个给定component中的prop是指在你的spec方法中,所有使用@Prop注释标注的参数的集合.你可以把它作为@Prop的参数声明出来,以在所有的方法中访问它的值.</p>\n<p>在多个lifecycle方法中,我们可以定义和访问相同的prop.注释处理器会确保你在所有的spec方法中使用一致的prop类型和注释参数.</p>\n<p>以下面的Component Spec为例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnPrepare</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepare</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop(optional = <span class=\"keyword\">true</span>) String prop1) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> SomeDrawable <span class=\"title\">onMount</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      SomeDrawable convertDrawable,</div><div class=\"line\">      @Prop(optional = <span class=\"keyword\">true</span>) String prop1,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> prop2) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (prop1 != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    \t...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MyComponentSpec定义了两个Prop,一个String类型的Prop,名叫prop1,和一个int类型的prop,名叫prop2.prop1是可选的,它需要在所有定义它的方法中进行标注,否则注释处理器将会抛出一个异常.</p>\n<p>当生命周期方法被调用时,@Prop参数将保存component创建时从它们的父级传递过来的值(或者它们的默认值).</p>\n<p>Prop在LayoutSpec和MountSpec中定义和使用的方法都是一样的.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"设置Prop\"><a href=\"#设置Prop\" class=\"headerlink\" title=\"设置Prop\"></a>设置Prop</h4><hr>\n<p>对每一个在spec中定义的独立的prop,注释处理器都会创建一个与prop名称相同的构造器模式的方法在Component的Builder中,用来把传入的参数设置到对应的prop上.</p>\n<p>你可以调用自动生成的Component Builder中的对应的方法传入参数来设置prop.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyComponent.create(c)</div><div class=\"line\">    .prop1(<span class=\"string\">\"My prop 1\"</span>)</div><div class=\"line\">    .prop2(<span class=\"number\">256</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"Prop的默认值\"><a href=\"#Prop的默认值\" class=\"headerlink\" title=\"Prop的默认值\"></a>Prop的默认值</h4><hr>\n<p>对可选的prop你可以省略设置它的value的动作,它会被自动设置为它这种类型在java中的默认值.你可能也会经常需要明确的定义component prop的默认值为你想要的值,而不是简单的使用java的默认值.</p>\n<p>你可以使用@PropDefault注释在Spec类中定义一个静态的成员变量作为prop的默认值.让我们为上面例子中prop定义一个默认值:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@PropDefault</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String prop1 = <span class=\"string\">\"mydefaultvalue\"</span>;</div><div class=\"line\">  <span class=\"meta\">@PropDefault</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> prop2 = -<span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"资源类型\"><a href=\"#资源类型\" class=\"headerlink\" title=\"资源类型\"></a>资源类型</h4><hr>\n<p>当创建布局的时候,经常会使用到Android资源系统中的值,例如dimension,color,string等等.Component框架提供了一个非常方便的方法使用注释来设置Android资源系统里的值到prop中.</p>\n<p>让我们看一个简单的例子:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      LayoutContext context,</div><div class=\"line\">      @Prop CharSequence someString,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> someSize,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> someColor) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面的例子中,MyComponent拥有几个prop,它们预计会被设置为一个代表color的integer(someColor),一个代表像素的dimension(someSize)和一个String(someString).通常的,你需要使用资源的值来设置它们:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resources res = context.getResources();</div><div class=\"line\"></div><div class=\"line\">MyComponent.create(c)</div><div class=\"line\">    .someString(res.getString(R.string.my_string))</div><div class=\"line\">    .someSize(res.getDimensionPixelSize(R.dimen.my_dimen))</div><div class=\"line\">    .someColor(res.getColor(R.color.my_color))</div></pre></td></tr></table></figure></p>\n<p>而component 框架允许你使用资源类型来注释你的prop,以便你的component builder可以生成更加方便的方法来供你直接使用资源的值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      LayoutContext context,</div><div class=\"line\">      @Prop(resType = ResType.STRING) CharSequence someString,</div><div class=\"line\">      @<span class=\"title\">Prop</span><span class=\"params\">(resType = ResType.DIMEN_SIZE)</span> <span class=\"keyword\">int</span> someSize,</div><div class=\"line\">      @<span class=\"title\">Prop</span><span class=\"params\">(resType = ResType.COLOR)</span> <span class=\"keyword\">int</span> someColor) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你做了以上的更改后,MyComponent的builder将会根据被注释的prop的资源类型自动包含响应的Res,Attr,Dip,Px方法.因此你就可以像下面这么做:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyComponent.create(c)</div><div class=\"line\">    .someStringRes(R.string.my_string)</div><div class=\"line\">    .someSizePx(<span class=\"number\">10</span>)</div><div class=\"line\">    .someSizeDip(<span class=\"number\">10</span>)</div><div class=\"line\">    .someColorAttr(android.R.attr.textColorTertiary)</div></pre></td></tr></table></figure></p>\n<p>其他支持的资源类型包括 ResType.STRING_ARRAY, ResType.INT, ResType.INT_ARRAY, ResType.BOOL, ResType.COLOR, ResType.DIMEN_OFFSET, ResType.FLOAT, and ResType.DRAWABLE.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><hr>\n<p>Component中的prop是只读的.当Component的父级创建Component时传递给它的prop响应的值之后,在component的生命周期中,它们的值就不能被改变了.如果prop的值必须被更新,那么它的父级创建一个新的Component并且传递将新的值传递给它的prop.prop对象必须保证是不可变的.因为在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">后台布局计算</a>中prop可能被多个线程同时访问.Prop的不可变性能够确保在你的component层级中不会出现线程安全问题.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/props\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p></p><br></p></p>\n<p>Litho使用不可变的输入作为单向数据流提供给Component.Component使用<a href=\"https://facebook.github.io/react/\">React</a>中提出的名称props,作为它的输入.</p>\n<p></p><br></p></p>\n<h4 id=\"定义和使用props\"><a href=\"#定义和使用props\" class=\"headerlink\" title=\"定义和使用props\"></a>定义和使用props</h4><hr>\n<p>一个给定component中的prop是指在你的spec方法中,所有使用@Prop注释标注的参数的集合.你可以把它作为@Prop的参数声明出来,以在所有的方法中访问它的值.</p>\n<p>在多个lifecycle方法中,我们可以定义和访问相同的prop.注释处理器会确保你在所有的spec方法中使用一致的prop类型和注释参数.</p>\n<p>以下面的Component Spec为例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnPrepare</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepare</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop(optional = <span class=\"keyword\">true</span>)</span> String prop1) </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> SomeDrawable <span class=\"title\">onMount</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      SomeDrawable convertDrawable,</div><div class=\"line\">      @Prop(optional = <span class=\"keyword\">true</span>)</span> String prop1,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> prop2) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (prop1 != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    \t...</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MyComponentSpec定义了两个Prop,一个String类型的Prop,名叫prop1,和一个int类型的prop,名叫prop2.prop1是可选的,它需要在所有定义它的方法中进行标注,否则注释处理器将会抛出一个异常.</p>\n<p>当生命周期方法被调用时,@Prop参数将保存component创建时从它们的父级传递过来的值(或者它们的默认值).</p>\n<p>Prop在LayoutSpec和MountSpec中定义和使用的方法都是一样的.</p>\n<p></p><br></p></p>\n<h4 id=\"设置Prop\"><a href=\"#设置Prop\" class=\"headerlink\" title=\"设置Prop\"></a>设置Prop</h4><hr>\n<p>对每一个在spec中定义的独立的prop,注释处理器都会创建一个与prop名称相同的构造器模式的方法在Component的Builder中,用来把传入的参数设置到对应的prop上.</p>\n<p>你可以调用自动生成的Component Builder中的对应的方法传入参数来设置prop.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyComponent.create(c)</div><div class=\"line\">    .prop1(<span class=\"string\">\"My prop 1\"</span>)</div><div class=\"line\">    .prop2(<span class=\"number\">256</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"Prop的默认值\"><a href=\"#Prop的默认值\" class=\"headerlink\" title=\"Prop的默认值\"></a>Prop的默认值</h4><hr>\n<p>对可选的prop你可以省略设置它的value的动作,它会被自动设置为它这种类型在java中的默认值.你可能也会经常需要明确的定义component prop的默认值为你想要的值,而不是简单的使用java的默认值.</p>\n<p>你可以使用@PropDefault注释在Spec类中定义一个静态的成员变量作为prop的默认值.让我们为上面例子中prop定义一个默认值:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@PropDefault</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String prop1 = <span class=\"string\">\"mydefaultvalue\"</span>;</div><div class=\"line\">  <span class=\"meta\">@PropDefault</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> prop2 = -<span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"资源类型\"><a href=\"#资源类型\" class=\"headerlink\" title=\"资源类型\"></a>资源类型</h4><hr>\n<p>当创建布局的时候,经常会使用到Android资源系统中的值,例如dimension,color,string等等.Component框架提供了一个非常方便的方法使用注释来设置Android资源系统里的值到prop中.</p>\n<p>让我们看一个简单的例子:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      LayoutContext context,</div><div class=\"line\">      @Prop CharSequence someString,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> someSize,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> someColor)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面的例子中,MyComponent拥有几个prop,它们预计会被设置为一个代表color的integer(someColor),一个代表像素的dimension(someSize)和一个String(someString).通常的,你需要使用资源的值来设置它们:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resources res = context.getResources();</div><div class=\"line\"></div><div class=\"line\">MyComponent.create(c)</div><div class=\"line\">    .someString(res.getString(R.string.my_string))</div><div class=\"line\">    .someSize(res.getDimensionPixelSize(R.dimen.my_dimen))</div><div class=\"line\">    .someColor(res.getColor(R.color.my_color))</div></pre></td></tr></table></figure></p>\n<p>而component 框架允许你使用资源类型来注释你的prop,以便你的component builder可以生成更加方便的方法来供你直接使用资源的值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      LayoutContext context,</div><div class=\"line\">      @Prop(resType = ResType.STRING)</span> CharSequence someString,</div><div class=\"line\">      @<span class=\"title\">Prop</span><span class=\"params\">(resType = ResType.DIMEN_SIZE)</span> <span class=\"keyword\">int</span> someSize,</div><div class=\"line\">      @<span class=\"title\">Prop</span><span class=\"params\">(resType = ResType.COLOR)</span> <span class=\"keyword\">int</span> someColor) </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你做了以上的更改后,MyComponent的builder将会根据被注释的prop的资源类型自动包含响应的Res,Attr,Dip,Px方法.因此你就可以像下面这么做:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyComponent.create(c)</div><div class=\"line\">    .someStringRes(R.string.my_string)</div><div class=\"line\">    .someSizePx(<span class=\"number\">10</span>)</div><div class=\"line\">    .someSizeDip(<span class=\"number\">10</span>)</div><div class=\"line\">    .someColorAttr(android.R.attr.textColorTertiary)</div></pre></td></tr></table></figure></p>\n<p>其他支持的资源类型包括 ResType.STRING_ARRAY, ResType.INT, ResType.INT_ARRAY, ResType.BOOL, ResType.COLOR, ResType.DIMEN_OFFSET, ResType.FLOAT, and ResType.DRAWABLE.</p>\n<p></p><br></p></p>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><hr>\n<p>Component中的prop是只读的.当Component的父级创建Component时传递给它的prop响应的值之后,在component的生命周期中,它们的值就不能被改变了.如果prop的值必须被更新,那么它的父级创建一个新的Component并且传递将新的值传递给它的prop.prop对象必须保证是不可变的.因为在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">后台布局计算</a>中prop可能被多个线程同时访问.Prop的不可变性能够确保在你的component层级中不会出现线程安全问题.</p>\n<p></p><br></p><br></p><br></p></p>\n<p><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></p>\n<p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-State","date":"2017-05-04T06:06:23.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/state)\n## 参考\n### State(状态)\n\n</p>\n</p>\n\nLitho Component可以包含两种类型的data:\n- prop:从父级继承并且在Component的生命周期内不能被改变.\n- state:封装实现的细节,由Component管理,并且对父级是透明的.\n\n一个常见的需要使用State的例子是:渲染一个Checkbox(复选框).Component需要根据选中还是未选中来渲染不同的drawable,但是这是一个Component内部的信息,而他的父级不需要去关心这个状态.\n\n</p>\n</p>\n\n#### 声明一个Component的状态\n--- \n你可以使用@State注释在spec的生命周期方法中定义一个Component的State,这与你定义Prop的方法是一样的.\n\n定义State元素在Layout Spec和Mount Spec的生命周期方法中可用:\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\t\t\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @State boolean isChecked) {\n      \n    return Column.create(c)\n        .child(Image.create(c)\n            .srcRes(isChecked\n                ? R.drawable.is_checked\n                : R.drawable.is_unchecked))\n        .child(Text.create(c)\n            .text(\"Submit\")\n            .clickHandler(Checkbox.onClickedText(c))\n        .build;\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onClickedText(\n      ComponentContext c,\n      @State boolean isChecked) {\n    ...\n  }\n}\n```\n</p>\n</p>\n#### 初始化State的值\n---\n为了给State设置一个初始值,你需要在你的Spec中使用@OnCreateInitialState注释来编写一个方法.\n\n关于编写@OnCreateInitialState方法,你需要知道以下几点:\n- 第一个参数必须是ComponentContext类型.\n- @Prop参数在这里也是可用的.\n- 剩下的参数的名称必须和其他生命周期方法中的@State参数保持一致,并且这些剩下参数的类型必须为[StateValue](http://fblitho.com/javadoc/com/facebook/litho/StateValue),其中泛型的类型与对应的@State一致.\n- @OnCreateInitialState 方法不是必须的.如果你不定义或者没有定义所有state的初始值,那么那些没有被定义初始值的state将会使用java的默认值.\n- 每一个Component的@OnCreateInitialState方法只会在Component第一次被添加到Component树的时候被调用一次.如果Component的key没有改变,那么后续对Component树布局的重新计算不会重新调用@OnCreateInitialState方法.\n- 你永远不需要自己调用@OnCreateInitialState方法.\n\n下面是例子是如何使用父级传下来的值来初始化一个复选框的state值.\n\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\n\n  @OnCreateInitialState\n  static void createInitialState(\n      ComponentContext c,\n      StateValue<Boolean> isChecked,\n      @Prop boolean initChecked) {\n\n    isChecked.set(initChecked);\n  }\n}\n```\n</p>\n</p>\n#### 定义State的更新\n---\n你可以使用@OnUpdateState在Spec中声明一个方法来定义Component的State更新的方式.\n\n你可以根据你想更新的state或者你的state依赖的参数的值来定义任意多的你需要的@OnUpdateState方法.\n\n每次对@OnUpdateState方法的调用都会触发一次新的对它的Component树的布局计算.为了获得更好的性能,如果在某种情况下会触发对多个State的更新,那么你就应该定义一个@OnUpdateMethod方法来更新所有这些state的值.合并这些更新操作可以减少新的布局计算的次数,从而提升性能.\n\n关于编写@OnUpdateState方法,你需要知道以下几点:\n- 代表State的参数名必须和其他方法中使用@State定义的参数名一样,并且类型必须为StateValue,泛型类型也必须和对应的@State参数的类型一致.\n- @Param参数也是可以使用的.如果你的State的值需要依赖于Prop,你可以在@OnupdateState函数的参数中使用@Param声明,这样就可以在更新被触发的时候传递prop的值进来了.\n- 所有其他的参数都必须在其他生命周期方法中有一个对应的@State参数,并且类型必须为StateValue,泛型的类型也必须和@State参数一致.\n\n下面是如何给checkbox定义一个state方法:\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\t\t\n\n  @OnUpdateState\n  static void updateCheckboxState(StateValue<Boolean> isChecked) {\n    isChecked.set(!isChecked.get());\n  }\n}\n```\n如果你想要合并多个state更新到一个方法中,你只需要把所有这些state都添加到一个@OnUpdateState方法中:\n``` java\n@OnUpdateState\nstatic void updateMultipleStates(\n    StateValue<Boolean> stateOne,\n    StateValue<String> stateTwo,\n    @Param int someParam) {\n\n  final boolean thresholdReached = someParam > 100;\n  stateOne.set(thresholdReached);\n  stateTwo.set(thresholdReached ? \"reached\" : \"not reached\");\n}\n\n```\n</p>\n</p>\n#### 调用State更新\n---\n对你的Spec中的每一个@OnUpdateState方法,自动生成的Component中都会包含两个方法,他们在后台都会委托给@OnUpdateState方法处理.\n- 一个和@OnUpdateState同名的静态方法,它将同步的应用state的更新.\n- 一个和@OnUpdateState同名并且加上Async后缀的静态方法,它将异步的触发State的更新.这两个方法都使用ComponentContext作为第一个参数,后面的参数与你在@OnUpdateState方法中使用@Param定义的参数相同.\n\n下面展示了当用户点击的时候如何调用State更新方法来更新你的复选框:\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\t\t\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @State boolean isChecked) {\n      \n    return Column.create(c)\n        .child(Image.create(c)\n        .srcRes(isChecked\n            ? R.drawable.is_checked\n            : R.drawable.is_unchecked))\n        .clickHandler(Checkbox.onCheckboxClicked(c)))\n    .build;\n  }\n\n  @OnUpdateState\n  static void updateCheckbox(StateValue<Boolean> isChecked) {\n    isChecked.set(!isChecked.get());\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onCheckboxClicked(ComponentContext c) {\n    Checkbox.updateCheckboxAsync(c);\n    // Checkbox.updateCheckbox(c); for a sync update\n  }\n}\n```\n\n当你调用State更新方法的时候,你需要记住下面几点:\n- 当调用一个State更新方法的时候,作为第一个参数的ComponentContext必须总是为更新发生时的生命周期方法中传递进来的那个ComponentContext.这个context包含了现在已知的State的值等重要信息,在布局计算时,这些信息对把旧的Component转换成新的Component非常重要.\n- 在LayoutSpec中,你应该避免在onCreateLayout中调用State更新方法,除非你完全确定它只会发生很少并且确定的的次数。每一次调用State更新方法都会引起Component树的一次新的布局计算，而计算又会反过来调用它其中所有的Component的onCreateLayout方法，因此，这很容易引起死循环。你应该考虑是否使用懒汉式State更新(下面会说到)才是更加适用于你的情况的方法.\n- 在MountSpec中,永远也不要在mount和bind方法中调用State更新方法.如果你需要在这类方法中更新State的值,你应该使用下面会讲到的懒汉式State更新来替代.\n</p>\n</p>\n\n#### Key和识别Component\n---\nLitho框架将会为每一个Component设置一个key值,这个值取决于它的类型和它的父级的key值.你可以使用这个key值来确定在State更新的时候哪一个Component才是我们需要更新的,或者使用这个key值在遍历Component树的时候查找Component.\n\n具有相同父级的同类型Component将会被设定相同的key值.因此我们需要一种方法来唯一的识别它们.\n\n此外,当组件的State或者Prop被更新并且Component树重新被创建的时候,会出现一些Component被移除,添加或者在树中重新安排位置的情况.因为Component可能是动态的,因此我们需要一种方法,能在即使Component树改变的情况下还能追踪到应该是哪个Component去进行状态更新.\n\nComponent.Builder类会暴露一个.key()方法,你可以使用它来在创建Component的时候制定一个唯一的key给它,以便将来能够识别它.\n\n当你在一个父控件下拥有多个相同类型的Component时,或者你期望的布局内容是动态的时候,你就应该设置这个key值.\n\n一种最常见的你需要手动给你的Component设置key的情况是,你在一个循环中创建和添加子Component:\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @State boolean isChecked) {\n\n  final ComponentLayout.Builder parent = Column.create(c);\n  for (int i = 0; i < 10; i++) {\n    parent.child(Text.create(c).key(\"key\" +i));\n  }\n  return parent.build();\n}\n```\n</p>\n</p>\n\n#### 懒汉式State更新\n---\n当你想要更新State的值但是又不想立刻触发一次性的布局计算的时候,你可以使用懒汉式State更新.当你调用懒汉式State更新之后,Component将会保持现有的State值直到下一次布局计算被别的机制(例如收到一个新的prop或者定期的State更新)触发,此时State的值才会被更新.在不需要立刻进行布局计算的情况下,懒汉式State更新对想要更新内部Component信息并且在Component树的重新布局中保持这些信息是非常实用的.\n\n为了使用懒汉式State更新,你需要在@State注释中把canUpdateLazily参数设置为true.\n\n如果我们把一个名叫foo的State标记为canUpdateLazily,Litho框架将会自动生成一个静态State更新方法,名叫LazyUpdateFoo,它将带有一个参数,用于设置foo的新值.\n\nState被标记为canUpdateLazily后依然可以使用常规的State更新.\n\n让我们看下面的例子:\n\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    final ComponentContext c,\n    @State(canUpdateLazily = true) String foo) {\n\n  FooComponent.lazyUpdateFoo(context, \"updated foo\");\n  return Column.create(c)\n      .child(\n          Text.create(c)\n              .text(foo))\n      .build();\n}\n\n@OnCreateInitialState\nstatic void onCreateInitialState(StateValue<String> foo) {\n  foo.set(\"first foo\");\n}\n```\n\n第一次FooComponent被渲染的时候,即使它的State foo已经被懒汉式更新成另一个值了,它的子Text Component也会显示\"first foo\".当一个常规的State更新被触发,或者收到一个新的prop的时候,就会触发布局计算,懒汉式更新将会生效,Text将会被渲染成\"update foo\".\n</p>\n</p>\n\n#### 不可变性\n---\n由于[后台布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)机制,State可以在任何时候被多个线程访问.为了确保线程安全,State对象应该是不可变的(即使有极少数情况下不能实现这一点,那么也应该确保State对象是线程安全的).最简单的解决方案是基于原语来表述你的State,因为根据定义,原语就是不可变的.\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","source":"_posts/2017-05-04-Facebook出品的Android声明式开源新框架Litho文档翻译-State.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-State\ndate: 2017-05-04 14:06:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/state)\n## 参考\n### State(状态)\n\n</p>\n</p>\n\nLitho Component可以包含两种类型的data:\n- prop:从父级继承并且在Component的生命周期内不能被改变.\n- state:封装实现的细节,由Component管理,并且对父级是透明的.\n\n一个常见的需要使用State的例子是:渲染一个Checkbox(复选框).Component需要根据选中还是未选中来渲染不同的drawable,但是这是一个Component内部的信息,而他的父级不需要去关心这个状态.\n\n</p>\n</p>\n\n#### 声明一个Component的状态\n--- \n你可以使用@State注释在spec的生命周期方法中定义一个Component的State,这与你定义Prop的方法是一样的.\n\n定义State元素在Layout Spec和Mount Spec的生命周期方法中可用:\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\t\t\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @State boolean isChecked) {\n      \n    return Column.create(c)\n        .child(Image.create(c)\n            .srcRes(isChecked\n                ? R.drawable.is_checked\n                : R.drawable.is_unchecked))\n        .child(Text.create(c)\n            .text(\"Submit\")\n            .clickHandler(Checkbox.onClickedText(c))\n        .build;\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onClickedText(\n      ComponentContext c,\n      @State boolean isChecked) {\n    ...\n  }\n}\n```\n</p>\n</p>\n#### 初始化State的值\n---\n为了给State设置一个初始值,你需要在你的Spec中使用@OnCreateInitialState注释来编写一个方法.\n\n关于编写@OnCreateInitialState方法,你需要知道以下几点:\n- 第一个参数必须是ComponentContext类型.\n- @Prop参数在这里也是可用的.\n- 剩下的参数的名称必须和其他生命周期方法中的@State参数保持一致,并且这些剩下参数的类型必须为[StateValue](http://fblitho.com/javadoc/com/facebook/litho/StateValue),其中泛型的类型与对应的@State一致.\n- @OnCreateInitialState 方法不是必须的.如果你不定义或者没有定义所有state的初始值,那么那些没有被定义初始值的state将会使用java的默认值.\n- 每一个Component的@OnCreateInitialState方法只会在Component第一次被添加到Component树的时候被调用一次.如果Component的key没有改变,那么后续对Component树布局的重新计算不会重新调用@OnCreateInitialState方法.\n- 你永远不需要自己调用@OnCreateInitialState方法.\n\n下面是例子是如何使用父级传下来的值来初始化一个复选框的state值.\n\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\n\n  @OnCreateInitialState\n  static void createInitialState(\n      ComponentContext c,\n      StateValue<Boolean> isChecked,\n      @Prop boolean initChecked) {\n\n    isChecked.set(initChecked);\n  }\n}\n```\n</p>\n</p>\n#### 定义State的更新\n---\n你可以使用@OnUpdateState在Spec中声明一个方法来定义Component的State更新的方式.\n\n你可以根据你想更新的state或者你的state依赖的参数的值来定义任意多的你需要的@OnUpdateState方法.\n\n每次对@OnUpdateState方法的调用都会触发一次新的对它的Component树的布局计算.为了获得更好的性能,如果在某种情况下会触发对多个State的更新,那么你就应该定义一个@OnUpdateMethod方法来更新所有这些state的值.合并这些更新操作可以减少新的布局计算的次数,从而提升性能.\n\n关于编写@OnUpdateState方法,你需要知道以下几点:\n- 代表State的参数名必须和其他方法中使用@State定义的参数名一样,并且类型必须为StateValue,泛型类型也必须和对应的@State参数的类型一致.\n- @Param参数也是可以使用的.如果你的State的值需要依赖于Prop,你可以在@OnupdateState函数的参数中使用@Param声明,这样就可以在更新被触发的时候传递prop的值进来了.\n- 所有其他的参数都必须在其他生命周期方法中有一个对应的@State参数,并且类型必须为StateValue,泛型的类型也必须和@State参数一致.\n\n下面是如何给checkbox定义一个state方法:\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\t\t\n\n  @OnUpdateState\n  static void updateCheckboxState(StateValue<Boolean> isChecked) {\n    isChecked.set(!isChecked.get());\n  }\n}\n```\n如果你想要合并多个state更新到一个方法中,你只需要把所有这些state都添加到一个@OnUpdateState方法中:\n``` java\n@OnUpdateState\nstatic void updateMultipleStates(\n    StateValue<Boolean> stateOne,\n    StateValue<String> stateTwo,\n    @Param int someParam) {\n\n  final boolean thresholdReached = someParam > 100;\n  stateOne.set(thresholdReached);\n  stateTwo.set(thresholdReached ? \"reached\" : \"not reached\");\n}\n\n```\n</p>\n</p>\n#### 调用State更新\n---\n对你的Spec中的每一个@OnUpdateState方法,自动生成的Component中都会包含两个方法,他们在后台都会委托给@OnUpdateState方法处理.\n- 一个和@OnUpdateState同名的静态方法,它将同步的应用state的更新.\n- 一个和@OnUpdateState同名并且加上Async后缀的静态方法,它将异步的触发State的更新.这两个方法都使用ComponentContext作为第一个参数,后面的参数与你在@OnUpdateState方法中使用@Param定义的参数相同.\n\n下面展示了当用户点击的时候如何调用State更新方法来更新你的复选框:\n``` java\n@LayoutSpec\t\t\npublic class CheckboxSpec {\t\t\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @State boolean isChecked) {\n      \n    return Column.create(c)\n        .child(Image.create(c)\n        .srcRes(isChecked\n            ? R.drawable.is_checked\n            : R.drawable.is_unchecked))\n        .clickHandler(Checkbox.onCheckboxClicked(c)))\n    .build;\n  }\n\n  @OnUpdateState\n  static void updateCheckbox(StateValue<Boolean> isChecked) {\n    isChecked.set(!isChecked.get());\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onCheckboxClicked(ComponentContext c) {\n    Checkbox.updateCheckboxAsync(c);\n    // Checkbox.updateCheckbox(c); for a sync update\n  }\n}\n```\n\n当你调用State更新方法的时候,你需要记住下面几点:\n- 当调用一个State更新方法的时候,作为第一个参数的ComponentContext必须总是为更新发生时的生命周期方法中传递进来的那个ComponentContext.这个context包含了现在已知的State的值等重要信息,在布局计算时,这些信息对把旧的Component转换成新的Component非常重要.\n- 在LayoutSpec中,你应该避免在onCreateLayout中调用State更新方法,除非你完全确定它只会发生很少并且确定的的次数。每一次调用State更新方法都会引起Component树的一次新的布局计算，而计算又会反过来调用它其中所有的Component的onCreateLayout方法，因此，这很容易引起死循环。你应该考虑是否使用懒汉式State更新(下面会说到)才是更加适用于你的情况的方法.\n- 在MountSpec中,永远也不要在mount和bind方法中调用State更新方法.如果你需要在这类方法中更新State的值,你应该使用下面会讲到的懒汉式State更新来替代.\n</p>\n</p>\n\n#### Key和识别Component\n---\nLitho框架将会为每一个Component设置一个key值,这个值取决于它的类型和它的父级的key值.你可以使用这个key值来确定在State更新的时候哪一个Component才是我们需要更新的,或者使用这个key值在遍历Component树的时候查找Component.\n\n具有相同父级的同类型Component将会被设定相同的key值.因此我们需要一种方法来唯一的识别它们.\n\n此外,当组件的State或者Prop被更新并且Component树重新被创建的时候,会出现一些Component被移除,添加或者在树中重新安排位置的情况.因为Component可能是动态的,因此我们需要一种方法,能在即使Component树改变的情况下还能追踪到应该是哪个Component去进行状态更新.\n\nComponent.Builder类会暴露一个.key()方法,你可以使用它来在创建Component的时候制定一个唯一的key给它,以便将来能够识别它.\n\n当你在一个父控件下拥有多个相同类型的Component时,或者你期望的布局内容是动态的时候,你就应该设置这个key值.\n\n一种最常见的你需要手动给你的Component设置key的情况是,你在一个循环中创建和添加子Component:\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @State boolean isChecked) {\n\n  final ComponentLayout.Builder parent = Column.create(c);\n  for (int i = 0; i < 10; i++) {\n    parent.child(Text.create(c).key(\"key\" +i));\n  }\n  return parent.build();\n}\n```\n</p>\n</p>\n\n#### 懒汉式State更新\n---\n当你想要更新State的值但是又不想立刻触发一次性的布局计算的时候,你可以使用懒汉式State更新.当你调用懒汉式State更新之后,Component将会保持现有的State值直到下一次布局计算被别的机制(例如收到一个新的prop或者定期的State更新)触发,此时State的值才会被更新.在不需要立刻进行布局计算的情况下,懒汉式State更新对想要更新内部Component信息并且在Component树的重新布局中保持这些信息是非常实用的.\n\n为了使用懒汉式State更新,你需要在@State注释中把canUpdateLazily参数设置为true.\n\n如果我们把一个名叫foo的State标记为canUpdateLazily,Litho框架将会自动生成一个静态State更新方法,名叫LazyUpdateFoo,它将带有一个参数,用于设置foo的新值.\n\nState被标记为canUpdateLazily后依然可以使用常规的State更新.\n\n让我们看下面的例子:\n\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    final ComponentContext c,\n    @State(canUpdateLazily = true) String foo) {\n\n  FooComponent.lazyUpdateFoo(context, \"updated foo\");\n  return Column.create(c)\n      .child(\n          Text.create(c)\n              .text(foo))\n      .build();\n}\n\n@OnCreateInitialState\nstatic void onCreateInitialState(StateValue<String> foo) {\n  foo.set(\"first foo\");\n}\n```\n\n第一次FooComponent被渲染的时候,即使它的State foo已经被懒汉式更新成另一个值了,它的子Text Component也会显示\"first foo\".当一个常规的State更新被触发,或者收到一个新的prop的时候,就会触发布局计算,懒汉式更新将会生效,Text将会被渲染成\"update foo\".\n</p>\n</p>\n\n#### 不可变性\n---\n由于[后台布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)机制,State可以在任何时候被多个线程访问.为了确保线程安全,State对象应该是不可变的(即使有极少数情况下不能实现这一点,那么也应该确保State对象是线程安全的).最简单的解决方案是基于原语来表述你的State,因为根据定义,原语就是不可变的.\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-State","published":1,"updated":"2017-05-11T09:25:56.077Z","_id":"cj2k76hqz001issrlqi7j99vf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/state\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"State-状态\"><a href=\"#State-状态\" class=\"headerlink\" title=\"State(状态)\"></a>State(状态)</h3><p></p><br><p></p><p></p>\n<p>Litho Component可以包含两种类型的data:</p>\n<ul>\n<li>prop:从父级继承并且在Component的生命周期内不能被改变.</li>\n<li>state:封装实现的细节,由Component管理,并且对父级是透明的.</li>\n</ul>\n<p>一个常见的需要使用State的例子是:渲染一个Checkbox(复选框).Component需要根据选中还是未选中来渲染不同的drawable,但是这是一个Component内部的信息,而他的父级不需要去关心这个状态.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"声明一个Component的状态\"><a href=\"#声明一个Component的状态\" class=\"headerlink\" title=\"声明一个Component的状态\"></a>声明一个Component的状态</h4><hr>\n<p>你可以使用@State注释在spec的生命周期方法中定义一个Component的State,这与你定义Prop的方法是一样的.</p>\n<p>定义State元素在Layout Spec和Mount Spec的生命周期方法中可用:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;\t\t</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @State <span class=\"keyword\">boolean</span> isChecked) &#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .child(Image.create(c)</div><div class=\"line\">            .srcRes(isChecked</div><div class=\"line\">                ? R.drawable.is_checked</div><div class=\"line\">                : R.drawable.is_unchecked))</div><div class=\"line\">        .child(Text.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"Submit\"</span>)</div><div class=\"line\">            .clickHandler(Checkbox.onClickedText(c))</div><div class=\"line\">        .build;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onClickedText</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @State <span class=\"keyword\">boolean</span> isChecked) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"初始化State的值\"><a href=\"#初始化State的值\" class=\"headerlink\" title=\"初始化State的值\"></a>初始化State的值</h4><hr>\n<p>为了给State设置一个初始值,你需要在你的Spec中使用@OnCreateInitialState注释来编写一个方法.</p>\n<p>关于编写@OnCreateInitialState方法,你需要知道以下几点:</p>\n<ul>\n<li>第一个参数必须是ComponentContext类型.</li>\n<li>@Prop参数在这里也是可用的.</li>\n<li>剩下的参数的名称必须和其他生命周期方法中的@State参数保持一致,并且这些剩下参数的类型必须为<a href=\"http://fblitho.com/javadoc/com/facebook/litho/StateValue\" target=\"_blank\" rel=\"external\">StateValue</a>,其中泛型的类型与对应的@State一致.</li>\n<li>@OnCreateInitialState 方法不是必须的.如果你不定义或者没有定义所有state的初始值,那么那些没有被定义初始值的state将会使用java的默认值.</li>\n<li>每一个Component的@OnCreateInitialState方法只会在Component第一次被添加到Component树的时候被调用一次.如果Component的key没有改变,那么后续对Component树布局的重新计算不会重新调用@OnCreateInitialState方法.</li>\n<li>你永远不需要自己调用@OnCreateInitialState方法.</li>\n</ul>\n<p>下面是例子是如何使用父级传下来的值来初始化一个复选框的state值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateInitialState</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">createInitialState</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      StateValue&lt;Boolean&gt; isChecked,</div><div class=\"line\">      @Prop <span class=\"keyword\">boolean</span> initChecked) &#123;</div><div class=\"line\"></div><div class=\"line\">    isChecked.set(initChecked);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"定义State的更新\"><a href=\"#定义State的更新\" class=\"headerlink\" title=\"定义State的更新\"></a>定义State的更新</h4><hr>\n<p>你可以使用@OnUpdateState在Spec中声明一个方法来定义Component的State更新的方式.</p>\n<p>你可以根据你想更新的state或者你的state依赖的参数的值来定义任意多的你需要的@OnUpdateState方法.</p>\n<p>每次对@OnUpdateState方法的调用都会触发一次新的对它的Component树的布局计算.为了获得更好的性能,如果在某种情况下会触发对多个State的更新,那么你就应该定义一个@OnUpdateMethod方法来更新所有这些state的值.合并这些更新操作可以减少新的布局计算的次数,从而提升性能.</p>\n<p>关于编写@OnUpdateState方法,你需要知道以下几点:</p>\n<ul>\n<li>代表State的参数名必须和其他方法中使用@State定义的参数名一样,并且类型必须为StateValue,泛型类型也必须和对应的@State参数的类型一致.</li>\n<li>@Param参数也是可以使用的.如果你的State的值需要依赖于Prop,你可以在@OnupdateState函数的参数中使用@Param声明,这样就可以在更新被触发的时候传递prop的值进来了.</li>\n<li>所有其他的参数都必须在其他生命周期方法中有一个对应的@State参数,并且类型必须为StateValue,泛型的类型也必须和@State参数一致.</li>\n</ul>\n<p>下面是如何给checkbox定义一个state方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;\t\t</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnUpdateState</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateCheckboxState</span><span class=\"params\">(StateValue&lt;Boolean&gt; isChecked)</span> </span>&#123;</div><div class=\"line\">    isChecked.set(!isChecked.get());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果你想要合并多个state更新到一个方法中,你只需要把所有这些state都添加到一个@OnUpdateState方法中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnUpdateState</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateMultipleStates</span><span class=\"params\">(</span></span></div><div class=\"line\">    StateValue&lt;Boolean&gt; stateOne,</div><div class=\"line\">    StateValue&lt;String&gt; stateTwo,</div><div class=\"line\">    @Param <span class=\"keyword\">int</span> someParam) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> thresholdReached = someParam &gt; <span class=\"number\">100</span>;</div><div class=\"line\">  stateOne.set(thresholdReached);</div><div class=\"line\">  stateTwo.set(thresholdReached ? <span class=\"string\">\"reached\"</span> : <span class=\"string\">\"not reached\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"调用State更新\"><a href=\"#调用State更新\" class=\"headerlink\" title=\"调用State更新\"></a>调用State更新</h4><hr>\n<p>对你的Spec中的每一个@OnUpdateState方法,自动生成的Component中都会包含两个方法,他们在后台都会委托给@OnUpdateState方法处理.</p>\n<ul>\n<li>一个和@OnUpdateState同名的静态方法,它将同步的应用state的更新.</li>\n<li>一个和@OnUpdateState同名并且加上Async后缀的静态方法,它将异步的触发State的更新.这两个方法都使用ComponentContext作为第一个参数,后面的参数与你在@OnUpdateState方法中使用@Param定义的参数相同.</li>\n</ul>\n<p>下面展示了当用户点击的时候如何调用State更新方法来更新你的复选框:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;\t\t</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @State <span class=\"keyword\">boolean</span> isChecked) &#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .child(Image.create(c)</div><div class=\"line\">        .srcRes(isChecked</div><div class=\"line\">            ? R.drawable.is_checked</div><div class=\"line\">            : R.drawable.is_unchecked))</div><div class=\"line\">        .clickHandler(Checkbox.onCheckboxClicked(c)))</div><div class=\"line\">    .build;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnUpdateState</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateCheckbox</span><span class=\"params\">(StateValue&lt;Boolean&gt; isChecked)</span> </span>&#123;</div><div class=\"line\">    isChecked.set(!isChecked.get());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onCheckboxClicked</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Checkbox.updateCheckboxAsync(c);</div><div class=\"line\">    <span class=\"comment\">// Checkbox.updateCheckbox(c); for a sync update</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当你调用State更新方法的时候,你需要记住下面几点:</p>\n<ul>\n<li>当调用一个State更新方法的时候,作为第一个参数的ComponentContext必须总是为更新发生时的生命周期方法中传递进来的那个ComponentContext.这个context包含了现在已知的State的值等重要信息,在布局计算时,这些信息对把旧的Component转换成新的Component非常重要.</li>\n<li>在LayoutSpec中,你应该避免在onCreateLayout中调用State更新方法,除非你完全确定它只会发生很少并且确定的的次数。每一次调用State更新方法都会引起Component树的一次新的布局计算，而计算又会反过来调用它其中所有的Component的onCreateLayout方法，因此，这很容易引起死循环。你应该考虑是否使用懒汉式State更新(下面会说到)才是更加适用于你的情况的方法.</li>\n<li>在MountSpec中,永远也不要在mount和bind方法中调用State更新方法.如果你需要在这类方法中更新State的值,你应该使用下面会讲到的懒汉式State更新来替代.<br><p></p><br><p></p></li>\n</ul>\n<h4 id=\"Key和识别Component\"><a href=\"#Key和识别Component\" class=\"headerlink\" title=\"Key和识别Component\"></a>Key和识别Component</h4><hr>\n<p>Litho框架将会为每一个Component设置一个key值,这个值取决于它的类型和它的父级的key值.你可以使用这个key值来确定在State更新的时候哪一个Component才是我们需要更新的,或者使用这个key值在遍历Component树的时候查找Component.</p>\n<p>具有相同父级的同类型Component将会被设定相同的key值.因此我们需要一种方法来唯一的识别它们.</p>\n<p>此外,当组件的State或者Prop被更新并且Component树重新被创建的时候,会出现一些Component被移除,添加或者在树中重新安排位置的情况.因为Component可能是动态的,因此我们需要一种方法,能在即使Component树改变的情况下还能追踪到应该是哪个Component去进行状态更新.</p>\n<p>Component.Builder类会暴露一个.key()方法,你可以使用它来在创建Component的时候制定一个唯一的key给它,以便将来能够识别它.</p>\n<p>当你在一个父控件下拥有多个相同类型的Component时,或者你期望的布局内容是动态的时候,你就应该设置这个key值.</p>\n<p>一种最常见的你需要手动给你的Component设置key的情况是,你在一个循环中创建和添加子Component:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @State <span class=\"keyword\">boolean</span> isChecked) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">final</span> ComponentLayout.Builder parent = Column.create(c);</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    parent.child(Text.create(c).key(<span class=\"string\">\"key\"</span> +i));</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> parent.build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"懒汉式State更新\"><a href=\"#懒汉式State更新\" class=\"headerlink\" title=\"懒汉式State更新\"></a>懒汉式State更新</h4><hr>\n<p>当你想要更新State的值但是又不想立刻触发一次性的布局计算的时候,你可以使用懒汉式State更新.当你调用懒汉式State更新之后,Component将会保持现有的State值直到下一次布局计算被别的机制(例如收到一个新的prop或者定期的State更新)触发,此时State的值才会被更新.在不需要立刻进行布局计算的情况下,懒汉式State更新对想要更新内部Component信息并且在Component树的重新布局中保持这些信息是非常实用的.</p>\n<p>为了使用懒汉式State更新,你需要在@State注释中把canUpdateLazily参数设置为true.</p>\n<p>如果我们把一个名叫foo的State标记为canUpdateLazily,Litho框架将会自动生成一个静态State更新方法,名叫LazyUpdateFoo,它将带有一个参数,用于设置foo的新值.</p>\n<p>State被标记为canUpdateLazily后依然可以使用常规的State更新.</p>\n<p>让我们看下面的例子:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c,</div><div class=\"line\">    @State(canUpdateLazily = <span class=\"keyword\">true</span>) String foo) &#123;</div><div class=\"line\"></div><div class=\"line\">  FooComponent.lazyUpdateFoo(context, <span class=\"string\">\"updated foo\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">      .child(</div><div class=\"line\">          Text.create(c)</div><div class=\"line\">              .text(foo))</div><div class=\"line\">      .build();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@OnCreateInitialState</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreateInitialState</span><span class=\"params\">(StateValue&lt;String&gt; foo)</span> </span>&#123;</div><div class=\"line\">  foo.set(<span class=\"string\">\"first foo\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一次FooComponent被渲染的时候,即使它的State foo已经被懒汉式更新成另一个值了,它的子Text Component也会显示”first foo”.当一个常规的State更新被触发,或者收到一个新的prop的时候,就会触发布局计算,懒汉式更新将会生效,Text将会被渲染成”update foo”.<br></p><br><p></p><p></p>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><hr>\n<p>由于<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">后台布局</a>机制,State可以在任何时候被多个线程访问.为了确保线程安全,State对象应该是不可变的(即使有极少数情况下不能实现这一点,那么也应该确保State对象是线程安全的).最简单的解决方案是基于原语来表述你的State,因为根据定义,原语就是不可变的.<br></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/state\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"State-状态\"><a href=\"#State-状态\" class=\"headerlink\" title=\"State(状态)\"></a>State(状态)</h3><p></p><br></p></p>\n<p>Litho Component可以包含两种类型的data:</p>\n<ul>\n<li>prop:从父级继承并且在Component的生命周期内不能被改变.</li>\n<li>state:封装实现的细节,由Component管理,并且对父级是透明的.</li>\n</ul>\n<p>一个常见的需要使用State的例子是:渲染一个Checkbox(复选框).Component需要根据选中还是未选中来渲染不同的drawable,但是这是一个Component内部的信息,而他的父级不需要去关心这个状态.</p>\n<p></p><br></p></p>\n<h4 id=\"声明一个Component的状态\"><a href=\"#声明一个Component的状态\" class=\"headerlink\" title=\"声明一个Component的状态\"></a>声明一个Component的状态</h4><hr>\n<p>你可以使用@State注释在spec的生命周期方法中定义一个Component的State,这与你定义Prop的方法是一样的.</p>\n<p>定义State元素在Layout Spec和Mount Spec的生命周期方法中可用:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;\t\t</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @State <span class=\"keyword\">boolean</span> isChecked)</span> </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .child(Image.create(c)</div><div class=\"line\">            .srcRes(isChecked</div><div class=\"line\">                ? R.drawable.is_checked</div><div class=\"line\">                : R.drawable.is_unchecked))</div><div class=\"line\">        .child(Text.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"Submit\"</span>)</div><div class=\"line\">            .clickHandler(Checkbox.onClickedText(c))</div><div class=\"line\">        .build;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onClickedText</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @State <span class=\"keyword\">boolean</span> isChecked)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br></p></p>\n<h4 id=\"初始化State的值\"><a href=\"#初始化State的值\" class=\"headerlink\" title=\"初始化State的值\"></a>初始化State的值</h4><hr>\n<p>为了给State设置一个初始值,你需要在你的Spec中使用@OnCreateInitialState注释来编写一个方法.</p>\n<p>关于编写@OnCreateInitialState方法,你需要知道以下几点:</p>\n<ul>\n<li>第一个参数必须是ComponentContext类型.</li>\n<li>@Prop参数在这里也是可用的.</li>\n<li>剩下的参数的名称必须和其他生命周期方法中的@State参数保持一致,并且这些剩下参数的类型必须为<a href=\"http://fblitho.com/javadoc/com/facebook/litho/StateValue\">StateValue</a>,其中泛型的类型与对应的@State一致.</li>\n<li>@OnCreateInitialState 方法不是必须的.如果你不定义或者没有定义所有state的初始值,那么那些没有被定义初始值的state将会使用java的默认值.</li>\n<li>每一个Component的@OnCreateInitialState方法只会在Component第一次被添加到Component树的时候被调用一次.如果Component的key没有改变,那么后续对Component树布局的重新计算不会重新调用@OnCreateInitialState方法.</li>\n<li>你永远不需要自己调用@OnCreateInitialState方法.</li>\n</ul>\n<p>下面是例子是如何使用父级传下来的值来初始化一个复选框的state值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateInitialState</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">createInitialState</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      StateValue&lt;Boolean&gt; isChecked,</div><div class=\"line\">      @Prop <span class=\"keyword\">boolean</span> initChecked)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    isChecked.set(initChecked);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"定义State的更新\"><a href=\"#定义State的更新\" class=\"headerlink\" title=\"定义State的更新\"></a>定义State的更新</h4><hr>\n<p>你可以使用@OnUpdateState在Spec中声明一个方法来定义Component的State更新的方式.</p>\n<p>你可以根据你想更新的state或者你的state依赖的参数的值来定义任意多的你需要的@OnUpdateState方法.</p>\n<p>每次对@OnUpdateState方法的调用都会触发一次新的对它的Component树的布局计算.为了获得更好的性能,如果在某种情况下会触发对多个State的更新,那么你就应该定义一个@OnUpdateMethod方法来更新所有这些state的值.合并这些更新操作可以减少新的布局计算的次数,从而提升性能.</p>\n<p>关于编写@OnUpdateState方法,你需要知道以下几点:</p>\n<ul>\n<li>代表State的参数名必须和其他方法中使用@State定义的参数名一样,并且类型必须为StateValue,泛型类型也必须和对应的@State参数的类型一致.</li>\n<li>@Param参数也是可以使用的.如果你的State的值需要依赖于Prop,你可以在@OnupdateState函数的参数中使用@Param声明,这样就可以在更新被触发的时候传递prop的值进来了.</li>\n<li>所有其他的参数都必须在其他生命周期方法中有一个对应的@State参数,并且类型必须为StateValue,泛型的类型也必须和@State参数一致.</li>\n</ul>\n<p>下面是如何给checkbox定义一个state方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;\t\t</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnUpdateState</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateCheckboxState</span><span class=\"params\">(StateValue&lt;Boolean&gt; isChecked)</span> </span>&#123;</div><div class=\"line\">    isChecked.set(!isChecked.get());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果你想要合并多个state更新到一个方法中,你只需要把所有这些state都添加到一个@OnUpdateState方法中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnUpdateState</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateMultipleStates</span><span class=\"params\">(</div><div class=\"line\">    StateValue&lt;Boolean&gt; stateOne,</div><div class=\"line\">    StateValue&lt;String&gt; stateTwo,</div><div class=\"line\">    @Param <span class=\"keyword\">int</span> someParam)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> thresholdReached = someParam &gt; <span class=\"number\">100</span>;</div><div class=\"line\">  stateOne.set(thresholdReached);</div><div class=\"line\">  stateTwo.set(thresholdReached ? <span class=\"string\">\"reached\"</span> : <span class=\"string\">\"not reached\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br></p></p>\n<h4 id=\"调用State更新\"><a href=\"#调用State更新\" class=\"headerlink\" title=\"调用State更新\"></a>调用State更新</h4><hr>\n<p>对你的Spec中的每一个@OnUpdateState方法,自动生成的Component中都会包含两个方法,他们在后台都会委托给@OnUpdateState方法处理.</p>\n<ul>\n<li>一个和@OnUpdateState同名的静态方法,它将同步的应用state的更新.</li>\n<li>一个和@OnUpdateState同名并且加上Async后缀的静态方法,它将异步的触发State的更新.这两个方法都使用ComponentContext作为第一个参数,后面的参数与你在@OnUpdateState方法中使用@Param定义的参数相同.</li>\n</ul>\n<p>下面展示了当用户点击的时候如何调用State更新方法来更新你的复选框:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>\t\t</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckboxSpec</span> </span>&#123;\t\t</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @State <span class=\"keyword\">boolean</span> isChecked)</span> </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .child(Image.create(c)</div><div class=\"line\">        .srcRes(isChecked</div><div class=\"line\">            ? R.drawable.is_checked</div><div class=\"line\">            : R.drawable.is_unchecked))</div><div class=\"line\">        .clickHandler(Checkbox.onCheckboxClicked(c)))</div><div class=\"line\">    .build;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnUpdateState</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateCheckbox</span><span class=\"params\">(StateValue&lt;Boolean&gt; isChecked)</span> </span>&#123;</div><div class=\"line\">    isChecked.set(!isChecked.get());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onCheckboxClicked</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Checkbox.updateCheckboxAsync(c);</div><div class=\"line\">    <span class=\"comment\">// Checkbox.updateCheckbox(c); for a sync update</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当你调用State更新方法的时候,你需要记住下面几点:</p>\n<ul>\n<li>当调用一个State更新方法的时候,作为第一个参数的ComponentContext必须总是为更新发生时的生命周期方法中传递进来的那个ComponentContext.这个context包含了现在已知的State的值等重要信息,在布局计算时,这些信息对把旧的Component转换成新的Component非常重要.</li>\n<li>在LayoutSpec中,你应该避免在onCreateLayout中调用State更新方法,除非你完全确定它只会发生很少并且确定的的次数。每一次调用State更新方法都会引起Component树的一次新的布局计算，而计算又会反过来调用它其中所有的Component的onCreateLayout方法，因此，这很容易引起死循环。你应该考虑是否使用懒汉式State更新(下面会说到)才是更加适用于你的情况的方法.</li>\n<li>在MountSpec中,永远也不要在mount和bind方法中调用State更新方法.如果你需要在这类方法中更新State的值,你应该使用下面会讲到的懒汉式State更新来替代.<br></p><br></p></li>\n</ul>\n<h4 id=\"Key和识别Component\"><a href=\"#Key和识别Component\" class=\"headerlink\" title=\"Key和识别Component\"></a>Key和识别Component</h4><hr>\n<p>Litho框架将会为每一个Component设置一个key值,这个值取决于它的类型和它的父级的key值.你可以使用这个key值来确定在State更新的时候哪一个Component才是我们需要更新的,或者使用这个key值在遍历Component树的时候查找Component.</p>\n<p>具有相同父级的同类型Component将会被设定相同的key值.因此我们需要一种方法来唯一的识别它们.</p>\n<p>此外,当组件的State或者Prop被更新并且Component树重新被创建的时候,会出现一些Component被移除,添加或者在树中重新安排位置的情况.因为Component可能是动态的,因此我们需要一种方法,能在即使Component树改变的情况下还能追踪到应该是哪个Component去进行状态更新.</p>\n<p>Component.Builder类会暴露一个.key()方法,你可以使用它来在创建Component的时候制定一个唯一的key给它,以便将来能够识别它.</p>\n<p>当你在一个父控件下拥有多个相同类型的Component时,或者你期望的布局内容是动态的时候,你就应该设置这个key值.</p>\n<p>一种最常见的你需要手动给你的Component设置key的情况是,你在一个循环中创建和添加子Component:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @State <span class=\"keyword\">boolean</span> isChecked)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">final</span> ComponentLayout.Builder parent = Column.create(c);</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    parent.child(Text.create(c).key(<span class=\"string\">\"key\"</span> +i));</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> parent.build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br></p></p>\n<h4 id=\"懒汉式State更新\"><a href=\"#懒汉式State更新\" class=\"headerlink\" title=\"懒汉式State更新\"></a>懒汉式State更新</h4><hr>\n<p>当你想要更新State的值但是又不想立刻触发一次性的布局计算的时候,你可以使用懒汉式State更新.当你调用懒汉式State更新之后,Component将会保持现有的State值直到下一次布局计算被别的机制(例如收到一个新的prop或者定期的State更新)触发,此时State的值才会被更新.在不需要立刻进行布局计算的情况下,懒汉式State更新对想要更新内部Component信息并且在Component树的重新布局中保持这些信息是非常实用的.</p>\n<p>为了使用懒汉式State更新,你需要在@State注释中把canUpdateLazily参数设置为true.</p>\n<p>如果我们把一个名叫foo的State标记为canUpdateLazily,Litho框架将会自动生成一个静态State更新方法,名叫LazyUpdateFoo,它将带有一个参数,用于设置foo的新值.</p>\n<p>State被标记为canUpdateLazily后依然可以使用常规的State更新.</p>\n<p>让我们看下面的例子:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c,</div><div class=\"line\">    @State(canUpdateLazily = <span class=\"keyword\">true</span>)</span> String foo) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  FooComponent.lazyUpdateFoo(context, <span class=\"string\">\"updated foo\"</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">      .child(</div><div class=\"line\">          Text.create(c)</div><div class=\"line\">              .text(foo))</div><div class=\"line\">      .build();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@OnCreateInitialState</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreateInitialState</span><span class=\"params\">(StateValue&lt;String&gt; foo)</span> </span>&#123;</div><div class=\"line\">  foo.set(<span class=\"string\">\"first foo\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一次FooComponent被渲染的时候,即使它的State foo已经被懒汉式更新成另一个值了,它的子Text Component也会显示”first foo”.当一个常规的State更新被触发,或者收到一个新的prop的时候,就会触发布局计算,懒汉式更新将会生效,Text将会被渲染成”update foo”.<br></p><br></p></p>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><hr>\n<p>由于<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">后台布局</a>机制,State可以在任何时候被多个线程访问.为了确保线程安全,State对象应该是不可变的(即使有极少数情况下不能实现这一点,那么也应该确保State对象是线程安全的).最简单的解决方案是基于原语来表述你的State,因为根据定义,原语就是不可变的.<br></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-Layout","date":"2017-05-05T06:30:13.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/layout)\n## 参考\n### Layout(布局)\n\n</p>\n</p>\n\nLitho使用[Yoga](https://facebook.github.io/yoga/),一种[Flexbox](https://www.w3.org/TR/css-flexbox-1/)的实现来测量Component和在屏幕上布局.如果你以前已经在web端使用过Flexbox,那么你使用Litho时将会非常熟悉.如果你更加熟悉Android普通的布局的工作方式,那么Flexbox常常会让你想起LinearLayout.\n\n在Litho中你可以使用一个Row(行)来实现一个类似于水平的LinearLayout的布局.\n``` java\nRow.create(c)\n    .child(...)\n    .child(...)\n    .build();\n```\n\n或者使用一个Column(列)来实现一个类似于竖直LinearLayout的布局.\n``` java\nColumn.create(c)\n    .child(...)\n    .child(...)\n    .build();\n```\n\n为了实现类似于LinearLayout中的weight的效果,Flexbox提供了一个叫做flexGrow(<weight>)的概念.\n``` java\nRow.create(c)\n    .child(\n        SolidColor.create(c)\n            .color(RED)\n            .withLayout()\n            .flexGrow(1))\n    .child(\n        SolidColor.create(c)\n            .color(BLUE)\n            .withLayout()\n            .flexGrow(1))\n    .build();\n```\n如果你比较喜欢FrameLayout中把一个view放置到其他view的上方的效果,Flexbox中可以使用positionType(ABSOLUTE)来实现.\n``` java\nRow.create(c)\n    .child(\n        SolidColor.create(c)\n            .color(RED)\n            .withLayout()\n            .flexGrow(1))\n    .child(\n        SolidColor.create(c)\n            .color(BLUE)\n            .withLayout()\n            .flexGrow(1))\n    .build();\n```\n\n如果需要查看更多关于Flexbox特性的文档,你可以查阅[Yoga文档](https://facebook.github.io/yoga/docs/getting-started/)或者其他任何讲述Flexbox如何工作的网络资源.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-05-Facebook出品的Android声明式开源新框架Litho文档翻译-Layout.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-Layout\ndate: 2017-05-05 14:30:13\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/layout)\n## 参考\n### Layout(布局)\n\n</p>\n</p>\n\nLitho使用[Yoga](https://facebook.github.io/yoga/),一种[Flexbox](https://www.w3.org/TR/css-flexbox-1/)的实现来测量Component和在屏幕上布局.如果你以前已经在web端使用过Flexbox,那么你使用Litho时将会非常熟悉.如果你更加熟悉Android普通的布局的工作方式,那么Flexbox常常会让你想起LinearLayout.\n\n在Litho中你可以使用一个Row(行)来实现一个类似于水平的LinearLayout的布局.\n``` java\nRow.create(c)\n    .child(...)\n    .child(...)\n    .build();\n```\n\n或者使用一个Column(列)来实现一个类似于竖直LinearLayout的布局.\n``` java\nColumn.create(c)\n    .child(...)\n    .child(...)\n    .build();\n```\n\n为了实现类似于LinearLayout中的weight的效果,Flexbox提供了一个叫做flexGrow(<weight>)的概念.\n``` java\nRow.create(c)\n    .child(\n        SolidColor.create(c)\n            .color(RED)\n            .withLayout()\n            .flexGrow(1))\n    .child(\n        SolidColor.create(c)\n            .color(BLUE)\n            .withLayout()\n            .flexGrow(1))\n    .build();\n```\n如果你比较喜欢FrameLayout中把一个view放置到其他view的上方的效果,Flexbox中可以使用positionType(ABSOLUTE)来实现.\n``` java\nRow.create(c)\n    .child(\n        SolidColor.create(c)\n            .color(RED)\n            .withLayout()\n            .flexGrow(1))\n    .child(\n        SolidColor.create(c)\n            .color(BLUE)\n            .withLayout()\n            .flexGrow(1))\n    .build();\n```\n\n如果需要查看更多关于Flexbox特性的文档,你可以查阅[Yoga文档](https://facebook.github.io/yoga/docs/getting-started/)或者其他任何讲述Flexbox如何工作的网络资源.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-Layout","published":1,"updated":"2017-05-11T09:26:19.504Z","_id":"cj2k76hr0001mssrlvykj30xf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/layout\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Layout-布局\"><a href=\"#Layout-布局\" class=\"headerlink\" title=\"Layout(布局)\"></a>Layout(布局)</h3><p></p><br><p></p><p></p>\n<p>Litho使用<a href=\"https://facebook.github.io/yoga/\" target=\"_blank\" rel=\"external\">Yoga</a>,一种<a href=\"https://www.w3.org/TR/css-flexbox-1/\" target=\"_blank\" rel=\"external\">Flexbox</a>的实现来测量Component和在屏幕上布局.如果你以前已经在web端使用过Flexbox,那么你使用Litho时将会非常熟悉.如果你更加熟悉Android普通的布局的工作方式,那么Flexbox常常会让你想起LinearLayout.</p>\n<p>在Litho中你可以使用一个Row(行)来实现一个类似于水平的LinearLayout的布局.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Row.create(c)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>或者使用一个Column(列)来实现一个类似于竖直LinearLayout的布局.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Column.create(c)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>为了实现类似于LinearLayout中的weight的效果,Flexbox提供了一个叫做flexGrow(<weight>)的概念.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Row.create(c)</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(RED)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(BLUE)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></weight></p>\n<p>如果你比较喜欢FrameLayout中把一个view放置到其他view的上方的效果,Flexbox中可以使用positionType(ABSOLUTE)来实现.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Row.create(c)</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(RED)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(BLUE)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>如果需要查看更多关于Flexbox特性的文档,你可以查阅<a href=\"https://facebook.github.io/yoga/docs/getting-started/\" target=\"_blank\" rel=\"external\">Yoga文档</a>或者其他任何讲述Flexbox如何工作的网络资源.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/layout\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Layout-布局\"><a href=\"#Layout-布局\" class=\"headerlink\" title=\"Layout(布局)\"></a>Layout(布局)</h3><p></p><br></p></p>\n<p>Litho使用<a href=\"https://facebook.github.io/yoga/\">Yoga</a>,一种<a href=\"https://www.w3.org/TR/css-flexbox-1/\">Flexbox</a>的实现来测量Component和在屏幕上布局.如果你以前已经在web端使用过Flexbox,那么你使用Litho时将会非常熟悉.如果你更加熟悉Android普通的布局的工作方式,那么Flexbox常常会让你想起LinearLayout.</p>\n<p>在Litho中你可以使用一个Row(行)来实现一个类似于水平的LinearLayout的布局.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Row.create(c)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>或者使用一个Column(列)来实现一个类似于竖直LinearLayout的布局.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Column.create(c)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>为了实现类似于LinearLayout中的weight的效果,Flexbox提供了一个叫做flexGrow(<weight>)的概念.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Row.create(c)</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(RED)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(BLUE)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>如果你比较喜欢FrameLayout中把一个view放置到其他view的上方的效果,Flexbox中可以使用positionType(ABSOLUTE)来实现.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Row.create(c)</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(RED)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .child(</div><div class=\"line\">        SolidColor.create(c)</div><div class=\"line\">            .color(BLUE)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .flexGrow(<span class=\"number\">1</span>))</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>如果需要查看更多关于Flexbox特性的文档,你可以查阅<a href=\"https://facebook.github.io/yoga/docs/getting-started/\">Yoga文档</a>或者其他任何讲述Flexbox如何工作的网络资源.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-总览和导航","date":"2017-05-04T02:59:55.000Z","_content":"\n欢迎转载,转载请标明出处.\n\n今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.它的特点是可以在后台线程中计算布局结构,并且支持资源回收再利用.使用Recycler的思想,自己重新写了一套UI布局框架,可以大大的改进现有的RecyclerView的渲染效率.\n果然是facebook,听起来很牛逼啊,在网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.\n\n英文原文文档地址: [Litho-doc](http://fblitho.com/)\ngithub地址: [Litho-Github](https://github.com/facebook/litho)\n\n# Litho 官方文档翻译\n\n### 介绍Litho\n--- \n##### [Litho是什么?](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Litho%E6%98%AF%E4%BB%80%E4%B9%88/)\n##### [编写动机](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99%E5%8A%A8%E6%9C%BA%20/)\n##### [使用](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/)\n\n\n### 快速开始\n---\n##### [准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)\n##### [教程](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/)\n##### [编写Component](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/)\n##### [使用Component](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)\n\n### 参考\n--- \n##### [Layout Specs](https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-LayoutSpecs/)\n##### [Mount Specs](https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-MountSpecs/)\n##### [Props](https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/)\n##### [State](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/)\n##### [Layout](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Layout/)\n##### [Recycler](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Recycler/)\n\n### 处理事件\n--- \n##### [概述](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/)\n##### [触摸事件处理](https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/)\n##### [可见新的处理](https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86/)\n\n### 兼容性\n---\n##### [Style](https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Styles/)\n##### [无障碍环境](https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%8E%AF%E5%A2%83/)\n##### [RTL](https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-RTL/)\n\n### 测试\n---\n##### [单元测试](https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)\n\n### 进阶指引\n--- \n##### [自定义布局](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/)\n##### [TreeProp](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-TreeProp/)\n##### [增量式挂载](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%89%8B%E5%8A%A8%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)\n##### [创建ComponentTree](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAComponentTree/)\n\n### 架构\n---\n##### [代码生成器](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/)\n##### [异步布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)\n##### [增量式挂载](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)\n##### [View的扁平化](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/)\n##### [回收机制](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n\n### 最佳实践\n---\n##### [最佳实践](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/)\n\n### 工具\n---\n##### [调试](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%B0%83%E8%AF%95/)\n##### [开发者选项](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9/)\n\n### 参与\n---\n##### [如何参与](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E/)\n##### [仓库架构](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%93%E5%BA%93%E6%9E%B6%E6%9E%84/)","source":"_posts/2017-05-04-Facebook出品的Android声明式开源新框架Litho文档翻译-总览和导航.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-总览和导航\ndate: 2017-05-04 10:59:55\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n\n今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.它的特点是可以在后台线程中计算布局结构,并且支持资源回收再利用.使用Recycler的思想,自己重新写了一套UI布局框架,可以大大的改进现有的RecyclerView的渲染效率.\n果然是facebook,听起来很牛逼啊,在网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.\n\n英文原文文档地址: [Litho-doc](http://fblitho.com/)\ngithub地址: [Litho-Github](https://github.com/facebook/litho)\n\n# Litho 官方文档翻译\n\n### 介绍Litho\n--- \n##### [Litho是什么?](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Litho%E6%98%AF%E4%BB%80%E4%B9%88/)\n##### [编写动机](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99%E5%8A%A8%E6%9C%BA%20/)\n##### [使用](https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/)\n\n\n### 快速开始\n---\n##### [准备工作](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/)\n##### [教程](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/)\n##### [编写Component](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/)\n##### [使用Component](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)\n\n### 参考\n--- \n##### [Layout Specs](https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-LayoutSpecs/)\n##### [Mount Specs](https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-MountSpecs/)\n##### [Props](https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/)\n##### [State](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/)\n##### [Layout](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Layout/)\n##### [Recycler](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Recycler/)\n\n### 处理事件\n--- \n##### [概述](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/)\n##### [触摸事件处理](https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/)\n##### [可见新的处理](https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86/)\n\n### 兼容性\n---\n##### [Style](https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Styles/)\n##### [无障碍环境](https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%8E%AF%E5%A2%83/)\n##### [RTL](https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-RTL/)\n\n### 测试\n---\n##### [单元测试](https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)\n\n### 进阶指引\n--- \n##### [自定义布局](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/)\n##### [TreeProp](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-TreeProp/)\n##### [增量式挂载](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%89%8B%E5%8A%A8%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)\n##### [创建ComponentTree](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAComponentTree/)\n\n### 架构\n---\n##### [代码生成器](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/)\n##### [异步布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/)\n##### [增量式挂载](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)\n##### [View的扁平化](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/)\n##### [回收机制](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n\n### 最佳实践\n---\n##### [最佳实践](https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/)\n\n### 工具\n---\n##### [调试](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%B0%83%E8%AF%95/)\n##### [开发者选项](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9/)\n\n### 参与\n---\n##### [如何参与](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E/)\n##### [仓库架构](https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%93%E5%BA%93%E6%9E%B6%E6%9E%84/)","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-总览和导航","published":1,"updated":"2017-05-11T09:39:29.990Z","_id":"cj2k76hr2001pssrl06uxzfcy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.</p>\n<p>今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.它的特点是可以在后台线程中计算布局结构,并且支持资源回收再利用.使用Recycler的思想,自己重新写了一套UI布局框架,可以大大的改进现有的RecyclerView的渲染效率.<br>果然是facebook,听起来很牛逼啊,在网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.</p>\n<p>英文原文文档地址: <a href=\"http://fblitho.com/\" target=\"_blank\" rel=\"external\">Litho-doc</a><br>github地址: <a href=\"https://github.com/facebook/litho\" target=\"_blank\" rel=\"external\">Litho-Github</a></p>\n<h1 id=\"Litho-官方文档翻译\"><a href=\"#Litho-官方文档翻译\" class=\"headerlink\" title=\"Litho 官方文档翻译\"></a>Litho 官方文档翻译</h1><h3 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h3><hr>\n<h5 id=\"Litho是什么\"><a href=\"#Litho是什么\" class=\"headerlink\" title=\"Litho是什么?\"></a><a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Litho%E6%98%AF%E4%BB%80%E4%B9%88/\">Litho是什么?</a></h5><h5 id=\"编写动机\"><a href=\"#编写动机\" class=\"headerlink\" title=\"编写动机\"></a><a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99%E5%8A%A8%E6%9C%BA%20/\">编写动机</a></h5><h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/\">使用</a></h5><h3 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h3><hr>\n<h5 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a></h5><h5 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/\">教程</a></h5><h5 id=\"编写Component\"><a href=\"#编写Component\" class=\"headerlink\" title=\"编写Component\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/\">编写Component</a></h5><h5 id=\"使用Component\"><a href=\"#使用Component\" class=\"headerlink\" title=\"使用Component\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用Component</a></h5><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><hr>\n<h5 id=\"Layout-Specs\"><a href=\"#Layout-Specs\" class=\"headerlink\" title=\"Layout Specs\"></a><a href=\"https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-LayoutSpecs/\">Layout Specs</a></h5><h5 id=\"Mount-Specs\"><a href=\"#Mount-Specs\" class=\"headerlink\" title=\"Mount Specs\"></a><a href=\"https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-MountSpecs/\">Mount Specs</a></h5><h5 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a><a href=\"https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/\">Props</a></h5><h5 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/\">State</a></h5><h5 id=\"Layout\"><a href=\"#Layout\" class=\"headerlink\" title=\"Layout\"></a><a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Layout/\">Layout</a></h5><h5 id=\"Recycler\"><a href=\"#Recycler\" class=\"headerlink\" title=\"Recycler\"></a><a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Recycler/\">Recycler</a></h5><h3 id=\"处理事件\"><a href=\"#处理事件\" class=\"headerlink\" title=\"处理事件\"></a>处理事件</h3><hr>\n<h5 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/\">概述</a></h5><h5 id=\"触摸事件处理\"><a href=\"#触摸事件处理\" class=\"headerlink\" title=\"触摸事件处理\"></a><a href=\"https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/\">触摸事件处理</a></h5><h5 id=\"可见新的处理\"><a href=\"#可见新的处理\" class=\"headerlink\" title=\"可见新的处理\"></a><a href=\"https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86/\">可见新的处理</a></h5><h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><hr>\n<h5 id=\"Style\"><a href=\"#Style\" class=\"headerlink\" title=\"Style\"></a><a href=\"https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Styles/\">Style</a></h5><h5 id=\"无障碍环境\"><a href=\"#无障碍环境\" class=\"headerlink\" title=\"无障碍环境\"></a><a href=\"https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%8E%AF%E5%A2%83/\">无障碍环境</a></h5><h5 id=\"RTL\"><a href=\"#RTL\" class=\"headerlink\" title=\"RTL\"></a><a href=\"https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-RTL/\">RTL</a></h5><h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><hr>\n<h5 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a><a href=\"https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/\">单元测试</a></h5><h3 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h3><hr>\n<h5 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/\">自定义布局</a></h5><h5 id=\"TreeProp\"><a href=\"#TreeProp\" class=\"headerlink\" title=\"TreeProp\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-TreeProp/\">TreeProp</a></h5><h5 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%89%8B%E5%8A%A8%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载</a></h5><h5 id=\"创建ComponentTree\"><a href=\"#创建ComponentTree\" class=\"headerlink\" title=\"创建ComponentTree\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAComponentTree/\">创建ComponentTree</a></h5><h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><hr>\n<h5 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/\">代码生成器</a></h5><h5 id=\"异步布局\"><a href=\"#异步布局\" class=\"headerlink\" title=\"异步布局\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">异步布局</a></h5><h5 id=\"增量式挂载-1\"><a href=\"#增量式挂载-1\" class=\"headerlink\" title=\"增量式挂载\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载</a></h5><h5 id=\"View的扁平化\"><a href=\"#View的扁平化\" class=\"headerlink\" title=\"View的扁平化\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/\">View的扁平化</a></h5><h5 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/\">回收机制</a></h5><h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><hr>\n<h5 id=\"最佳实践-1\"><a href=\"#最佳实践-1\" class=\"headerlink\" title=\"最佳实践\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/\">最佳实践</a></h5><h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><hr>\n<h5 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%B0%83%E8%AF%95/\">调试</a></h5><h5 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9/\">开发者选项</a></h5><h3 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h3><hr>\n<h5 id=\"如何参与\"><a href=\"#如何参与\" class=\"headerlink\" title=\"如何参与\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E/\">如何参与</a></h5><h5 id=\"仓库架构\"><a href=\"#仓库架构\" class=\"headerlink\" title=\"仓库架构\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%93%E5%BA%93%E6%9E%B6%E6%9E%84/\">仓库架构</a></h5>","excerpt":"","more":"<p>欢迎转载,转载请标明出处.</p>\n<p>今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.它的特点是可以在后台线程中计算布局结构,并且支持资源回收再利用.使用Recycler的思想,自己重新写了一套UI布局框架,可以大大的改进现有的RecyclerView的渲染效率.<br>果然是facebook,听起来很牛逼啊,在网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.</p>\n<p>英文原文文档地址: <a href=\"http://fblitho.com/\">Litho-doc</a><br>github地址: <a href=\"https://github.com/facebook/litho\">Litho-Github</a></p>\n<h1 id=\"Litho-官方文档翻译\"><a href=\"#Litho-官方文档翻译\" class=\"headerlink\" title=\"Litho 官方文档翻译\"></a>Litho 官方文档翻译</h1><h3 id=\"介绍Litho\"><a href=\"#介绍Litho\" class=\"headerlink\" title=\"介绍Litho\"></a>介绍Litho</h3><hr>\n<h5 id=\"Litho是什么\"><a href=\"#Litho是什么\" class=\"headerlink\" title=\"Litho是什么?\"></a><a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Litho%E6%98%AF%E4%BB%80%E4%B9%88/\">Litho是什么?</a></h5><h5 id=\"编写动机\"><a href=\"#编写动机\" class=\"headerlink\" title=\"编写动机\"></a><a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99%E5%8A%A8%E6%9C%BA%20/\">编写动机</a></h5><h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"https://shikieiki.github.io/2017/04/25/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8/\">使用</a></h5><h3 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h3><hr>\n<h5 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/\">准备工作</a></h5><h5 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%99%E7%A8%8B/\">教程</a></h5><h5 id=\"编写Component\"><a href=\"#编写Component\" class=\"headerlink\" title=\"编写Component\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E7%BC%96%E5%86%99Component/\">编写Component</a></h5><h5 id=\"使用Component\"><a href=\"#使用Component\" class=\"headerlink\" title=\"使用Component\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用Component</a></h5><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><hr>\n<h5 id=\"Layout-Specs\"><a href=\"#Layout-Specs\" class=\"headerlink\" title=\"Layout Specs\"></a><a href=\"https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-LayoutSpecs/\">Layout Specs</a></h5><h5 id=\"Mount-Specs\"><a href=\"#Mount-Specs\" class=\"headerlink\" title=\"Mount Specs\"></a><a href=\"https://shikieiki.github.io/2017/04/28/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-MountSpecs/\">Mount Specs</a></h5><h5 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a><a href=\"https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/\">Props</a></h5><h5 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/\">State</a></h5><h5 id=\"Layout\"><a href=\"#Layout\" class=\"headerlink\" title=\"Layout\"></a><a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Layout/\">Layout</a></h5><h5 id=\"Recycler\"><a href=\"#Recycler\" class=\"headerlink\" title=\"Recycler\"></a><a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Recycler/\">Recycler</a></h5><h3 id=\"处理事件\"><a href=\"#处理事件\" class=\"headerlink\" title=\"处理事件\"></a>处理事件</h3><hr>\n<h5 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/\">概述</a></h5><h5 id=\"触摸事件处理\"><a href=\"#触摸事件处理\" class=\"headerlink\" title=\"触摸事件处理\"></a><a href=\"https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/\">触摸事件处理</a></h5><h5 id=\"可见新的处理\"><a href=\"#可见新的处理\" class=\"headerlink\" title=\"可见新的处理\"></a><a href=\"https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86/\">可见新的处理</a></h5><h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><hr>\n<h5 id=\"Style\"><a href=\"#Style\" class=\"headerlink\" title=\"Style\"></a><a href=\"https://shikieiki.github.io/2017/05/08/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Styles/\">Style</a></h5><h5 id=\"无障碍环境\"><a href=\"#无障碍环境\" class=\"headerlink\" title=\"无障碍环境\"></a><a href=\"https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%97%A0%E9%9A%9C%E7%A2%8D%E7%8E%AF%E5%A2%83/\">无障碍环境</a></h5><h5 id=\"RTL\"><a href=\"#RTL\" class=\"headerlink\" title=\"RTL\"></a><a href=\"https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-RTL/\">RTL</a></h5><h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><hr>\n<h5 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a><a href=\"https://shikieiki.github.io/2017/05/09/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/\">单元测试</a></h5><h3 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h3><hr>\n<h5 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/\">自定义布局</a></h5><h5 id=\"TreeProp\"><a href=\"#TreeProp\" class=\"headerlink\" title=\"TreeProp\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-TreeProp/\">TreeProp</a></h5><h5 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%89%8B%E5%8A%A8%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载</a></h5><h5 id=\"创建ComponentTree\"><a href=\"#创建ComponentTree\" class=\"headerlink\" title=\"创建ComponentTree\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAComponentTree/\">创建ComponentTree</a></h5><h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><hr>\n<h5 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/\">代码生成器</a></h5><h5 id=\"异步布局\"><a href=\"#异步布局\" class=\"headerlink\" title=\"异步布局\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">异步布局</a></h5><h5 id=\"增量式挂载-1\"><a href=\"#增量式挂载-1\" class=\"headerlink\" title=\"增量式挂载\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载</a></h5><h5 id=\"View的扁平化\"><a href=\"#View的扁平化\" class=\"headerlink\" title=\"View的扁平化\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-View%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96/\">View的扁平化</a></h5><h5 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a><a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/\">回收机制</a></h5><h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><hr>\n<h5 id=\"最佳实践-1\"><a href=\"#最佳实践-1\" class=\"headerlink\" title=\"最佳实践\"></a><a href=\"https://shikieiki.github.io/2017/05/10/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/\">最佳实践</a></h5><h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><hr>\n<h5 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%B0%83%E8%AF%95/\">调试</a></h5><h5 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%80%E5%8F%91%E8%80%85%E9%80%89%E9%A1%B9/\">开发者选项</a></h5><h3 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h3><hr>\n<h5 id=\"如何参与\"><a href=\"#如何参与\" class=\"headerlink\" title=\"如何参与\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E/\">如何参与</a></h5><h5 id=\"仓库架构\"><a href=\"#仓库架构\" class=\"headerlink\" title=\"仓库架构\"></a><a href=\"https://shikieiki.github.io/2017/05/11/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BB%93%E5%BA%93%E6%9E%B6%E6%9E%84/\">仓库架构</a></h5>"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-Recycler","date":"2017-05-05T06:45:20.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/recycler-component)\n## 参考\n### Recycler\n\n</p>\n</p>\n\n[RecyclerView](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html)是一个Android系统中构建一个可滚动列表所需的基本的构建快.而[Recycler](http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler) component提供了与RecyclerView非常相似的功能,同时实现了例如后台布局和增量式挂载这样的功能.\n\n</p>\n</p>\n\n#### 创建一个Recycler Component\n---\n你可以像使用其他任何Litho框架中的Component一样——先构建,再把它添加到你的布局中——这样来使用Recycler。\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    final ComponentContext c,\n    @Prop RecyclerBinder recyclerBinder) {\n    \n  return Recycler.create(c)\n      .binder(recyclerBinder)\n      .buildWithLayout();\n}\n```\n\n以上的代码渲染了一个Recycler Component,它将显示recyclerBinder中的内容.\n\n</p>\n</p>\n\n#### RecyclerBinder\n---\n[RecyclerBinder](http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder)是使用Component操作列表式UI的切入点.它保存了列表中包含的所有Item，并且当用户滚动列表时，它会计算将会在屏幕中显示的item的布局。\n\nRecyclerBinder作为Litho的一部分:\n- 作用类似于RecyclerView的Adapter\n- 定义在RecyclerView中使用的布局(如Linear或Grid等)\n- 会提前在后台线程中处理负责的布局计算.\n\n![](/image/20170505150546.gif)\n\n让我们开始创建一个RecyclerBinder:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(c);\n```\n\n这样会创建一个最简单的RecyclerBinder,它会把Recycler中的内容以竖直列表的方式展现.\n\n如果想要让Recycler使用GridLayout(表格布局),我们可以改用这个构造函数:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(c, new GridLayoutInfo(c, spanCount));\n```\nRecyclerBinder暴露了一系列API来操作将在Recycler中显示的item.\n\n最常使用的有:\n``` java\nrecyclerBinder.insertItemAt(position, component);\nrecyclerBinder.updateItemAt(position, component);\nrecyclerBinder.removeItemAt(position);\nrecyclerBinder.moveItem(fromPosition, toPosition);\n```\n\nRecyclerBinder的API中直接使用到Component,因为一个Component仅仅是一系列Prop的集合,我们可以提前建立任何的Component然后把布局管理工作交给RecyclerBinder.\n\nRecyclerBinder也支持接收规定Component该如何布局的额外的信息.这些额外的信息可以通过一个ComponentInfo传递.代码如下所示:\n``` java\nrecyclerBinder.insertItemAt(\n  position,\n  ComponentInfo.create()\n      .component(component)\n      .isSticky(true)\n      .build());\n```\n\n</p>\n</p>\n\n#### 使用RecyclerBinder与DiffUtil协同工作\n---\nRecyclerBinder提供了与[DiffUtil](https://developer.android.com/reference/android/support/v7/util/DiffUtil.html)协同工作的方式.Litho定义了[RecyclerBinderUpdateCallback](http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinderUpdateCallback.html)这个API,它实现了ListUpdateCallback,因此可以用来发送DiffResult到RecyclerBinder.\n\n下面是一个如何使用Litho与DiffUtil协同工作的例子:\n``` java\nprivate final ComponentRenderer<Data> mComponentRenderer = new ComponentRenderer<> {\n    ComponentInfo render(Data data, int idx) {\n      return ComponentInfo.create()\n          .component(\n          \tDataComponent.create(mComponentContext)\n          \t    .data(data))\n          \t    .build();\n    }\n  }\n\n  public void onNewData(List<Data> newData) {\n    final DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new MyDataDiffCallback(mCurrentData, newData));\n    final RecyclerBinderUpdateCallback callback = RecyclerBinderUpdateCallback.acquire(\n      mCurrentData.size(),\n      newData,\n      mComponentRenderer,\n      mRecyclerBinder)\n\n    diffResult.dispatchUpdatesTo(callback);\n    callback.applyChangeset();\n    RecyclerBinderUpdateCallback.release(callback);\n}\n```\n每当列表中需要创建新的Component或者列表的模型需要被更新的时候,ComponentRenderer都会被调用.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n\n\n\n\n","source":"_posts/2017-05-05-Facebook出品的Android声明式开源新框架Litho文档翻译-Recycler.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-Recycler\ndate: 2017-05-05 14:45:20\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/recycler-component)\n## 参考\n### Recycler\n\n</p>\n</p>\n\n[RecyclerView](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html)是一个Android系统中构建一个可滚动列表所需的基本的构建快.而[Recycler](http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler) component提供了与RecyclerView非常相似的功能,同时实现了例如后台布局和增量式挂载这样的功能.\n\n</p>\n</p>\n\n#### 创建一个Recycler Component\n---\n你可以像使用其他任何Litho框架中的Component一样——先构建,再把它添加到你的布局中——这样来使用Recycler。\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    final ComponentContext c,\n    @Prop RecyclerBinder recyclerBinder) {\n    \n  return Recycler.create(c)\n      .binder(recyclerBinder)\n      .buildWithLayout();\n}\n```\n\n以上的代码渲染了一个Recycler Component,它将显示recyclerBinder中的内容.\n\n</p>\n</p>\n\n#### RecyclerBinder\n---\n[RecyclerBinder](http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder)是使用Component操作列表式UI的切入点.它保存了列表中包含的所有Item，并且当用户滚动列表时，它会计算将会在屏幕中显示的item的布局。\n\nRecyclerBinder作为Litho的一部分:\n- 作用类似于RecyclerView的Adapter\n- 定义在RecyclerView中使用的布局(如Linear或Grid等)\n- 会提前在后台线程中处理负责的布局计算.\n\n![](/image/20170505150546.gif)\n\n让我们开始创建一个RecyclerBinder:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(c);\n```\n\n这样会创建一个最简单的RecyclerBinder,它会把Recycler中的内容以竖直列表的方式展现.\n\n如果想要让Recycler使用GridLayout(表格布局),我们可以改用这个构造函数:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(c, new GridLayoutInfo(c, spanCount));\n```\nRecyclerBinder暴露了一系列API来操作将在Recycler中显示的item.\n\n最常使用的有:\n``` java\nrecyclerBinder.insertItemAt(position, component);\nrecyclerBinder.updateItemAt(position, component);\nrecyclerBinder.removeItemAt(position);\nrecyclerBinder.moveItem(fromPosition, toPosition);\n```\n\nRecyclerBinder的API中直接使用到Component,因为一个Component仅仅是一系列Prop的集合,我们可以提前建立任何的Component然后把布局管理工作交给RecyclerBinder.\n\nRecyclerBinder也支持接收规定Component该如何布局的额外的信息.这些额外的信息可以通过一个ComponentInfo传递.代码如下所示:\n``` java\nrecyclerBinder.insertItemAt(\n  position,\n  ComponentInfo.create()\n      .component(component)\n      .isSticky(true)\n      .build());\n```\n\n</p>\n</p>\n\n#### 使用RecyclerBinder与DiffUtil协同工作\n---\nRecyclerBinder提供了与[DiffUtil](https://developer.android.com/reference/android/support/v7/util/DiffUtil.html)协同工作的方式.Litho定义了[RecyclerBinderUpdateCallback](http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinderUpdateCallback.html)这个API,它实现了ListUpdateCallback,因此可以用来发送DiffResult到RecyclerBinder.\n\n下面是一个如何使用Litho与DiffUtil协同工作的例子:\n``` java\nprivate final ComponentRenderer<Data> mComponentRenderer = new ComponentRenderer<> {\n    ComponentInfo render(Data data, int idx) {\n      return ComponentInfo.create()\n          .component(\n          \tDataComponent.create(mComponentContext)\n          \t    .data(data))\n          \t    .build();\n    }\n  }\n\n  public void onNewData(List<Data> newData) {\n    final DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new MyDataDiffCallback(mCurrentData, newData));\n    final RecyclerBinderUpdateCallback callback = RecyclerBinderUpdateCallback.acquire(\n      mCurrentData.size(),\n      newData,\n      mComponentRenderer,\n      mRecyclerBinder)\n\n    diffResult.dispatchUpdatesTo(callback);\n    callback.applyChangeset();\n    RecyclerBinderUpdateCallback.release(callback);\n}\n```\n每当列表中需要创建新的Component或者列表的模型需要被更新的时候,ComponentRenderer都会被调用.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n\n\n\n\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-Recycler","published":1,"updated":"2017-05-11T09:26:40.013Z","_id":"cj2k76hr3001tssrlcb0539s8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/recycler-component\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Recycler\"><a href=\"#Recycler\" class=\"headerlink\" title=\"Recycler\"></a>Recycler</h3><p></p><br><p></p><p></p>\n<p><a href=\"https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html\" target=\"_blank\" rel=\"external\">RecyclerView</a>是一个Android系统中构建一个可滚动列表所需的基本的构建快.而<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler\" target=\"_blank\" rel=\"external\">Recycler</a> component提供了与RecyclerView非常相似的功能,同时实现了例如后台布局和增量式挂载这样的功能.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"创建一个Recycler-Component\"><a href=\"#创建一个Recycler-Component\" class=\"headerlink\" title=\"创建一个Recycler Component\"></a>创建一个Recycler Component</h4><hr>\n<p>你可以像使用其他任何Litho框架中的Component一样——先构建,再把它添加到你的布局中——这样来使用Recycler。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c,</div><div class=\"line\">    @Prop RecyclerBinder recyclerBinder) &#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> Recycler.create(c)</div><div class=\"line\">      .binder(recyclerBinder)</div><div class=\"line\">      .buildWithLayout();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上的代码渲染了一个Recycler Component,它将显示recyclerBinder中的内容.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"RecyclerBinder\"><a href=\"#RecyclerBinder\" class=\"headerlink\" title=\"RecyclerBinder\"></a>RecyclerBinder</h4><hr>\n<p><a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder\" target=\"_blank\" rel=\"external\">RecyclerBinder</a>是使用Component操作列表式UI的切入点.它保存了列表中包含的所有Item，并且当用户滚动列表时，它会计算将会在屏幕中显示的item的布局。</p>\n<p>RecyclerBinder作为Litho的一部分:</p>\n<ul>\n<li>作用类似于RecyclerView的Adapter</li>\n<li>定义在RecyclerView中使用的布局(如Linear或Grid等)</li>\n<li>会提前在后台线程中处理负责的布局计算.</li>\n</ul>\n<p><img src=\"/image/20170505150546.gif\" alt=\"\"></p>\n<p>让我们开始创建一个RecyclerBinder:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(c);</div></pre></td></tr></table></figure></p>\n<p>这样会创建一个最简单的RecyclerBinder,它会把Recycler中的内容以竖直列表的方式展现.</p>\n<p>如果想要让Recycler使用GridLayout(表格布局),我们可以改用这个构造函数:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(c, <span class=\"keyword\">new</span> GridLayoutInfo(c, spanCount));</div></pre></td></tr></table></figure></p>\n<p>RecyclerBinder暴露了一系列API来操作将在Recycler中显示的item.</p>\n<p>最常使用的有:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerBinder.insertItemAt(position, component);</div><div class=\"line\">recyclerBinder.updateItemAt(position, component);</div><div class=\"line\">recyclerBinder.removeItemAt(position);</div><div class=\"line\">recyclerBinder.moveItem(fromPosition, toPosition);</div></pre></td></tr></table></figure></p>\n<p>RecyclerBinder的API中直接使用到Component,因为一个Component仅仅是一系列Prop的集合,我们可以提前建立任何的Component然后把布局管理工作交给RecyclerBinder.</p>\n<p>RecyclerBinder也支持接收规定Component该如何布局的额外的信息.这些额外的信息可以通过一个ComponentInfo传递.代码如下所示:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerBinder.insertItemAt(</div><div class=\"line\">  position,</div><div class=\"line\">  ComponentInfo.create()</div><div class=\"line\">      .component(component)</div><div class=\"line\">      .isSticky(<span class=\"keyword\">true</span>)</div><div class=\"line\">      .build());</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><p></p>\n<h4 id=\"使用RecyclerBinder与DiffUtil协同工作\"><a href=\"#使用RecyclerBinder与DiffUtil协同工作\" class=\"headerlink\" title=\"使用RecyclerBinder与DiffUtil协同工作\"></a>使用RecyclerBinder与DiffUtil协同工作</h4><hr>\n<p>RecyclerBinder提供了与<a href=\"https://developer.android.com/reference/android/support/v7/util/DiffUtil.html\" target=\"_blank\" rel=\"external\">DiffUtil</a>协同工作的方式.Litho定义了<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinderUpdateCallback.html\" target=\"_blank\" rel=\"external\">RecyclerBinderUpdateCallback</a>这个API,它实现了ListUpdateCallback,因此可以用来发送DiffResult到RecyclerBinder.</p>\n<p>下面是一个如何使用Litho与DiffUtil协同工作的例子:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ComponentRenderer&lt;Data&gt; mComponentRenderer = <span class=\"keyword\">new</span> ComponentRenderer&lt;&gt; &#123;</div><div class=\"line\">    <span class=\"function\">ComponentInfo <span class=\"title\">render</span><span class=\"params\">(Data data, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> ComponentInfo.create()</div><div class=\"line\">          .component(</div><div class=\"line\">          \tDataComponent.create(mComponentContext)</div><div class=\"line\">          \t    .data(data))</div><div class=\"line\">          \t    .build();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewData</span><span class=\"params\">(List&lt;Data&gt; newData)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class=\"keyword\">new</span> MyDataDiffCallback(mCurrentData, newData));</div><div class=\"line\">    <span class=\"keyword\">final</span> RecyclerBinderUpdateCallback callback = RecyclerBinderUpdateCallback.acquire(</div><div class=\"line\">      mCurrentData.size(),</div><div class=\"line\">      newData,</div><div class=\"line\">      mComponentRenderer,</div><div class=\"line\">      mRecyclerBinder)</div><div class=\"line\"></div><div class=\"line\">    diffResult.dispatchUpdatesTo(callback);</div><div class=\"line\">    callback.applyChangeset();</div><div class=\"line\">    RecyclerBinderUpdateCallback.release(callback);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每当列表中需要创建新的Component或者列表的模型需要被更新的时候,ComponentRenderer都会被调用.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/recycler-component\">Litho-doc</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h3 id=\"Recycler\"><a href=\"#Recycler\" class=\"headerlink\" title=\"Recycler\"></a>Recycler</h3><p></p><br></p></p>\n<p><a href=\"https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html\">RecyclerView</a>是一个Android系统中构建一个可滚动列表所需的基本的构建快.而<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler\">Recycler</a> component提供了与RecyclerView非常相似的功能,同时实现了例如后台布局和增量式挂载这样的功能.</p>\n<p></p><br></p></p>\n<h4 id=\"创建一个Recycler-Component\"><a href=\"#创建一个Recycler-Component\" class=\"headerlink\" title=\"创建一个Recycler Component\"></a>创建一个Recycler Component</h4><hr>\n<p>你可以像使用其他任何Litho框架中的Component一样——先构建,再把它添加到你的布局中——这样来使用Recycler。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c,</div><div class=\"line\">    @Prop RecyclerBinder recyclerBinder)</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> Recycler.create(c)</div><div class=\"line\">      .binder(recyclerBinder)</div><div class=\"line\">      .buildWithLayout();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上的代码渲染了一个Recycler Component,它将显示recyclerBinder中的内容.</p>\n<p></p><br></p></p>\n<h4 id=\"RecyclerBinder\"><a href=\"#RecyclerBinder\" class=\"headerlink\" title=\"RecyclerBinder\"></a>RecyclerBinder</h4><hr>\n<p><a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinder\">RecyclerBinder</a>是使用Component操作列表式UI的切入点.它保存了列表中包含的所有Item，并且当用户滚动列表时，它会计算将会在屏幕中显示的item的布局。</p>\n<p>RecyclerBinder作为Litho的一部分:</p>\n<ul>\n<li>作用类似于RecyclerView的Adapter</li>\n<li>定义在RecyclerView中使用的布局(如Linear或Grid等)</li>\n<li>会提前在后台线程中处理负责的布局计算.</li>\n</ul>\n<p><img src=\"/image/20170505150546.gif\" alt=\"\"></p>\n<p>让我们开始创建一个RecyclerBinder:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(c);</div></pre></td></tr></table></figure></p>\n<p>这样会创建一个最简单的RecyclerBinder,它会把Recycler中的内容以竖直列表的方式展现.</p>\n<p>如果想要让Recycler使用GridLayout(表格布局),我们可以改用这个构造函数:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(c, <span class=\"keyword\">new</span> GridLayoutInfo(c, spanCount));</div></pre></td></tr></table></figure></p>\n<p>RecyclerBinder暴露了一系列API来操作将在Recycler中显示的item.</p>\n<p>最常使用的有:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerBinder.insertItemAt(position, component);</div><div class=\"line\">recyclerBinder.updateItemAt(position, component);</div><div class=\"line\">recyclerBinder.removeItemAt(position);</div><div class=\"line\">recyclerBinder.moveItem(fromPosition, toPosition);</div></pre></td></tr></table></figure></p>\n<p>RecyclerBinder的API中直接使用到Component,因为一个Component仅仅是一系列Prop的集合,我们可以提前建立任何的Component然后把布局管理工作交给RecyclerBinder.</p>\n<p>RecyclerBinder也支持接收规定Component该如何布局的额外的信息.这些额外的信息可以通过一个ComponentInfo传递.代码如下所示:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerBinder.insertItemAt(</div><div class=\"line\">  position,</div><div class=\"line\">  ComponentInfo.create()</div><div class=\"line\">      .component(component)</div><div class=\"line\">      .isSticky(<span class=\"keyword\">true</span>)</div><div class=\"line\">      .build());</div></pre></td></tr></table></figure></p>\n<p></p><br></p></p>\n<h4 id=\"使用RecyclerBinder与DiffUtil协同工作\"><a href=\"#使用RecyclerBinder与DiffUtil协同工作\" class=\"headerlink\" title=\"使用RecyclerBinder与DiffUtil协同工作\"></a>使用RecyclerBinder与DiffUtil协同工作</h4><hr>\n<p>RecyclerBinder提供了与<a href=\"https://developer.android.com/reference/android/support/v7/util/DiffUtil.html\">DiffUtil</a>协同工作的方式.Litho定义了<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/RecyclerBinderUpdateCallback.html\">RecyclerBinderUpdateCallback</a>这个API,它实现了ListUpdateCallback,因此可以用来发送DiffResult到RecyclerBinder.</p>\n<p>下面是一个如何使用Litho与DiffUtil协同工作的例子:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ComponentRenderer&lt;Data&gt; mComponentRenderer = <span class=\"keyword\">new</span> ComponentRenderer&lt;&gt; &#123;</div><div class=\"line\">    <span class=\"function\">ComponentInfo <span class=\"title\">render</span><span class=\"params\">(Data data, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> ComponentInfo.create()</div><div class=\"line\">          .component(</div><div class=\"line\">          \tDataComponent.create(mComponentContext)</div><div class=\"line\">          \t    .data(data))</div><div class=\"line\">          \t    .build();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewData</span><span class=\"params\">(List&lt;Data&gt; newData)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class=\"keyword\">new</span> MyDataDiffCallback(mCurrentData, newData));</div><div class=\"line\">    <span class=\"keyword\">final</span> RecyclerBinderUpdateCallback callback = RecyclerBinderUpdateCallback.acquire(</div><div class=\"line\">      mCurrentData.size(),</div><div class=\"line\">      newData,</div><div class=\"line\">      mComponentRenderer,</div><div class=\"line\">      mRecyclerBinder)</div><div class=\"line\"></div><div class=\"line\">    diffResult.dispatchUpdatesTo(callback);</div><div class=\"line\">    callback.applyChangeset();</div><div class=\"line\">    RecyclerBinderUpdateCallback.release(callback);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每当列表中需要创建新的Component或者列表的模型需要被更新的时候,ComponentRenderer都会被调用.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-事件处理概述","date":"2017-05-05T08:14:50.000Z","_content":"\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/events-overview)\n## 事件处理\n### 概述\n\n</p>\n</p>\n\n框架提供了一套多用途的API用来在事件发生的时候与Component通信.事件被声明成一个POJO并且使用@Event注释.为了方便,我们命名事件类时使用Event作为后缀.事件的类不一定必须是LayoutSpec或者MountSpec的内部类.这是因为从设计上看,Spec一般被认为是私有的概念,而事件却可以允许被多个Component使用.\n``` java\n@Event\npublic class ColorChangedEvent {\n  public int color;\n}\n```\n在这个例子中我们假设我们有一个Component名叫ColorComponent.为了指明一个ColorComponent可以分发ColorChangedEvent事件,我们的ColorComponentSpec必须在注释中注明这一点.注明的方式是使用@MountSpec或者@LayoutSpec注释中的events参数.一个Component的注释可以分派多个事件.\n\n``` java\n@LayoutSpec(events = { ColorChangedEvent.class })\nclass ColorComponentSpec {\n  ...\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      Context c,\n      @Prop EventHandler colorChangedHandler,\n      @FromPrepare int color) {\n    ...\n    ColorComponent.dispatchColorChangedEvent(\n        colorChangedHandler,\n        color);\n    ...\n  }\n}\n```\n\n对一个FooEvent类型的事件,将会自动生成一个对应的dispatchFooEvent方法和一个供事件回调使用的事件标识符.\n\ndispatchFooEvent方法使用一个[EventHandler](http://fblitho.com/javadoc/com/facebook/litho/EventHandler)作为第一个参数,它后面紧跟着的参数是你在@Event类中定义的参数的列表.我们规定为每一个你的Component暴露出的事件使用一个EventHandler prop.\n\n在上面的例子中,ColorComponent使用一个colorChangedHandler作为prop,并且使用自动生成的dispatchColorChangedEvent()方法把ColorChangedEvent分发给它.\n\n</p>\n</p>\n#### 回调\n---\n为了处理其他Component分发过来的事件,你需要一个EventHandler实例和一个匹配的回调.\n\n你可以使用自动生成的Component中的相对应的eventHandler factory方法来创建EventHandler实例.这个方法的名称将会和你的事件回调方法的名称相同.\n\n你可以使用@OnEvent注释定义事件回调.@OnEvent将接受一个参数:事件类.这个方法的第一个参数必须是一个ComponentContext,框架将会为你填充它.\n\n举例来说,下面是一个Component如何为上面声明的ColorChangedEvent定义一个handler.\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext c,\n      @Prop String someColor) {\n\n    return Column.create(c)\n        ...\n        .child(\n            ColorComponent.create(c)\n                .color(someColor)\n                .colorChangedHandler(MyComponent.onColorChanged(c))\n        ...\n        .build();\n\n  }\n\n  @OnEvent(ColorChangedEvent.class)\n  static void onColorChanged(\n      ComponentContext c,\n      @FromEvent int color,\n      @Prop String someProp) {\n    Log.d(\"MyComponent\", \"Color changed: \" + color);\n  }\n}\n```\n对一个或者多个回调方法的参数使用@Param注释,你可以定义动态的事件参数.如果你想要定义一个确定类型的事件的回调(例如onAvatarClicked()),但是你也想知道哪一个头像被点击了,使用@Param注释会变得非常实用.这个情况中的avatar参数将会被传递到eventHandler factory方法中.\n\n正如你所见,@OnEvent回调可以访问所有的Component的prop,就像其他的Spec方法一样.\n``` java\n@LayoutSpec\nclass FacePileComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext c,\n      @Prop Uri[] faces) {\n    ComponentLayout.Builder builder = Column.create(c);\n    for (Uri face : avatarUrls) {\n      builder.child(\n          FrescoImage.create(c)\n              .uri(face)\n              .withLayout()\n              .clickHandler(FacePileComponent.onFaceClicked(c, face));\n    }\n    \n    return builder.build();\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onFaceClicked(\n      ComponentContext c,\n      @Param Uri face) {\n    Log.d(\"FacePileComponent\", \"Face clicked: \" + face);\n  }\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-05-Facebook出品的Android声明式开源新框架Litho文档翻译-事件处理概述.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-事件处理概述\ndate: 2017-05-05 16:14:50\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/events-overview)\n## 事件处理\n### 概述\n\n</p>\n</p>\n\n框架提供了一套多用途的API用来在事件发生的时候与Component通信.事件被声明成一个POJO并且使用@Event注释.为了方便,我们命名事件类时使用Event作为后缀.事件的类不一定必须是LayoutSpec或者MountSpec的内部类.这是因为从设计上看,Spec一般被认为是私有的概念,而事件却可以允许被多个Component使用.\n``` java\n@Event\npublic class ColorChangedEvent {\n  public int color;\n}\n```\n在这个例子中我们假设我们有一个Component名叫ColorComponent.为了指明一个ColorComponent可以分发ColorChangedEvent事件,我们的ColorComponentSpec必须在注释中注明这一点.注明的方式是使用@MountSpec或者@LayoutSpec注释中的events参数.一个Component的注释可以分派多个事件.\n\n``` java\n@LayoutSpec(events = { ColorChangedEvent.class })\nclass ColorComponentSpec {\n  ...\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      Context c,\n      @Prop EventHandler colorChangedHandler,\n      @FromPrepare int color) {\n    ...\n    ColorComponent.dispatchColorChangedEvent(\n        colorChangedHandler,\n        color);\n    ...\n  }\n}\n```\n\n对一个FooEvent类型的事件,将会自动生成一个对应的dispatchFooEvent方法和一个供事件回调使用的事件标识符.\n\ndispatchFooEvent方法使用一个[EventHandler](http://fblitho.com/javadoc/com/facebook/litho/EventHandler)作为第一个参数,它后面紧跟着的参数是你在@Event类中定义的参数的列表.我们规定为每一个你的Component暴露出的事件使用一个EventHandler prop.\n\n在上面的例子中,ColorComponent使用一个colorChangedHandler作为prop,并且使用自动生成的dispatchColorChangedEvent()方法把ColorChangedEvent分发给它.\n\n</p>\n</p>\n#### 回调\n---\n为了处理其他Component分发过来的事件,你需要一个EventHandler实例和一个匹配的回调.\n\n你可以使用自动生成的Component中的相对应的eventHandler factory方法来创建EventHandler实例.这个方法的名称将会和你的事件回调方法的名称相同.\n\n你可以使用@OnEvent注释定义事件回调.@OnEvent将接受一个参数:事件类.这个方法的第一个参数必须是一个ComponentContext,框架将会为你填充它.\n\n举例来说,下面是一个Component如何为上面声明的ColorChangedEvent定义一个handler.\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext c,\n      @Prop String someColor) {\n\n    return Column.create(c)\n        ...\n        .child(\n            ColorComponent.create(c)\n                .color(someColor)\n                .colorChangedHandler(MyComponent.onColorChanged(c))\n        ...\n        .build();\n\n  }\n\n  @OnEvent(ColorChangedEvent.class)\n  static void onColorChanged(\n      ComponentContext c,\n      @FromEvent int color,\n      @Prop String someProp) {\n    Log.d(\"MyComponent\", \"Color changed: \" + color);\n  }\n}\n```\n对一个或者多个回调方法的参数使用@Param注释,你可以定义动态的事件参数.如果你想要定义一个确定类型的事件的回调(例如onAvatarClicked()),但是你也想知道哪一个头像被点击了,使用@Param注释会变得非常实用.这个情况中的avatar参数将会被传递到eventHandler factory方法中.\n\n正如你所见,@OnEvent回调可以访问所有的Component的prop,就像其他的Spec方法一样.\n``` java\n@LayoutSpec\nclass FacePileComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      LayoutContext c,\n      @Prop Uri[] faces) {\n    ComponentLayout.Builder builder = Column.create(c);\n    for (Uri face : avatarUrls) {\n      builder.child(\n          FrescoImage.create(c)\n              .uri(face)\n              .withLayout()\n              .clickHandler(FacePileComponent.onFaceClicked(c, face));\n    }\n    \n    return builder.build();\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onFaceClicked(\n      ComponentContext c,\n      @Param Uri face) {\n    Log.d(\"FacePileComponent\", \"Face clicked: \" + face);\n  }\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-事件处理概述","published":1,"updated":"2017-05-11T09:27:07.793Z","_id":"cj2k76hr4001wssrlju6gknxb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/events-overview\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p></p><br><p></p><p></p>\n<p>框架提供了一套多用途的API用来在事件发生的时候与Component通信.事件被声明成一个POJO并且使用@Event注释.为了方便,我们命名事件类时使用Event作为后缀.事件的类不一定必须是LayoutSpec或者MountSpec的内部类.这是因为从设计上看,Spec一般被认为是私有的概念,而事件却可以允许被多个Component使用.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Event</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorChangedEvent</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这个例子中我们假设我们有一个Component名叫ColorComponent.为了指明一个ColorComponent可以分发ColorChangedEvent事件,我们的ColorComponentSpec必须在注释中注明这一点.注明的方式是使用@MountSpec或者@LayoutSpec注释中的events参数.一个Component的注释可以分派多个事件.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>(events = &#123; ColorChangedEvent.class &#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      Context c,</div><div class=\"line\">      @Prop EventHandler colorChangedHandler,</div><div class=\"line\">      @FromPrepare <span class=\"keyword\">int</span> color) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ColorComponent.dispatchColorChangedEvent(</div><div class=\"line\">        colorChangedHandler,</div><div class=\"line\">        color);</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对一个FooEvent类型的事件,将会自动生成一个对应的dispatchFooEvent方法和一个供事件回调使用的事件标识符.</p>\n<p>dispatchFooEvent方法使用一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/EventHandler\" target=\"_blank\" rel=\"external\">EventHandler</a>作为第一个参数,它后面紧跟着的参数是你在@Event类中定义的参数的列表.我们规定为每一个你的Component暴露出的事件使用一个EventHandler prop.</p>\n<p>在上面的例子中,ColorComponent使用一个colorChangedHandler作为prop,并且使用自动生成的dispatchColorChangedEvent()方法把ColorChangedEvent分发给它.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h4><hr>\n<p>为了处理其他Component分发过来的事件,你需要一个EventHandler实例和一个匹配的回调.</p>\n<p>你可以使用自动生成的Component中的相对应的eventHandler factory方法来创建EventHandler实例.这个方法的名称将会和你的事件回调方法的名称相同.</p>\n<p>你可以使用@OnEvent注释定义事件回调.@OnEvent将接受一个参数:事件类.这个方法的第一个参数必须是一个ComponentContext,框架将会为你填充它.</p>\n<p>举例来说,下面是一个Component如何为上面声明的ColorChangedEvent定义一个handler.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      LayoutContext c,</div><div class=\"line\">      @Prop String someColor) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        ...</div><div class=\"line\">        .child(</div><div class=\"line\">            ColorComponent.create(c)</div><div class=\"line\">                .color(someColor)</div><div class=\"line\">                .colorChangedHandler(MyComponent.onColorChanged(c))</div><div class=\"line\">        ...</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ColorChangedEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onColorChanged</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @FromEvent <span class=\"keyword\">int</span> color,</div><div class=\"line\">      @Prop String someProp) &#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"MyComponent\"</span>, <span class=\"string\">\"Color changed: \"</span> + color);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对一个或者多个回调方法的参数使用@Param注释,你可以定义动态的事件参数.如果你想要定义一个确定类型的事件的回调(例如onAvatarClicked()),但是你也想知道哪一个头像被点击了,使用@Param注释会变得非常实用.这个情况中的avatar参数将会被传递到eventHandler factory方法中.</p>\n<p>正如你所见,@OnEvent回调可以访问所有的Component的prop,就像其他的Spec方法一样.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FacePileComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      LayoutContext c,</div><div class=\"line\">      @Prop Uri[] faces) &#123;</div><div class=\"line\">    ComponentLayout.Builder builder = Column.create(c);</div><div class=\"line\">    <span class=\"keyword\">for</span> (Uri face : avatarUrls) &#123;</div><div class=\"line\">      builder.child(</div><div class=\"line\">          FrescoImage.create(c)</div><div class=\"line\">              .uri(face)</div><div class=\"line\">              .withLayout()</div><div class=\"line\">              .clickHandler(FacePileComponent.onFaceClicked(c, face));</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> builder.build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onFaceClicked</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Param Uri face) &#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"FacePileComponent\"</span>, <span class=\"string\">\"Face clicked: \"</span> + face);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/events-overview\">Litho-doc</a></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p></p><br></p></p>\n<p>框架提供了一套多用途的API用来在事件发生的时候与Component通信.事件被声明成一个POJO并且使用@Event注释.为了方便,我们命名事件类时使用Event作为后缀.事件的类不一定必须是LayoutSpec或者MountSpec的内部类.这是因为从设计上看,Spec一般被认为是私有的概念,而事件却可以允许被多个Component使用.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Event</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorChangedEvent</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这个例子中我们假设我们有一个Component名叫ColorComponent.为了指明一个ColorComponent可以分发ColorChangedEvent事件,我们的ColorComponentSpec必须在注释中注明这一点.注明的方式是使用@MountSpec或者@LayoutSpec注释中的events参数.一个Component的注释可以分派多个事件.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span>(events = &#123; ColorChangedEvent.class &#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      Context c,</div><div class=\"line\">      @Prop EventHandler colorChangedHandler,</div><div class=\"line\">      @FromPrepare <span class=\"keyword\">int</span> color)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ColorComponent.dispatchColorChangedEvent(</div><div class=\"line\">        colorChangedHandler,</div><div class=\"line\">        color);</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对一个FooEvent类型的事件,将会自动生成一个对应的dispatchFooEvent方法和一个供事件回调使用的事件标识符.</p>\n<p>dispatchFooEvent方法使用一个<a href=\"http://fblitho.com/javadoc/com/facebook/litho/EventHandler\">EventHandler</a>作为第一个参数,它后面紧跟着的参数是你在@Event类中定义的参数的列表.我们规定为每一个你的Component暴露出的事件使用一个EventHandler prop.</p>\n<p>在上面的例子中,ColorComponent使用一个colorChangedHandler作为prop,并且使用自动生成的dispatchColorChangedEvent()方法把ColorChangedEvent分发给它.</p>\n<p></p><br></p></p>\n<h4 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h4><hr>\n<p>为了处理其他Component分发过来的事件,你需要一个EventHandler实例和一个匹配的回调.</p>\n<p>你可以使用自动生成的Component中的相对应的eventHandler factory方法来创建EventHandler实例.这个方法的名称将会和你的事件回调方法的名称相同.</p>\n<p>你可以使用@OnEvent注释定义事件回调.@OnEvent将接受一个参数:事件类.这个方法的第一个参数必须是一个ComponentContext,框架将会为你填充它.</p>\n<p>举例来说,下面是一个Component如何为上面声明的ColorChangedEvent定义一个handler.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      LayoutContext c,</div><div class=\"line\">      @Prop String someColor)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        ...</div><div class=\"line\">        .child(</div><div class=\"line\">            ColorComponent.create(c)</div><div class=\"line\">                .color(someColor)</div><div class=\"line\">                .colorChangedHandler(MyComponent.onColorChanged(c))</div><div class=\"line\">        ...</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ColorChangedEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onColorChanged</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @FromEvent <span class=\"keyword\">int</span> color,</div><div class=\"line\">      @Prop String someProp)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"MyComponent\"</span>, <span class=\"string\">\"Color changed: \"</span> + color);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对一个或者多个回调方法的参数使用@Param注释,你可以定义动态的事件参数.如果你想要定义一个确定类型的事件的回调(例如onAvatarClicked()),但是你也想知道哪一个头像被点击了,使用@Param注释会变得非常实用.这个情况中的avatar参数将会被传递到eventHandler factory方法中.</p>\n<p>正如你所见,@OnEvent回调可以访问所有的Component的prop,就像其他的Spec方法一样.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FacePileComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      LayoutContext c,</div><div class=\"line\">      @Prop Uri[] faces)</span> </span>&#123;</div><div class=\"line\">    ComponentLayout.Builder builder = Column.create(c);</div><div class=\"line\">    <span class=\"keyword\">for</span> (Uri face : avatarUrls) &#123;</div><div class=\"line\">      builder.child(</div><div class=\"line\">          FrescoImage.create(c)</div><div class=\"line\">              .uri(face)</div><div class=\"line\">              .withLayout()</div><div class=\"line\">              .clickHandler(FacePileComponent.onFaceClicked(c, face));</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> builder.build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onFaceClicked</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Param Uri face)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"FacePileComponent\"</span>, <span class=\"string\">\"Face clicked: \"</span> + face);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-Styles","date":"2017-05-08T09:36:02.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/styles)\n## 兼容性\n### Styles\n\n</p>\n</p>\n\nComponent可以像Android View的属性集的构建器一样,使用Android的style资源来构建它的prop.它让开发者能够直接使用style资源来定义静态的prop值或者prop的默认值.\n\n可以通过在你的Component的Spec中实现@OnLoadStyle方法来支持Style.它的第一个参数是ComponentContext,你可以用它来检索生成一个包含stype资源的TypedArray.其他的参数需要是Output类型,并且名称与类型都与你想要设置的prop相同.\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String prop1,\n      @Prop int prop2) {\n\n    return ...;\n  }\n}\n```\n举个例子,为了对上面的MyComponent的两个prop实现style的支持,你先要按照惯例定义样式属性:\n\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n\n  <attr name=\"prop1\" format=\"string\" />\n  <attr name=\"prop2\" format=\"integer\" />\n\n  <declare-styleable name=\"MyComponent\">\n    <attr name=\"prop1\" />\n    <attr name=\"prop2\" />\n  </declare-styleable>\n\n</resources>\n```\n\n接着你可以在你的@OnLoadStyle方法中收集这些属性的值:\n``` java\n@OnLoadStyle\nvoid onLoadStyle(\n    ComponentContext c,\n    Output<String> prop1,\n    Output<Integer> prop2) {\n\n  final DataBoundTypedArray a =\n      c.obtainDataBoundAttributes(R.styleable.Text, 0);\n\n  for (int i = 0, size = a.getIndexCount(); i < size; i++) {\n    final int attr = a.getIndex(i);\n\n    if (attr == R.styleable.MyComponent_prop1) {\n      prop1.set(a.getString(attr));\n    } else if (attr == R.styleable.MyComponent_prop2) {\n      prop2.set(a.getInteger(attr));\n    }\n  }\n\n  a.recycle();\n}\n```\n\n这样,你就可以在style中定义prop1和prop2的值了:\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <style name=\"SomeStyle\">\n        <item name=\"prop1\">@string/some_string</item>\n    </style>\n</resources>\n```\n\n并且在MyComponent中使用它:\n``` java\nMyComponent.create(c, 0, R.style.SomeStyle)\n    .prop2(10)\n    .build();\n```\n\n这样,prop1就能够从@string/some_string资源中获取值了.\n\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-08-Facebook出品的Android声明式开源新框架Litho文档翻译-Styles.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-Styles\ndate: 2017-05-08 17:36:02\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/styles)\n## 兼容性\n### Styles\n\n</p>\n</p>\n\nComponent可以像Android View的属性集的构建器一样,使用Android的style资源来构建它的prop.它让开发者能够直接使用style资源来定义静态的prop值或者prop的默认值.\n\n可以通过在你的Component的Spec中实现@OnLoadStyle方法来支持Style.它的第一个参数是ComponentContext,你可以用它来检索生成一个包含stype资源的TypedArray.其他的参数需要是Output类型,并且名称与类型都与你想要设置的prop相同.\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String prop1,\n      @Prop int prop2) {\n\n    return ...;\n  }\n}\n```\n举个例子,为了对上面的MyComponent的两个prop实现style的支持,你先要按照惯例定义样式属性:\n\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n\n  <attr name=\"prop1\" format=\"string\" />\n  <attr name=\"prop2\" format=\"integer\" />\n\n  <declare-styleable name=\"MyComponent\">\n    <attr name=\"prop1\" />\n    <attr name=\"prop2\" />\n  </declare-styleable>\n\n</resources>\n```\n\n接着你可以在你的@OnLoadStyle方法中收集这些属性的值:\n``` java\n@OnLoadStyle\nvoid onLoadStyle(\n    ComponentContext c,\n    Output<String> prop1,\n    Output<Integer> prop2) {\n\n  final DataBoundTypedArray a =\n      c.obtainDataBoundAttributes(R.styleable.Text, 0);\n\n  for (int i = 0, size = a.getIndexCount(); i < size; i++) {\n    final int attr = a.getIndex(i);\n\n    if (attr == R.styleable.MyComponent_prop1) {\n      prop1.set(a.getString(attr));\n    } else if (attr == R.styleable.MyComponent_prop2) {\n      prop2.set(a.getInteger(attr));\n    }\n  }\n\n  a.recycle();\n}\n```\n\n这样,你就可以在style中定义prop1和prop2的值了:\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <style name=\"SomeStyle\">\n        <item name=\"prop1\">@string/some_string</item>\n    </style>\n</resources>\n```\n\n并且在MyComponent中使用它:\n``` java\nMyComponent.create(c, 0, R.style.SomeStyle)\n    .prop2(10)\n    .build();\n```\n\n这样,prop1就能够从@string/some_string资源中获取值了.\n\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-Styles","published":1,"updated":"2017-05-11T09:29:17.092Z","_id":"cj2k76hr60020ssrlfdhnp3hu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/styles\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><h3 id=\"Styles\"><a href=\"#Styles\" class=\"headerlink\" title=\"Styles\"></a>Styles</h3><p></p><br><p></p><p></p>\n<p>Component可以像Android View的属性集的构建器一样,使用Android的style资源来构建它的prop.它让开发者能够直接使用style资源来定义静态的prop值或者prop的默认值.</p>\n<p>可以通过在你的Component的Spec中实现@OnLoadStyle方法来支持Style.它的第一个参数是ComponentContext,你可以用它来检索生成一个包含stype资源的TypedArray.其他的参数需要是Output类型,并且名称与类型都与你想要设置的prop相同.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String prop1,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> prop2) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ...;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>举个例子,为了对上面的MyComponent的两个prop实现style的支持,你先要按照惯例定义样式属性:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;attr name=\"prop1\" format=\"string\" /&gt;</div><div class=\"line\">  &lt;attr name=\"prop2\" format=\"integer\" /&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;declare-styleable name=\"MyComponent\"&gt;</div><div class=\"line\">    &lt;attr name=\"prop1\" /&gt;</div><div class=\"line\">    &lt;attr name=\"prop2\" /&gt;</div><div class=\"line\">  &lt;/declare-styleable&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n<p>接着你可以在你的@OnLoadStyle方法中收集这些属性的值:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnLoadStyle</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onLoadStyle</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    Output&lt;String&gt; prop1,</div><div class=\"line\">    Output&lt;Integer&gt; prop2) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">final</span> DataBoundTypedArray a =</div><div class=\"line\">      c.obtainDataBoundAttributes(R.styleable.Text, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = a.getIndexCount(); i &lt; size; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> attr = a.getIndex(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (attr == R.styleable.MyComponent_prop1) &#123;</div><div class=\"line\">      prop1.set(a.getString(attr));</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (attr == R.styleable.MyComponent_prop2) &#123;</div><div class=\"line\">      prop2.set(a.getInteger(attr));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  a.recycle();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样,你就可以在style中定义prop1和prop2的值了:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;style name=\"SomeStyle\"&gt;</div><div class=\"line\">        &lt;item name=\"prop1\"&gt;@string/some_string&lt;/item&gt;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>\n<p>并且在MyComponent中使用它:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyComponent.create(c, <span class=\"number\">0</span>, R.style.SomeStyle)</div><div class=\"line\">    .prop2(<span class=\"number\">10</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>这样,prop1就能够从@string/some_string资源中获取值了.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/styles\">Litho-doc</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><h3 id=\"Styles\"><a href=\"#Styles\" class=\"headerlink\" title=\"Styles\"></a>Styles</h3><p></p><br></p></p>\n<p>Component可以像Android View的属性集的构建器一样,使用Android的style资源来构建它的prop.它让开发者能够直接使用style资源来定义静态的prop值或者prop的默认值.</p>\n<p>可以通过在你的Component的Spec中实现@OnLoadStyle方法来支持Style.它的第一个参数是ComponentContext,你可以用它来检索生成一个包含stype资源的TypedArray.其他的参数需要是Output类型,并且名称与类型都与你想要设置的prop相同.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String prop1,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> prop2)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ...;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>举个例子,为了对上面的MyComponent的两个prop实现style的支持,你先要按照惯例定义样式属性:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;attr name=\"prop1\" format=\"string\" /&gt;</div><div class=\"line\">  &lt;attr name=\"prop2\" format=\"integer\" /&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;declare-styleable name=\"MyComponent\"&gt;</div><div class=\"line\">    &lt;attr name=\"prop1\" /&gt;</div><div class=\"line\">    &lt;attr name=\"prop2\" /&gt;</div><div class=\"line\">  &lt;/declare-styleable&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure>\n<p>接着你可以在你的@OnLoadStyle方法中收集这些属性的值:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnLoadStyle</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onLoadStyle</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    Output&lt;String&gt; prop1,</div><div class=\"line\">    Output&lt;Integer&gt; prop2)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">final</span> DataBoundTypedArray a =</div><div class=\"line\">      c.obtainDataBoundAttributes(R.styleable.Text, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = a.getIndexCount(); i &lt; size; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> attr = a.getIndex(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (attr == R.styleable.MyComponent_prop1) &#123;</div><div class=\"line\">      prop1.set(a.getString(attr));</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (attr == R.styleable.MyComponent_prop2) &#123;</div><div class=\"line\">      prop2.set(a.getInteger(attr));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  a.recycle();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样,你就可以在style中定义prop1和prop2的值了:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\">&lt;resources&gt;</div><div class=\"line\">    &lt;style name=\"SomeStyle\"&gt;</div><div class=\"line\">        &lt;item name=\"prop1\"&gt;@string/some_string&lt;/item&gt;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>\n<p>并且在MyComponent中使用它:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyComponent.create(c, <span class=\"number\">0</span>, R.style.SomeStyle)</div><div class=\"line\">    .prop2(<span class=\"number\">10</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>这样,prop1就能够从@string/some_string资源中获取值了.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-可见性的处理","date":"2017-05-08T08:33:22.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/visibility-handling)\n## 事件处理\n### 可见性的处理\n\n</p>\n</p>\n\n#### 可见范围的类型\n---\n\n框架现在支持4中类型过的可见性事件:\n- [可见事件](http://fblitho.com/javadoc/com/facebook/litho/VisibleEvent):这种事件会在Component至少有1像素是可见的时候被触发.\n- [不可见事件](http://fblitho.com/javadoc/com/facebook/litho/InvisibleEvent):这种事件会在Component不再有任何像素是可见的时候被触发.\n- [聚焦可见事件](http://fblitho.com/javadoc/com/facebook/litho/FocusedVisibleEvent):这种事件会在Component至少占据视窗一半的的时候被触发,如果Component的大小小于视窗的一半,则会在Component完全可见的时候被触发.\n- [完全展示可见事件](http://fblitho.com/javadoc/com/facebook/litho/FullImpressionVisibleEvent):当整个Component在某个时间点通过视窗时，会触发此事件。\n\n</p>\n</p>\n\n#### 使用\n---\n\n可见性范围需要相关的Component支持[增量式挂载]()\n\n为一个Component注册可见性事件handler,你可以按照注册其他事件handler相同的[步骤](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/)来操作.\n\n下面是示例:\n\n``` java\n@LayoutSpec\nclass MyLayoutSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(ComponentContext c) {\n  \n    return Column.create(c)\n        .alignItems(Align.STRETCH)\n        .child(Text.create(c)\n            .text(\"This is MY layout spec\")\n            .withLayout()\n            .visibleHandler(MyLayoutSpec.onTitleVisible(c))\n            .invisibleHandler(MyLayoutSpec.onTitleInvisible(c)))\n        .focusedHandler(MyLayoutSpec.onComponentFocused(c, \"someStringParam\"))\n        .fullImpressionHandler(MyLayoutSpec.onComponentFullImpression(c)))\n        .build();\n  }\n\n  @OnEvent(VisibleEvent.class)\n  static void onTitleVisible(ComponentContext c) {\n    Log.d(\"VisibilityRanges\", \"The title entered the Visible Range\");\n  }\n\n  @OnEvent(InvisibleEvent.class)\n  static void onTitleInvisible(ComponentContext c) {\n    Log.d(\"VisibilityRanges\", \"The title is no longer visible\");\n  }\n\n  @OnEvent(FocusedVisibleEvent.class)\n  static void onComponentFocused(\n      ComponentContext c,\n      @Param String stringParam) {\n    Log.d(\n      \"VisibilityRanges\",\n      \"The component is focused with param: \" + contentString);\n  }\n\n  @OnEvent(FullImpressionVisibleEvent.class)\n  static void onComponentFullImpression(ComponentContext c) {\n    Log.d(\"VisibilityRanges\", \"The component has logged a full impression\");\n  }\n};\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-08-Facebook出品的Android声明式开源新框架Litho文档翻译-可见性的处理.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-可见性的处理\ndate: 2017-05-08 16:33:22\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/visibility-handling)\n## 事件处理\n### 可见性的处理\n\n</p>\n</p>\n\n#### 可见范围的类型\n---\n\n框架现在支持4中类型过的可见性事件:\n- [可见事件](http://fblitho.com/javadoc/com/facebook/litho/VisibleEvent):这种事件会在Component至少有1像素是可见的时候被触发.\n- [不可见事件](http://fblitho.com/javadoc/com/facebook/litho/InvisibleEvent):这种事件会在Component不再有任何像素是可见的时候被触发.\n- [聚焦可见事件](http://fblitho.com/javadoc/com/facebook/litho/FocusedVisibleEvent):这种事件会在Component至少占据视窗一半的的时候被触发,如果Component的大小小于视窗的一半,则会在Component完全可见的时候被触发.\n- [完全展示可见事件](http://fblitho.com/javadoc/com/facebook/litho/FullImpressionVisibleEvent):当整个Component在某个时间点通过视窗时，会触发此事件。\n\n</p>\n</p>\n\n#### 使用\n---\n\n可见性范围需要相关的Component支持[增量式挂载]()\n\n为一个Component注册可见性事件handler,你可以按照注册其他事件handler相同的[步骤](https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/)来操作.\n\n下面是示例:\n\n``` java\n@LayoutSpec\nclass MyLayoutSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(ComponentContext c) {\n  \n    return Column.create(c)\n        .alignItems(Align.STRETCH)\n        .child(Text.create(c)\n            .text(\"This is MY layout spec\")\n            .withLayout()\n            .visibleHandler(MyLayoutSpec.onTitleVisible(c))\n            .invisibleHandler(MyLayoutSpec.onTitleInvisible(c)))\n        .focusedHandler(MyLayoutSpec.onComponentFocused(c, \"someStringParam\"))\n        .fullImpressionHandler(MyLayoutSpec.onComponentFullImpression(c)))\n        .build();\n  }\n\n  @OnEvent(VisibleEvent.class)\n  static void onTitleVisible(ComponentContext c) {\n    Log.d(\"VisibilityRanges\", \"The title entered the Visible Range\");\n  }\n\n  @OnEvent(InvisibleEvent.class)\n  static void onTitleInvisible(ComponentContext c) {\n    Log.d(\"VisibilityRanges\", \"The title is no longer visible\");\n  }\n\n  @OnEvent(FocusedVisibleEvent.class)\n  static void onComponentFocused(\n      ComponentContext c,\n      @Param String stringParam) {\n    Log.d(\n      \"VisibilityRanges\",\n      \"The component is focused with param: \" + contentString);\n  }\n\n  @OnEvent(FullImpressionVisibleEvent.class)\n  static void onComponentFullImpression(ComponentContext c) {\n    Log.d(\"VisibilityRanges\", \"The component has logged a full impression\");\n  }\n};\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-可见性的处理","published":1,"updated":"2017-05-11T09:28:01.687Z","_id":"cj2k76hr70023ssrltd4h8cb3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/visibility-handling\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><h3 id=\"可见性的处理\"><a href=\"#可见性的处理\" class=\"headerlink\" title=\"可见性的处理\"></a>可见性的处理</h3><p></p><br><p></p><p></p>\n<h4 id=\"可见范围的类型\"><a href=\"#可见范围的类型\" class=\"headerlink\" title=\"可见范围的类型\"></a>可见范围的类型</h4><hr>\n<p>框架现在支持4中类型过的可见性事件:</p>\n<ul>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/VisibleEvent\" target=\"_blank\" rel=\"external\">可见事件</a>:这种事件会在Component至少有1像素是可见的时候被触发.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/InvisibleEvent\" target=\"_blank\" rel=\"external\">不可见事件</a>:这种事件会在Component不再有任何像素是可见的时候被触发.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/FocusedVisibleEvent\" target=\"_blank\" rel=\"external\">聚焦可见事件</a>:这种事件会在Component至少占据视窗一半的的时候被触发,如果Component的大小小于视窗的一半,则会在Component完全可见的时候被触发.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/FullImpressionVisibleEvent\" target=\"_blank\" rel=\"external\">完全展示可见事件</a>:当整个Component在某个时间点通过视窗时，会触发此事件。</li>\n</ul>\n<p></p><br><p></p><p></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><hr>\n<p>可见性范围需要相关的Component支持<a href=\"\">增量式挂载</a></p>\n<p>为一个Component注册可见性事件handler,你可以按照注册其他事件handler相同的<a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/\">步骤</a>来操作.</p>\n<p>下面是示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLayoutSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .alignItems(Align.STRETCH)</div><div class=\"line\">        .child(Text.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"This is MY layout spec\"</span>)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .visibleHandler(MyLayoutSpec.onTitleVisible(c))</div><div class=\"line\">            .invisibleHandler(MyLayoutSpec.onTitleInvisible(c)))</div><div class=\"line\">        .focusedHandler(MyLayoutSpec.onComponentFocused(c, <span class=\"string\">\"someStringParam\"</span>))</div><div class=\"line\">        .fullImpressionHandler(MyLayoutSpec.onComponentFullImpression(c)))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(VisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onTitleVisible</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"VisibilityRanges\"</span>, <span class=\"string\">\"The title entered the Visible Range\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(InvisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onTitleInvisible</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"VisibilityRanges\"</span>, <span class=\"string\">\"The title is no longer visible\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(FocusedVisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onComponentFocused</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Param String stringParam) &#123;</div><div class=\"line\">    Log.d(</div><div class=\"line\">      <span class=\"string\">\"VisibilityRanges\"</span>,</div><div class=\"line\">      <span class=\"string\">\"The component is focused with param: \"</span> + contentString);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(FullImpressionVisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onComponentFullImpression</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"VisibilityRanges\"</span>, <span class=\"string\">\"The component has logged a full impression\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/visibility-handling\">Litho-doc</a></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><h3 id=\"可见性的处理\"><a href=\"#可见性的处理\" class=\"headerlink\" title=\"可见性的处理\"></a>可见性的处理</h3><p></p><br></p></p>\n<h4 id=\"可见范围的类型\"><a href=\"#可见范围的类型\" class=\"headerlink\" title=\"可见范围的类型\"></a>可见范围的类型</h4><hr>\n<p>框架现在支持4中类型过的可见性事件:</p>\n<ul>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/VisibleEvent\">可见事件</a>:这种事件会在Component至少有1像素是可见的时候被触发.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/InvisibleEvent\">不可见事件</a>:这种事件会在Component不再有任何像素是可见的时候被触发.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/FocusedVisibleEvent\">聚焦可见事件</a>:这种事件会在Component至少占据视窗一半的的时候被触发,如果Component的大小小于视窗的一半,则会在Component完全可见的时候被触发.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/FullImpressionVisibleEvent\">完全展示可见事件</a>:当整个Component在某个时间点通过视窗时，会触发此事件。</li>\n</ul>\n<p></p><br></p></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><hr>\n<p>可见性范围需要相关的Component支持<a href=\"\">增量式挂载</a></p>\n<p>为一个Component注册可见性事件handler,你可以按照注册其他事件handler相同的<a href=\"https://shikieiki.github.io/2017/05/05/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0/\">步骤</a>来操作.</p>\n<p>下面是示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLayoutSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .alignItems(Align.STRETCH)</div><div class=\"line\">        .child(Text.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"This is MY layout spec\"</span>)</div><div class=\"line\">            .withLayout()</div><div class=\"line\">            .visibleHandler(MyLayoutSpec.onTitleVisible(c))</div><div class=\"line\">            .invisibleHandler(MyLayoutSpec.onTitleInvisible(c)))</div><div class=\"line\">        .focusedHandler(MyLayoutSpec.onComponentFocused(c, <span class=\"string\">\"someStringParam\"</span>))</div><div class=\"line\">        .fullImpressionHandler(MyLayoutSpec.onComponentFullImpression(c)))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(VisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onTitleVisible</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"VisibilityRanges\"</span>, <span class=\"string\">\"The title entered the Visible Range\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(InvisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onTitleInvisible</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"VisibilityRanges\"</span>, <span class=\"string\">\"The title is no longer visible\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(FocusedVisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onComponentFocused</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Param String stringParam)</span> </span>&#123;</div><div class=\"line\">    Log.d(</div><div class=\"line\">      <span class=\"string\">\"VisibilityRanges\"</span>,</div><div class=\"line\">      <span class=\"string\">\"The component is focused with param: \"</span> + contentString);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(FullImpressionVisibleEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onComponentFullImpression</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    Log.d(<span class=\"string\">\"VisibilityRanges\"</span>, <span class=\"string\">\"The component has logged a full impression\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-触摸事件","date":"2017-05-08T08:15:18.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/events-touch-handling)\n## 事件处理\n### 触摸事件处理\n\n</p>\n</p>\n\n\n所有的Component都支持通过框架的事件系统处理触摸事件.所有的Component都默认支持处理下列几种事件:ClickEvent(点击事件),LongClickEvent(长按事件)和TouchEvent(触摸事件).\n\n这意味着所有的布局builder都分别拥有叫做clickHandler,longClickHandler和touchHandler的EventHandler prop.你可以在你的@OnEvent注释里把你想要处理的事件类作为参数指定出来.\n\n举例来说,在任意一个Component指定点击handler都非常简单:\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n\t@OnCreateLayout\n\tstatic ComponentLayout onCreateLayout(\n\t    ComponentContext c,\n\t    @Prop String title) {\n\t    \n\t  return Text.create(c)\n\t      .text(title)\n\t      .withLayout()\n\t      .clickHandler(MyComponent.onClick(c))\n\t      .build();\n    }\n}\n```\n\n并且在MyComponentSpec中的回调可以写成这样:\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n... \n    @OnEvent(ClickEvent.class)\n    static void onClick(\n        ComponentContext c,\n        @FromEvent View view,\n        @Prop String someProp) {\n        // Handle click here.\n    }\n}\n```\n\n</p>\n</p>\n\n#### 触摸范围扩大\n---\n你可以使用布局builder中的触摸扩展API来扩展可交互的范围边界.\n\n``` java\nText.create(c)\n    .text(title)\n    .withLayout()\n    .clickHandler(MyComponent.onClick(c))\n    .touchExpansionDip(ALL, 10);\n```\n在这个例子中,text Component的可点击范围比Component的所有边界(上,下,左,右)都扩展了10dip.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n\n","source":"_posts/2017-05-08-Facebook出品的Android声明式开源新框架Litho文档翻译-触摸事件.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-触摸事件\ndate: 2017-05-08 16:15:18\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/events-touch-handling)\n## 事件处理\n### 触摸事件处理\n\n</p>\n</p>\n\n\n所有的Component都支持通过框架的事件系统处理触摸事件.所有的Component都默认支持处理下列几种事件:ClickEvent(点击事件),LongClickEvent(长按事件)和TouchEvent(触摸事件).\n\n这意味着所有的布局builder都分别拥有叫做clickHandler,longClickHandler和touchHandler的EventHandler prop.你可以在你的@OnEvent注释里把你想要处理的事件类作为参数指定出来.\n\n举例来说,在任意一个Component指定点击handler都非常简单:\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n\t@OnCreateLayout\n\tstatic ComponentLayout onCreateLayout(\n\t    ComponentContext c,\n\t    @Prop String title) {\n\t    \n\t  return Text.create(c)\n\t      .text(title)\n\t      .withLayout()\n\t      .clickHandler(MyComponent.onClick(c))\n\t      .build();\n    }\n}\n```\n\n并且在MyComponentSpec中的回调可以写成这样:\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n... \n    @OnEvent(ClickEvent.class)\n    static void onClick(\n        ComponentContext c,\n        @FromEvent View view,\n        @Prop String someProp) {\n        // Handle click here.\n    }\n}\n```\n\n</p>\n</p>\n\n#### 触摸范围扩大\n---\n你可以使用布局builder中的触摸扩展API来扩展可交互的范围边界.\n\n``` java\nText.create(c)\n    .text(title)\n    .withLayout()\n    .clickHandler(MyComponent.onClick(c))\n    .touchExpansionDip(ALL, 10);\n```\n在这个例子中,text Component的可点击范围比Component的所有边界(上,下,左,右)都扩展了10dip.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-触摸事件","published":1,"updated":"2017-05-11T09:27:38.283Z","_id":"cj2k76hr80027ssrlgev0jteu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/events-touch-handling\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><h3 id=\"触摸事件处理\"><a href=\"#触摸事件处理\" class=\"headerlink\" title=\"触摸事件处理\"></a>触摸事件处理</h3><p></p><br><p></p><p></p>\n<p>所有的Component都支持通过框架的事件系统处理触摸事件.所有的Component都默认支持处理下列几种事件:ClickEvent(点击事件),LongClickEvent(长按事件)和TouchEvent(触摸事件).</p>\n<p>这意味着所有的布局builder都分别拥有叫做clickHandler,longClickHandler和touchHandler的EventHandler prop.你可以在你的@OnEvent注释里把你想要处理的事件类作为参数指定出来.</p>\n<p>举例来说,在任意一个Component指定点击handler都非常简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">\t    ComponentContext c,</div><div class=\"line\">\t    @Prop String title) &#123;</div><div class=\"line\">\t    </div><div class=\"line\">\t  <span class=\"keyword\">return</span> Text.create(c)</div><div class=\"line\">\t      .text(title)</div><div class=\"line\">\t      .withLayout()</div><div class=\"line\">\t      .clickHandler(MyComponent.onClick(c))</div><div class=\"line\">\t      .build();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并且在MyComponentSpec中的回调可以写成这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">... </div><div class=\"line\">    <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(</span></span></div><div class=\"line\">        ComponentContext c,</div><div class=\"line\">        @FromEvent View view,</div><div class=\"line\">        @Prop String someProp) &#123;</div><div class=\"line\">        <span class=\"comment\">// Handle click here.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"触摸范围扩大\"><a href=\"#触摸范围扩大\" class=\"headerlink\" title=\"触摸范围扩大\"></a>触摸范围扩大</h4><hr>\n<p>你可以使用布局builder中的触摸扩展API来扩展可交互的范围边界.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .clickHandler(MyComponent.onClick(c))</div><div class=\"line\">    .touchExpansionDip(ALL, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<p>在这个例子中,text Component的可点击范围比Component的所有边界(上,下,左,右)都扩展了10dip.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/events-touch-handling\">Litho-doc</a></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><h3 id=\"触摸事件处理\"><a href=\"#触摸事件处理\" class=\"headerlink\" title=\"触摸事件处理\"></a>触摸事件处理</h3><p></p><br></p></p>\n<p>所有的Component都支持通过框架的事件系统处理触摸事件.所有的Component都默认支持处理下列几种事件:ClickEvent(点击事件),LongClickEvent(长按事件)和TouchEvent(触摸事件).</p>\n<p>这意味着所有的布局builder都分别拥有叫做clickHandler,longClickHandler和touchHandler的EventHandler prop.你可以在你的@OnEvent注释里把你想要处理的事件类作为参数指定出来.</p>\n<p>举例来说,在任意一个Component指定点击handler都非常简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">\t    ComponentContext c,</div><div class=\"line\">\t    @Prop String title)</span> </span>&#123;</div><div class=\"line\">\t    </div><div class=\"line\">\t  <span class=\"keyword\">return</span> Text.create(c)</div><div class=\"line\">\t      .text(title)</div><div class=\"line\">\t      .withLayout()</div><div class=\"line\">\t      .clickHandler(MyComponent.onClick(c))</div><div class=\"line\">\t      .build();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并且在MyComponentSpec中的回调可以写成这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">... </div><div class=\"line\">    <span class=\"meta\">@OnEvent</span>(ClickEvent.class)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(</div><div class=\"line\">        ComponentContext c,</div><div class=\"line\">        @FromEvent View view,</div><div class=\"line\">        @Prop String someProp)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Handle click here.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"触摸范围扩大\"><a href=\"#触摸范围扩大\" class=\"headerlink\" title=\"触摸范围扩大\"></a>触摸范围扩大</h4><hr>\n<p>你可以使用布局builder中的触摸扩展API来扩展可交互的范围边界.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .clickHandler(MyComponent.onClick(c))</div><div class=\"line\">    .touchExpansionDip(ALL, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<p>在这个例子中,text Component的可点击范围比Component的所有边界(上,下,左,右)都扩展了10dip.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-RTL","date":"2017-05-09T03:08:42.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/rtl)\n## 兼容性\n### RTL\n\n</p>\n</p>\n\nLitho中对RTL(从右到左)布局的支持与Android的RTL支持相同.为了使你的Component支持RTL,你只需要简单的在margin和padding参数中使用START和END代替原来的LEFT和RIGHT就可以了.所有其他的工作都会由布局系统自动的完成.\n\n举例来说,这是一个布局:\n``` java\nColumn.create(c)\n    .paddingDip(START, 10)\n    .marginDip(END, 5)\n    .child(...)\n    .child(...)\n    .build();\n```\n\n布局系统将会自动的遵循Android资源系统定义的布局方向.你还可以使用类似的start/end变量到位置参数中来是绝对位置支持RTL.\n\n``` java\nImage.create(c)\n    .srcRes(R.drawable.my_image)\n    .withLayout()\n    .positionType(ABSOLUTE)\n    .positionDip(START, 10)\n    .build();\n```\n\n在上面的示例中,当RTL被激活时,image Component将会自动的调整到距离它的父级的右边缘10像素的位置上.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","source":"_posts/2017-05-09-Facebook出品的Android声明式开源新框架Litho文档翻译-RTL.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-RTL\ndate: 2017-05-09 11:08:42\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/rtl)\n## 兼容性\n### RTL\n\n</p>\n</p>\n\nLitho中对RTL(从右到左)布局的支持与Android的RTL支持相同.为了使你的Component支持RTL,你只需要简单的在margin和padding参数中使用START和END代替原来的LEFT和RIGHT就可以了.所有其他的工作都会由布局系统自动的完成.\n\n举例来说,这是一个布局:\n``` java\nColumn.create(c)\n    .paddingDip(START, 10)\n    .marginDip(END, 5)\n    .child(...)\n    .child(...)\n    .build();\n```\n\n布局系统将会自动的遵循Android资源系统定义的布局方向.你还可以使用类似的start/end变量到位置参数中来是绝对位置支持RTL.\n\n``` java\nImage.create(c)\n    .srcRes(R.drawable.my_image)\n    .withLayout()\n    .positionType(ABSOLUTE)\n    .positionDip(START, 10)\n    .build();\n```\n\n在上面的示例中,当RTL被激活时,image Component将会自动的调整到距离它的父级的右边缘10像素的位置上.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-RTL","published":1,"updated":"2017-05-11T09:29:46.976Z","_id":"cj2k76hrc002assrltpojk0ab","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/rtl\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><h3 id=\"RTL\"><a href=\"#RTL\" class=\"headerlink\" title=\"RTL\"></a>RTL</h3><p></p><br><p></p><p></p>\n<p>Litho中对RTL(从右到左)布局的支持与Android的RTL支持相同.为了使你的Component支持RTL,你只需要简单的在margin和padding参数中使用START和END代替原来的LEFT和RIGHT就可以了.所有其他的工作都会由布局系统自动的完成.</p>\n<p>举例来说,这是一个布局:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Column.create(c)</div><div class=\"line\">    .paddingDip(START, <span class=\"number\">10</span>)</div><div class=\"line\">    .marginDip(END, <span class=\"number\">5</span>)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>布局系统将会自动的遵循Android资源系统定义的布局方向.你还可以使用类似的start/end变量到位置参数中来是绝对位置支持RTL.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Image.create(c)</div><div class=\"line\">    .srcRes(R.drawable.my_image)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .positionType(ABSOLUTE)</div><div class=\"line\">    .positionDip(START, <span class=\"number\">10</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<p>在上面的示例中,当RTL被激活时,image Component将会自动的调整到距离它的父级的右边缘10像素的位置上.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/rtl\">Litho-doc</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><h3 id=\"RTL\"><a href=\"#RTL\" class=\"headerlink\" title=\"RTL\"></a>RTL</h3><p></p><br></p></p>\n<p>Litho中对RTL(从右到左)布局的支持与Android的RTL支持相同.为了使你的Component支持RTL,你只需要简单的在margin和padding参数中使用START和END代替原来的LEFT和RIGHT就可以了.所有其他的工作都会由布局系统自动的完成.</p>\n<p>举例来说,这是一个布局:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Column.create(c)</div><div class=\"line\">    .paddingDip(START, <span class=\"number\">10</span>)</div><div class=\"line\">    .marginDip(END, <span class=\"number\">5</span>)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .child(...)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>布局系统将会自动的遵循Android资源系统定义的布局方向.你还可以使用类似的start/end变量到位置参数中来是绝对位置支持RTL.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Image.create(c)</div><div class=\"line\">    .srcRes(R.drawable.my_image)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .positionType(ABSOLUTE)</div><div class=\"line\">    .positionDip(START, <span class=\"number\">10</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure>\n<p>在上面的示例中,当RTL被激活时,image Component将会自动的调整到距离它的父级的右边缘10像素的位置上.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-单元测试","date":"2017-05-09T03:26:59.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/unit-testing)\n## 测试\n### 单元测试\n\n</p>\n</p>\n\nLitho通过流AssertJ方法提供了测试helper.可用的有:\n- [ComponentAssert](http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/ComponentAssert)用于那些针对Component builder和Component的断言.\n- [LithoViewAssert](http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/LithoViewAssert)用于针对已挂载Component的断言.\n\n为了使用这些测试功能,你需要在编译的时候包含可选的litho-testing包.可用的包是:com.facebook.litho:litho-testing:+\n\n为了演示这些类的用法,下面展示一个示例,它是一个包含了图标和简单描述文字的Component.\n\n``` java\n/**\n * Displays who liked the post.\n *\n * 1 - 3 likers => Comma separated names (e.g. Jane, Mike, Doug)\n * > 3 likers => Comma separated number denoting the like count\n */\n@LayoutSpec\nclass LikersComponentSpec {\n\n  @OnCreateLayout\n  protected static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop List<User> likers) {\n      \n    return Row.create(c)\n        .alignItems(FLEX_START)\n        .child(\n            Image.create(c)\n                 .srcRes(R.drawable.like))\n        .child(\n            Text.create(c)\n                .text(formatLikers(likers))\n                .textSizeSp(12)\n                .ellipsize(TruncateAt.END))\n        .build();\n  }\n\n  private static String formatLikers(List<User> likers) {\n    ...\n  }\n}\n```\n\n在我们的测试中,我们想要验证文字和图标的渲染效果.\n\n</p>\n</p>\n\n#### 安装\n---\nComponent的测试框架提供了一个Junit @Rule,它覆写了[Styleables](https://developer.android.com/reference/android/R.styleable.html),并且允许轻松的访问ComponentContext.\n\n``` java\n/**\n * Tests {@link LikersComponent}\n */\n@RunWith(RobolectricTestRunner.class)\npublic class LikersComponentTest {\n  @Rule\n  public ComponentsRule mComponentsRule = new ComponentsRule();\n```\n\n</p>\n</p>\n\n#### 测试组件的渲染\n---\nComponent框架包括了一组AssertJ风格的helper类来验证你Component的属性.在后台,它们将为你挂载Component.\n\n你也可以在ComponentContext和Context组上,或者ComponentBuilder被build()消耗之前使用断言.\n\n``` java\n  @Test\n  public void testTwoLikers() {\n    ComponentContext c = mComponentsRule.getContext();\n    ImmutableList<User> likers =\n       ImmutableList.of(new User(\"Jane\"), new User(\"Mike\"));\n\n    Component<LikersComponent> component =\n       LikersComponent\n           .create(c)\n           .likers(likers)\n           .build();\n\n    assertThat(c, component).hasText(\"Jane, Mike\");\n  }\n\n  @Test\n  public void testLikeIcon() {\n    ComponentContext c = mComponentsRule.getContext();\n    Drawable likeIcon = c.getResources().getDrawable(R.drawable.like);\n\n    ImmutableList<User> likers =\n        ImmutableList.of(new User(\"Jane\"), new User(\"Mike\"));\n\n    LikersComponent.Builder componentBuilder =\n        LikersComponent\n            .create(c)\n            .likers(likers);\n\n    assertThat(componentBuilder).hasDrawable(likeIcon);\n  }\n```\n\n</p>\n</p>\n\n#### 测试子Component的渲染\n---\n\n比起在你的Component的内容渲染上使用断言,可能一种更有效的方式是测试子Component的渲染情况.[SubComponent](http://fblitho.com/javadoc/com/facebook/litho/testing/SubComponent)是一个方便的类,可以更简单的比较Component的类型.你依然可以使用AssertJ来验证子Component是否存在.\n\n``` java\npublic class StoryTest {\n  ...\n\n  @Test\n  public void testStoryLayout() {\n    ComponentContext c = mComponentsRule.getContext();\n    Story story = ...\n\n    Component<StoryComponent> component =\n        StoryComponent.create(c)\n            .story(story);\n\n    assertThat(subComponents).hasSubComponents(\n        SubComponent.of(HeaderComponent.class),\n        SubComponent.of(MessageComponent.class),\n        SubComponent.of(LikersComponent.class),\n        SubComponent.of(FeedbackComponent.class));\n  }\n\n  @Test\n  public void testStoryWithZeroLikes() {\n    ComponentContext c = mComponentsRule.getContext();\n    Story storyWithZeroLikes = ...;\n\n    Component<StoryComponent> component = StoryComponent.create(c)\n        .story(storyWithZeroLikes)\n        .build();\n\n    assertThat(component)\n        .doesNotContainSubComponent(SubComponent.of(LikersComponent.class));\n  }\n}\n```\n\n</p>\n</p>\n\n#### 额外的断言\n---\n还有一些断言是可用于Component和LithoView的.他们都会在你的Component创建的树上进行操作.因此,断言一个你的Component上的Drawable的存在将会从提供的开始点遍历view的层级结构.\n\n</p>\n</p>\n\n#### 注意事项\n---\n在进行Litho单元测试时,请注意,Yoga的本地库必须要被加载,这可能会由于你的构建系统的选择,而产生一些问题.比如,使用Gradle和Robolectric时,你可能会遇到问题,因为Robolectric对于每一个测试组件都使用了一个新的拥有不同设置的[ClassLoader](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html).对于PowerMock也是一样,对于每一个基本组件,它都提供了一个ClassLoader,并且规定他们都为不可重用状态.\n\nJVM有两个非常重要的相关限制:\n1. 一个共享的库在一个进程中只能被加载一次.\n2. ClassLoader不共享加载的库的信息\n\n因为这些,在测试运行中使用多个ClassLoader是非常有问题的,因为每一个实例都会尝试加载Yoga,但是除了第一个会成功之外,其它的都会报libyoga.so already loaded in another classloader(libyoga.so已经在另一个classloader被加载过了)的异常.\n\n避免这个的唯一方法是避免使用多个ClassLoader,如果必须使用新的ClassLoader,则使用fork进程的方式.\n\nGradle允许你限制一个进程在作废之前可以执行的测试类的数量.如果你设置这个值为1,我们就避免了ClassLoader的重用:\n``` java\nandroid {\n    [...]\n\n    testOptions {\n        unitTests.all {\n            forkEvery = 1\n            maxParallelForks = Math.ceil(Runtime.runtime.availableProcessors() * 1.5)\n        }\n    }\n}\n```\n\n使用BUCK,可以通过指定每一个测试目标的名称为会导致并行进程加速的名称来打到这个效果.或者,你也可以设置fork_mode为per_test,具体请参照[这里](https://buckbuild.com/rule/java_test.html#fork_mode)的描述.\n\n最后,根据你的构建系统和你的项目中已经存在的限制,你可能需要调整你的测试运行器使用ClassLoader的方式.然而,这不是Litho独有的问题,而是在Android项目中混合使用native代码和java代码所导致的不幸后果.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n\n\n\n\n\n","source":"_posts/2017-05-09-Facebook出品的Android声明式开源新框架Litho文档翻译-单元测试.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-单元测试\ndate: 2017-05-09 11:26:59\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/unit-testing)\n## 测试\n### 单元测试\n\n</p>\n</p>\n\nLitho通过流AssertJ方法提供了测试helper.可用的有:\n- [ComponentAssert](http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/ComponentAssert)用于那些针对Component builder和Component的断言.\n- [LithoViewAssert](http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/LithoViewAssert)用于针对已挂载Component的断言.\n\n为了使用这些测试功能,你需要在编译的时候包含可选的litho-testing包.可用的包是:com.facebook.litho:litho-testing:+\n\n为了演示这些类的用法,下面展示一个示例,它是一个包含了图标和简单描述文字的Component.\n\n``` java\n/**\n * Displays who liked the post.\n *\n * 1 - 3 likers => Comma separated names (e.g. Jane, Mike, Doug)\n * > 3 likers => Comma separated number denoting the like count\n */\n@LayoutSpec\nclass LikersComponentSpec {\n\n  @OnCreateLayout\n  protected static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop List<User> likers) {\n      \n    return Row.create(c)\n        .alignItems(FLEX_START)\n        .child(\n            Image.create(c)\n                 .srcRes(R.drawable.like))\n        .child(\n            Text.create(c)\n                .text(formatLikers(likers))\n                .textSizeSp(12)\n                .ellipsize(TruncateAt.END))\n        .build();\n  }\n\n  private static String formatLikers(List<User> likers) {\n    ...\n  }\n}\n```\n\n在我们的测试中,我们想要验证文字和图标的渲染效果.\n\n</p>\n</p>\n\n#### 安装\n---\nComponent的测试框架提供了一个Junit @Rule,它覆写了[Styleables](https://developer.android.com/reference/android/R.styleable.html),并且允许轻松的访问ComponentContext.\n\n``` java\n/**\n * Tests {@link LikersComponent}\n */\n@RunWith(RobolectricTestRunner.class)\npublic class LikersComponentTest {\n  @Rule\n  public ComponentsRule mComponentsRule = new ComponentsRule();\n```\n\n</p>\n</p>\n\n#### 测试组件的渲染\n---\nComponent框架包括了一组AssertJ风格的helper类来验证你Component的属性.在后台,它们将为你挂载Component.\n\n你也可以在ComponentContext和Context组上,或者ComponentBuilder被build()消耗之前使用断言.\n\n``` java\n  @Test\n  public void testTwoLikers() {\n    ComponentContext c = mComponentsRule.getContext();\n    ImmutableList<User> likers =\n       ImmutableList.of(new User(\"Jane\"), new User(\"Mike\"));\n\n    Component<LikersComponent> component =\n       LikersComponent\n           .create(c)\n           .likers(likers)\n           .build();\n\n    assertThat(c, component).hasText(\"Jane, Mike\");\n  }\n\n  @Test\n  public void testLikeIcon() {\n    ComponentContext c = mComponentsRule.getContext();\n    Drawable likeIcon = c.getResources().getDrawable(R.drawable.like);\n\n    ImmutableList<User> likers =\n        ImmutableList.of(new User(\"Jane\"), new User(\"Mike\"));\n\n    LikersComponent.Builder componentBuilder =\n        LikersComponent\n            .create(c)\n            .likers(likers);\n\n    assertThat(componentBuilder).hasDrawable(likeIcon);\n  }\n```\n\n</p>\n</p>\n\n#### 测试子Component的渲染\n---\n\n比起在你的Component的内容渲染上使用断言,可能一种更有效的方式是测试子Component的渲染情况.[SubComponent](http://fblitho.com/javadoc/com/facebook/litho/testing/SubComponent)是一个方便的类,可以更简单的比较Component的类型.你依然可以使用AssertJ来验证子Component是否存在.\n\n``` java\npublic class StoryTest {\n  ...\n\n  @Test\n  public void testStoryLayout() {\n    ComponentContext c = mComponentsRule.getContext();\n    Story story = ...\n\n    Component<StoryComponent> component =\n        StoryComponent.create(c)\n            .story(story);\n\n    assertThat(subComponents).hasSubComponents(\n        SubComponent.of(HeaderComponent.class),\n        SubComponent.of(MessageComponent.class),\n        SubComponent.of(LikersComponent.class),\n        SubComponent.of(FeedbackComponent.class));\n  }\n\n  @Test\n  public void testStoryWithZeroLikes() {\n    ComponentContext c = mComponentsRule.getContext();\n    Story storyWithZeroLikes = ...;\n\n    Component<StoryComponent> component = StoryComponent.create(c)\n        .story(storyWithZeroLikes)\n        .build();\n\n    assertThat(component)\n        .doesNotContainSubComponent(SubComponent.of(LikersComponent.class));\n  }\n}\n```\n\n</p>\n</p>\n\n#### 额外的断言\n---\n还有一些断言是可用于Component和LithoView的.他们都会在你的Component创建的树上进行操作.因此,断言一个你的Component上的Drawable的存在将会从提供的开始点遍历view的层级结构.\n\n</p>\n</p>\n\n#### 注意事项\n---\n在进行Litho单元测试时,请注意,Yoga的本地库必须要被加载,这可能会由于你的构建系统的选择,而产生一些问题.比如,使用Gradle和Robolectric时,你可能会遇到问题,因为Robolectric对于每一个测试组件都使用了一个新的拥有不同设置的[ClassLoader](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html).对于PowerMock也是一样,对于每一个基本组件,它都提供了一个ClassLoader,并且规定他们都为不可重用状态.\n\nJVM有两个非常重要的相关限制:\n1. 一个共享的库在一个进程中只能被加载一次.\n2. ClassLoader不共享加载的库的信息\n\n因为这些,在测试运行中使用多个ClassLoader是非常有问题的,因为每一个实例都会尝试加载Yoga,但是除了第一个会成功之外,其它的都会报libyoga.so already loaded in another classloader(libyoga.so已经在另一个classloader被加载过了)的异常.\n\n避免这个的唯一方法是避免使用多个ClassLoader,如果必须使用新的ClassLoader,则使用fork进程的方式.\n\nGradle允许你限制一个进程在作废之前可以执行的测试类的数量.如果你设置这个值为1,我们就避免了ClassLoader的重用:\n``` java\nandroid {\n    [...]\n\n    testOptions {\n        unitTests.all {\n            forkEvery = 1\n            maxParallelForks = Math.ceil(Runtime.runtime.availableProcessors() * 1.5)\n        }\n    }\n}\n```\n\n使用BUCK,可以通过指定每一个测试目标的名称为会导致并行进程加速的名称来打到这个效果.或者,你也可以设置fork_mode为per_test,具体请参照[这里](https://buckbuild.com/rule/java_test.html#fork_mode)的描述.\n\n最后,根据你的构建系统和你的项目中已经存在的限制,你可能需要调整你的测试运行器使用ClassLoader的方式.然而,这不是Litho独有的问题,而是在Android项目中混合使用native代码和java代码所导致的不幸后果.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n\n\n\n\n\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-单元测试","published":1,"updated":"2017-05-11T09:31:12.408Z","_id":"cj2k76hre002dssrln2mq958z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/unit-testing\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p></p><br><p></p><p></p>\n<p>Litho通过流AssertJ方法提供了测试helper.可用的有:</p>\n<ul>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/ComponentAssert\" target=\"_blank\" rel=\"external\">ComponentAssert</a>用于那些针对Component builder和Component的断言.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/LithoViewAssert\" target=\"_blank\" rel=\"external\">LithoViewAssert</a>用于针对已挂载Component的断言.</li>\n</ul>\n<p>为了使用这些测试功能,你需要在编译的时候包含可选的litho-testing包.可用的包是:com.facebook.litho:litho-testing:+</p>\n<p>为了演示这些类的用法,下面展示一个示例,它是一个包含了图标和简单描述文字的Component.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Displays who liked the post.</div><div class=\"line\"> *</div><div class=\"line\"> * 1 - 3 likers =&gt; Comma separated names (e.g. Jane, Mike, Doug)</div><div class=\"line\"> * &gt; 3 likers =&gt; Comma separated number denoting the like count</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LikersComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop List&lt;User&gt; likers) &#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">        .alignItems(FLEX_START)</div><div class=\"line\">        .child(</div><div class=\"line\">            Image.create(c)</div><div class=\"line\">                 .srcRes(R.drawable.like))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(formatLikers(likers))</div><div class=\"line\">                .textSizeSp(<span class=\"number\">12</span>)</div><div class=\"line\">                .ellipsize(TruncateAt.END))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">formatLikers</span><span class=\"params\">(List&lt;User&gt; likers)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在我们的测试中,我们想要验证文字和图标的渲染效果.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><hr>\n<p>Component的测试框架提供了一个Junit @Rule,它覆写了<a href=\"https://developer.android.com/reference/android/R.styleable.html\" target=\"_blank\" rel=\"external\">Styleables</a>,并且允许轻松的访问ComponentContext.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Tests &#123;<span class=\"doctag\">@link</span> LikersComponent&#125;</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">@RunWith</span>(RobolectricTestRunner.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LikersComponentTest</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Rule</span></div><div class=\"line\">  <span class=\"keyword\">public</span> ComponentsRule mComponentsRule = <span class=\"keyword\">new</span> ComponentsRule();</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"测试组件的渲染\"><a href=\"#测试组件的渲染\" class=\"headerlink\" title=\"测试组件的渲染\"></a>测试组件的渲染</h4><hr>\n<p>Component框架包括了一组AssertJ风格的helper类来验证你Component的属性.在后台,它们将为你挂载Component.</p>\n<p>你也可以在ComponentContext和Context组上,或者ComponentBuilder被build()消耗之前使用断言.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTwoLikers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">  ImmutableList&lt;User&gt; likers =</div><div class=\"line\">     ImmutableList.of(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jane\"</span>), <span class=\"keyword\">new</span> User(<span class=\"string\">\"Mike\"</span>));</div><div class=\"line\"></div><div class=\"line\">  Component&lt;LikersComponent&gt; component =</div><div class=\"line\">     LikersComponent</div><div class=\"line\">         .create(c)</div><div class=\"line\">         .likers(likers)</div><div class=\"line\">         .build();</div><div class=\"line\"></div><div class=\"line\">  assertThat(c, component).hasText(<span class=\"string\">\"Jane, Mike\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLikeIcon</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">  Drawable likeIcon = c.getResources().getDrawable(R.drawable.like);</div><div class=\"line\"></div><div class=\"line\">  ImmutableList&lt;User&gt; likers =</div><div class=\"line\">      ImmutableList.of(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jane\"</span>), <span class=\"keyword\">new</span> User(<span class=\"string\">\"Mike\"</span>));</div><div class=\"line\"></div><div class=\"line\">  LikersComponent.Builder componentBuilder =</div><div class=\"line\">      LikersComponent</div><div class=\"line\">          .create(c)</div><div class=\"line\">          .likers(likers);</div><div class=\"line\"></div><div class=\"line\">  assertThat(componentBuilder).hasDrawable(likeIcon);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"测试子Component的渲染\"><a href=\"#测试子Component的渲染\" class=\"headerlink\" title=\"测试子Component的渲染\"></a>测试子Component的渲染</h4><hr>\n<p>比起在你的Component的内容渲染上使用断言,可能一种更有效的方式是测试子Component的渲染情况.<a href=\"http://fblitho.com/javadoc/com/facebook/litho/testing/SubComponent\" target=\"_blank\" rel=\"external\">SubComponent</a>是一个方便的类,可以更简单的比较Component的类型.你依然可以使用AssertJ来验证子Component是否存在.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoryTest</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStoryLayout</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">    Story story = ...</div><div class=\"line\"></div><div class=\"line\">    Component&lt;StoryComponent&gt; component =</div><div class=\"line\">        StoryComponent.create(c)</div><div class=\"line\">            .story(story);</div><div class=\"line\"></div><div class=\"line\">    assertThat(subComponents).hasSubComponents(</div><div class=\"line\">        SubComponent.of(HeaderComponent.class),</div><div class=\"line\">        SubComponent.of(MessageComponent.class),</div><div class=\"line\">        SubComponent.of(LikersComponent.class),</div><div class=\"line\">        SubComponent.of(FeedbackComponent.class));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStoryWithZeroLikes</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">    Story storyWithZeroLikes = ...;</div><div class=\"line\"></div><div class=\"line\">    Component&lt;StoryComponent&gt; component = StoryComponent.create(c)</div><div class=\"line\">        .story(storyWithZeroLikes)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    assertThat(component)</div><div class=\"line\">        .doesNotContainSubComponent(SubComponent.of(LikersComponent.class));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"额外的断言\"><a href=\"#额外的断言\" class=\"headerlink\" title=\"额外的断言\"></a>额外的断言</h4><hr>\n<p>还有一些断言是可用于Component和LithoView的.他们都会在你的Component创建的树上进行操作.因此,断言一个你的Component上的Drawable的存在将会从提供的开始点遍历view的层级结构.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><hr>\n<p>在进行Litho单元测试时,请注意,Yoga的本地库必须要被加载,这可能会由于你的构建系统的选择,而产生一些问题.比如,使用Gradle和Robolectric时,你可能会遇到问题,因为Robolectric对于每一个测试组件都使用了一个新的拥有不同设置的<a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html\" target=\"_blank\" rel=\"external\">ClassLoader</a>.对于PowerMock也是一样,对于每一个基本组件,它都提供了一个ClassLoader,并且规定他们都为不可重用状态.</p>\n<p>JVM有两个非常重要的相关限制:</p>\n<ol>\n<li>一个共享的库在一个进程中只能被加载一次.</li>\n<li>ClassLoader不共享加载的库的信息</li>\n</ol>\n<p>因为这些,在测试运行中使用多个ClassLoader是非常有问题的,因为每一个实例都会尝试加载Yoga,但是除了第一个会成功之外,其它的都会报libyoga.so already loaded in another classloader(libyoga.so已经在另一个classloader被加载过了)的异常.</p>\n<p>避免这个的唯一方法是避免使用多个ClassLoader,如果必须使用新的ClassLoader,则使用fork进程的方式.</p>\n<p>Gradle允许你限制一个进程在作废之前可以执行的测试类的数量.如果你设置这个值为1,我们就避免了ClassLoader的重用:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    [...]</div><div class=\"line\"></div><div class=\"line\">    testOptions &#123;</div><div class=\"line\">        unitTests.all &#123;</div><div class=\"line\">            forkEvery = <span class=\"number\">1</span></div><div class=\"line\">            maxParallelForks = Math.ceil(Runtime.runtime.availableProcessors() * <span class=\"number\">1.5</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用BUCK,可以通过指定每一个测试目标的名称为会导致并行进程加速的名称来打到这个效果.或者,你也可以设置fork_mode为per_test,具体请参照<a href=\"https://buckbuild.com/rule/java_test.html#fork_mode\" target=\"_blank\" rel=\"external\">这里</a>的描述.</p>\n<p>最后,根据你的构建系统和你的项目中已经存在的限制,你可能需要调整你的测试运行器使用ClassLoader的方式.然而,这不是Litho独有的问题,而是在Android项目中混合使用native代码和java代码所导致的不幸后果.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/unit-testing\">Litho-doc</a></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p></p><br></p></p>\n<p>Litho通过流AssertJ方法提供了测试helper.可用的有:</p>\n<ul>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/ComponentAssert\">ComponentAssert</a>用于那些针对Component builder和Component的断言.</li>\n<li><a href=\"http://fblitho.com/javadoc/com/facebook/litho/testing/assertj/LithoViewAssert\">LithoViewAssert</a>用于针对已挂载Component的断言.</li>\n</ul>\n<p>为了使用这些测试功能,你需要在编译的时候包含可选的litho-testing包.可用的包是:com.facebook.litho:litho-testing:+</p>\n<p>为了演示这些类的用法,下面展示一个示例,它是一个包含了图标和简单描述文字的Component.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Displays who liked the post.</div><div class=\"line\"> *</div><div class=\"line\"> * 1 - 3 likers =&gt; Comma separated names (e.g. Jane, Mike, Doug)</div><div class=\"line\"> * &gt; 3 likers =&gt; Comma separated number denoting the like count</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LikersComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop List&lt;User&gt; likers)</span> </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">        .alignItems(FLEX_START)</div><div class=\"line\">        .child(</div><div class=\"line\">            Image.create(c)</div><div class=\"line\">                 .srcRes(R.drawable.like))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(formatLikers(likers))</div><div class=\"line\">                .textSizeSp(<span class=\"number\">12</span>)</div><div class=\"line\">                .ellipsize(TruncateAt.END))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">formatLikers</span><span class=\"params\">(List&lt;User&gt; likers)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在我们的测试中,我们想要验证文字和图标的渲染效果.</p>\n<p></p><br></p></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><hr>\n<p>Component的测试框架提供了一个Junit @Rule,它覆写了<a href=\"https://developer.android.com/reference/android/R.styleable.html\">Styleables</a>,并且允许轻松的访问ComponentContext.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Tests &#123;<span class=\"doctag\">@link</span> LikersComponent&#125;</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"meta\">@RunWith</span>(RobolectricTestRunner.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LikersComponentTest</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Rule</span></div><div class=\"line\">  <span class=\"keyword\">public</span> ComponentsRule mComponentsRule = <span class=\"keyword\">new</span> ComponentsRule();</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"测试组件的渲染\"><a href=\"#测试组件的渲染\" class=\"headerlink\" title=\"测试组件的渲染\"></a>测试组件的渲染</h4><hr>\n<p>Component框架包括了一组AssertJ风格的helper类来验证你Component的属性.在后台,它们将为你挂载Component.</p>\n<p>你也可以在ComponentContext和Context组上,或者ComponentBuilder被build()消耗之前使用断言.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTwoLikers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">  ImmutableList&lt;User&gt; likers =</div><div class=\"line\">     ImmutableList.of(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jane\"</span>), <span class=\"keyword\">new</span> User(<span class=\"string\">\"Mike\"</span>));</div><div class=\"line\"></div><div class=\"line\">  Component&lt;LikersComponent&gt; component =</div><div class=\"line\">     LikersComponent</div><div class=\"line\">         .create(c)</div><div class=\"line\">         .likers(likers)</div><div class=\"line\">         .build();</div><div class=\"line\"></div><div class=\"line\">  assertThat(c, component).hasText(<span class=\"string\">\"Jane, Mike\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Test</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLikeIcon</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">  Drawable likeIcon = c.getResources().getDrawable(R.drawable.like);</div><div class=\"line\"></div><div class=\"line\">  ImmutableList&lt;User&gt; likers =</div><div class=\"line\">      ImmutableList.of(<span class=\"keyword\">new</span> User(<span class=\"string\">\"Jane\"</span>), <span class=\"keyword\">new</span> User(<span class=\"string\">\"Mike\"</span>));</div><div class=\"line\"></div><div class=\"line\">  LikersComponent.Builder componentBuilder =</div><div class=\"line\">      LikersComponent</div><div class=\"line\">          .create(c)</div><div class=\"line\">          .likers(likers);</div><div class=\"line\"></div><div class=\"line\">  assertThat(componentBuilder).hasDrawable(likeIcon);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"测试子Component的渲染\"><a href=\"#测试子Component的渲染\" class=\"headerlink\" title=\"测试子Component的渲染\"></a>测试子Component的渲染</h4><hr>\n<p>比起在你的Component的内容渲染上使用断言,可能一种更有效的方式是测试子Component的渲染情况.<a href=\"http://fblitho.com/javadoc/com/facebook/litho/testing/SubComponent\">SubComponent</a>是一个方便的类,可以更简单的比较Component的类型.你依然可以使用AssertJ来验证子Component是否存在.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoryTest</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStoryLayout</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">    Story story = ...</div><div class=\"line\"></div><div class=\"line\">    Component&lt;StoryComponent&gt; component =</div><div class=\"line\">        StoryComponent.create(c)</div><div class=\"line\">            .story(story);</div><div class=\"line\"></div><div class=\"line\">    assertThat(subComponents).hasSubComponents(</div><div class=\"line\">        SubComponent.of(HeaderComponent.class),</div><div class=\"line\">        SubComponent.of(MessageComponent.class),</div><div class=\"line\">        SubComponent.of(LikersComponent.class),</div><div class=\"line\">        SubComponent.of(FeedbackComponent.class));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStoryWithZeroLikes</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ComponentContext c = mComponentsRule.getContext();</div><div class=\"line\">    Story storyWithZeroLikes = ...;</div><div class=\"line\"></div><div class=\"line\">    Component&lt;StoryComponent&gt; component = StoryComponent.create(c)</div><div class=\"line\">        .story(storyWithZeroLikes)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    assertThat(component)</div><div class=\"line\">        .doesNotContainSubComponent(SubComponent.of(LikersComponent.class));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"额外的断言\"><a href=\"#额外的断言\" class=\"headerlink\" title=\"额外的断言\"></a>额外的断言</h4><hr>\n<p>还有一些断言是可用于Component和LithoView的.他们都会在你的Component创建的树上进行操作.因此,断言一个你的Component上的Drawable的存在将会从提供的开始点遍历view的层级结构.</p>\n<p></p><br></p></p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><hr>\n<p>在进行Litho单元测试时,请注意,Yoga的本地库必须要被加载,这可能会由于你的构建系统的选择,而产生一些问题.比如,使用Gradle和Robolectric时,你可能会遇到问题,因为Robolectric对于每一个测试组件都使用了一个新的拥有不同设置的<a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html\">ClassLoader</a>.对于PowerMock也是一样,对于每一个基本组件,它都提供了一个ClassLoader,并且规定他们都为不可重用状态.</p>\n<p>JVM有两个非常重要的相关限制:</p>\n<ol>\n<li>一个共享的库在一个进程中只能被加载一次.</li>\n<li>ClassLoader不共享加载的库的信息</li>\n</ol>\n<p>因为这些,在测试运行中使用多个ClassLoader是非常有问题的,因为每一个实例都会尝试加载Yoga,但是除了第一个会成功之外,其它的都会报libyoga.so already loaded in another classloader(libyoga.so已经在另一个classloader被加载过了)的异常.</p>\n<p>避免这个的唯一方法是避免使用多个ClassLoader,如果必须使用新的ClassLoader,则使用fork进程的方式.</p>\n<p>Gradle允许你限制一个进程在作废之前可以执行的测试类的数量.如果你设置这个值为1,我们就避免了ClassLoader的重用:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    [...]</div><div class=\"line\"></div><div class=\"line\">    testOptions &#123;</div><div class=\"line\">        unitTests.all &#123;</div><div class=\"line\">            forkEvery = <span class=\"number\">1</span></div><div class=\"line\">            maxParallelForks = Math.ceil(Runtime.runtime.availableProcessors() * <span class=\"number\">1.5</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用BUCK,可以通过指定每一个测试目标的名称为会导致并行进程加速的名称来打到这个效果.或者,你也可以设置fork_mode为per_test,具体请参照<a href=\"https://buckbuild.com/rule/java_test.html#fork_mode\">这里</a>的描述.</p>\n<p>最后,根据你的构建系统和你的项目中已经存在的限制,你可能需要调整你的测试运行器使用ClassLoader的方式.然而,这不是Litho独有的问题,而是在Android项目中混合使用native代码和java代码所导致的不幸后果.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-无障碍环境","date":"2017-05-09T01:14:45.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/accessibility)\n## 兼容性\n### 无障碍环境\n\n</p>\n</p>\n\n#### 内容描述\n---\n所有的Component都默认支持内容描述.这意味着所有的布局builder都拥有一个CharSequence类型的prop叫做contentDescription.\n\n在任何component上设置内容描述都非常的简单:\n\n``` java\nImage.create(c)\n    .imageRes(R.drawable.some_image)\n    .withLayout()\n    .contentDescription(\"This is an image\")\n    .build())\n```\n\n在这里设置的内容描述与在Android view上设置的内容描述拥有同等的效果.\n\n</p>\n</p>\n\n#### 自定义\n---\n在Mount Spec可以通过实现一个@OnPopulateAccessibilityNode方法来实现自定义的无障碍支持.这个方法接受一个AccessibilityNodeInfoCompat参数,也接受任何在其他spec方法中指定的prop参数.\n\n举例来说,Text的无障碍功能是使用下列方法指定的:\n``` java\n@OnPopulateAccessibilityNode\nstatic void onPopulateAccessibilityNode(\n    AccessibilityNodeInfoCompat accessibilityNode,\n    @Prop CharSequence text) {\n  accessibilityNode.setText(text);\n}\n```\n\n这仅适用于挂载drawable的Component,因为如果Component挂载一个view,则无障碍支持就是内置的了.\n\n</p>\n</p>\n\n#### 额外的无障碍节点\n---\n如果是在更复杂的需要暴露更多额外的node给无障碍框架的mount spec中,你就必须使用以下的注释实现3个额外的方法:\n- GetExtraAccessibilityNodesCount:返回Component暴露出的外的无障碍节点的个数.\n- OnpopulateExtraAccessibilityNode:使用给定的边界填充额外的无障碍节点.\n- GetExtraVirtualViewAt:返回Component中指定位置的额外无障碍节点的索引.\n- \n</p>\n</p>\n\n#### 无障碍的处理\n---\n所有的Component都支持一系列与[AccessibilityDelegateCompat](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html)方法相一致的事件.\n这些事件拥有它们对应的AccessibilityDelegateCompat方法的参数,和一个额外的名叫superDelegate的AccessibilityDelegateCompat参数,它允许你在必要的时候显式的调用View的无障碍方法的默认实现.\n\n以下是支持的事件的总览:\n\n| 事件 | ACCESSIBILITYDELEGATE方法 |\n| --- | ---- |\n| DispatchPopulateAccessibilityEventEvent | [dispatchPopulateAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#dispatchPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent) |\n| OnInitializeAccessibilityEventEvent | [onInitializeAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent) |\n| OnInitializeAccessibilityNodeInfoEvent | [onInitializeAccessibilityNodeInfo](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityNodeInfo(android.view.View, android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) |\n| OnPopulateAccessibilityEventEvent | [onPopulateAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent) |\n| OnRequestSendAccessibilityEventEvent | [onRequestSendAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onRequestSendAccessibilityEvent(android.view.ViewGroup, android.view.View, android.view.accessibility.AccessibilityEvent) |\n| PerformAccessibilityActionEvent | [performAccessibilityAction](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#performAccessibilityAction(android.view.View, int, android.os.Bundle) |\n| SendAccessibilityEventEvent | [sendAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEvent(android.view.View, int) |\n| SendAccessibilityUncheckedEvent | [sendAccessibilityEventUnchecked](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEventUnchecked(android.view.View, android.view.accessibility.AccessibilityEvent) |\n\n设置任何这些事件的处理程序将会导致在挂载的View中设置AccessibilityDelegate，当调用相应的方法时，它将调用您的事件处理程序。\n\n如果你没有提供处理程序的方法被调用,delegate将会交由ANdroid view的默认实现去处理(类似于调用了super或者superDelegate的实现).\n\n举例来说,下面是覆写Component中onInitializeAccessibilityNodeInfo的步骤:\n1.实现一个事件处理器:\n``` java\n@OnEvent(OnInitializeAccessiblityNodeInfoEvent.class)\nstatic void onInitializeAccessibilityNodeInfoEvent(\n    @FromEvent AccessibilityDelegateCompat superDelegate,\n    @FromEvent View view,\n    @FromEvent AccessibilityNodeInfoCompat node) {\n  // Equivalent to calling super on a regular AccessibilityDelegate, not required\n  superDelegate.onInitializeAccessibilityNodeInfo(view, node);\n  // My implementation\n}\n```\n\n2.把时间处理器设置到component中.\n``` java\nText.create(c)\n    .text(title)\n    .withLayout()\n    .onInitializeAccessiblityNodeInfoHandler(MyComponent.onInitializeAccessibilityNodeInfoEvent(c))\n```\n\nAccessibilityDelegates的一个最好的特性之一就是它的甚至可以跨越视图的可重用性.而在Litho中,这也可以通过在Component中引入一个包含我们需要的事件处理器的包装spec来实现.例如.假设我们需要一个Component,它添加了\"please\"到了每一个它注释的AccessibilityEvent方法中.\n\n``` java\n@LayoutSpec\nclass PoliteComponentWrapper {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop Component<?> content) {\n      \n    return Layout.create(c, content)\n        .onPopulateAccessibilityEventHandler(\n            PoliteComponentWrapper.onPopulateAccessibilityEvent(c))\n        .build();\n  }\n\n  @OnEvent(OnPopulateAccessibilityEvent.class)\n  static void onPopulateAccessibilityEvent(\n      ComponentContext c,\n      @FromEvent AccessibilityDelegateCompat superDelegate,\n      @FromEvent View view\n      @FromEvent AccessibilityEvent event) {\n    superDelegate.onPopulateAccessibilityEvent(view, event);\n    event.getText().add(\"please\");\n  }\n}\n```\n\n现在你可以使用PoliteComponentWrapper来替代任何你原来使用你的Component的地方了.\n\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @Prop CharSequence text) {\n    \n  return PoliteComponentWrapper.create(c)\n      .content(\n           Text.create(c)\n               .text(text))\n      .build();\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-09-Facebook出品的Android声明式开源新框架Litho文档翻译-无障碍环境.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-无障碍环境\ndate: 2017-05-09 09:14:45\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/accessibility)\n## 兼容性\n### 无障碍环境\n\n</p>\n</p>\n\n#### 内容描述\n---\n所有的Component都默认支持内容描述.这意味着所有的布局builder都拥有一个CharSequence类型的prop叫做contentDescription.\n\n在任何component上设置内容描述都非常的简单:\n\n``` java\nImage.create(c)\n    .imageRes(R.drawable.some_image)\n    .withLayout()\n    .contentDescription(\"This is an image\")\n    .build())\n```\n\n在这里设置的内容描述与在Android view上设置的内容描述拥有同等的效果.\n\n</p>\n</p>\n\n#### 自定义\n---\n在Mount Spec可以通过实现一个@OnPopulateAccessibilityNode方法来实现自定义的无障碍支持.这个方法接受一个AccessibilityNodeInfoCompat参数,也接受任何在其他spec方法中指定的prop参数.\n\n举例来说,Text的无障碍功能是使用下列方法指定的:\n``` java\n@OnPopulateAccessibilityNode\nstatic void onPopulateAccessibilityNode(\n    AccessibilityNodeInfoCompat accessibilityNode,\n    @Prop CharSequence text) {\n  accessibilityNode.setText(text);\n}\n```\n\n这仅适用于挂载drawable的Component,因为如果Component挂载一个view,则无障碍支持就是内置的了.\n\n</p>\n</p>\n\n#### 额外的无障碍节点\n---\n如果是在更复杂的需要暴露更多额外的node给无障碍框架的mount spec中,你就必须使用以下的注释实现3个额外的方法:\n- GetExtraAccessibilityNodesCount:返回Component暴露出的外的无障碍节点的个数.\n- OnpopulateExtraAccessibilityNode:使用给定的边界填充额外的无障碍节点.\n- GetExtraVirtualViewAt:返回Component中指定位置的额外无障碍节点的索引.\n- \n</p>\n</p>\n\n#### 无障碍的处理\n---\n所有的Component都支持一系列与[AccessibilityDelegateCompat](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html)方法相一致的事件.\n这些事件拥有它们对应的AccessibilityDelegateCompat方法的参数,和一个额外的名叫superDelegate的AccessibilityDelegateCompat参数,它允许你在必要的时候显式的调用View的无障碍方法的默认实现.\n\n以下是支持的事件的总览:\n\n| 事件 | ACCESSIBILITYDELEGATE方法 |\n| --- | ---- |\n| DispatchPopulateAccessibilityEventEvent | [dispatchPopulateAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#dispatchPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent) |\n| OnInitializeAccessibilityEventEvent | [onInitializeAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent) |\n| OnInitializeAccessibilityNodeInfoEvent | [onInitializeAccessibilityNodeInfo](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityNodeInfo(android.view.View, android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) |\n| OnPopulateAccessibilityEventEvent | [onPopulateAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent) |\n| OnRequestSendAccessibilityEventEvent | [onRequestSendAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onRequestSendAccessibilityEvent(android.view.ViewGroup, android.view.View, android.view.accessibility.AccessibilityEvent) |\n| PerformAccessibilityActionEvent | [performAccessibilityAction](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#performAccessibilityAction(android.view.View, int, android.os.Bundle) |\n| SendAccessibilityEventEvent | [sendAccessibilityEvent](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEvent(android.view.View, int) |\n| SendAccessibilityUncheckedEvent | [sendAccessibilityEventUnchecked](https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEventUnchecked(android.view.View, android.view.accessibility.AccessibilityEvent) |\n\n设置任何这些事件的处理程序将会导致在挂载的View中设置AccessibilityDelegate，当调用相应的方法时，它将调用您的事件处理程序。\n\n如果你没有提供处理程序的方法被调用,delegate将会交由ANdroid view的默认实现去处理(类似于调用了super或者superDelegate的实现).\n\n举例来说,下面是覆写Component中onInitializeAccessibilityNodeInfo的步骤:\n1.实现一个事件处理器:\n``` java\n@OnEvent(OnInitializeAccessiblityNodeInfoEvent.class)\nstatic void onInitializeAccessibilityNodeInfoEvent(\n    @FromEvent AccessibilityDelegateCompat superDelegate,\n    @FromEvent View view,\n    @FromEvent AccessibilityNodeInfoCompat node) {\n  // Equivalent to calling super on a regular AccessibilityDelegate, not required\n  superDelegate.onInitializeAccessibilityNodeInfo(view, node);\n  // My implementation\n}\n```\n\n2.把时间处理器设置到component中.\n``` java\nText.create(c)\n    .text(title)\n    .withLayout()\n    .onInitializeAccessiblityNodeInfoHandler(MyComponent.onInitializeAccessibilityNodeInfoEvent(c))\n```\n\nAccessibilityDelegates的一个最好的特性之一就是它的甚至可以跨越视图的可重用性.而在Litho中,这也可以通过在Component中引入一个包含我们需要的事件处理器的包装spec来实现.例如.假设我们需要一个Component,它添加了\"please\"到了每一个它注释的AccessibilityEvent方法中.\n\n``` java\n@LayoutSpec\nclass PoliteComponentWrapper {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop Component<?> content) {\n      \n    return Layout.create(c, content)\n        .onPopulateAccessibilityEventHandler(\n            PoliteComponentWrapper.onPopulateAccessibilityEvent(c))\n        .build();\n  }\n\n  @OnEvent(OnPopulateAccessibilityEvent.class)\n  static void onPopulateAccessibilityEvent(\n      ComponentContext c,\n      @FromEvent AccessibilityDelegateCompat superDelegate,\n      @FromEvent View view\n      @FromEvent AccessibilityEvent event) {\n    superDelegate.onPopulateAccessibilityEvent(view, event);\n    event.getText().add(\"please\");\n  }\n}\n```\n\n现在你可以使用PoliteComponentWrapper来替代任何你原来使用你的Component的地方了.\n\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @Prop CharSequence text) {\n    \n  return PoliteComponentWrapper.create(c)\n      .content(\n           Text.create(c)\n               .text(text))\n      .build();\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-无障碍环境","published":1,"updated":"2017-05-11T09:29:34.147Z","_id":"cj2k76hrf002hssrl73vsx686","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/accessibility\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><h3 id=\"无障碍环境\"><a href=\"#无障碍环境\" class=\"headerlink\" title=\"无障碍环境\"></a>无障碍环境</h3><p></p><br><p></p><p></p>\n<h4 id=\"内容描述\"><a href=\"#内容描述\" class=\"headerlink\" title=\"内容描述\"></a>内容描述</h4><hr>\n<p>所有的Component都默认支持内容描述.这意味着所有的布局builder都拥有一个CharSequence类型的prop叫做contentDescription.</p>\n<p>在任何component上设置内容描述都非常的简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Image.create(c)</div><div class=\"line\">    .imageRes(R.drawable.some_image)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .contentDescription(<span class=\"string\">\"This is an image\"</span>)</div><div class=\"line\">    .build())</div></pre></td></tr></table></figure>\n<p>在这里设置的内容描述与在Android view上设置的内容描述拥有同等的效果.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><hr>\n<p>在Mount Spec可以通过实现一个@OnPopulateAccessibilityNode方法来实现自定义的无障碍支持.这个方法接受一个AccessibilityNodeInfoCompat参数,也接受任何在其他spec方法中指定的prop参数.</p>\n<p>举例来说,Text的无障碍功能是使用下列方法指定的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnPopulateAccessibilityNode</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPopulateAccessibilityNode</span><span class=\"params\">(</span></span></div><div class=\"line\">    AccessibilityNodeInfoCompat accessibilityNode,</div><div class=\"line\">    @Prop CharSequence text) &#123;</div><div class=\"line\">  accessibilityNode.setText(text);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这仅适用于挂载drawable的Component,因为如果Component挂载一个view,则无障碍支持就是内置的了.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"额外的无障碍节点\"><a href=\"#额外的无障碍节点\" class=\"headerlink\" title=\"额外的无障碍节点\"></a>额外的无障碍节点</h4><hr>\n<p>如果是在更复杂的需要暴露更多额外的node给无障碍框架的mount spec中,你就必须使用以下的注释实现3个额外的方法:</p>\n<ul>\n<li>GetExtraAccessibilityNodesCount:返回Component暴露出的外的无障碍节点的个数.</li>\n<li>OnpopulateExtraAccessibilityNode:使用给定的边界填充额外的无障碍节点.</li>\n<li>GetExtraVirtualViewAt:返回Component中指定位置的额外无障碍节点的索引.</li>\n<li><p></p><br><p></p></li>\n</ul>\n<h4 id=\"无障碍的处理\"><a href=\"#无障碍的处理\" class=\"headerlink\" title=\"无障碍的处理\"></a>无障碍的处理</h4><hr>\n<p>所有的Component都支持一系列与<a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html\" target=\"_blank\" rel=\"external\">AccessibilityDelegateCompat</a>方法相一致的事件.<br>这些事件拥有它们对应的AccessibilityDelegateCompat方法的参数,和一个额外的名叫superDelegate的AccessibilityDelegateCompat参数,它允许你在必要的时候显式的调用View的无障碍方法的默认实现.</p>\n<p>以下是支持的事件的总览:</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>ACCESSIBILITYDELEGATE方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DispatchPopulateAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#dispatchPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent\" target=\"_blank\" rel=\"external\">dispatchPopulateAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>OnInitializeAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent\" target=\"_blank\" rel=\"external\">onInitializeAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>OnInitializeAccessibilityNodeInfoEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityNodeInfo(android.view.View, android.support.v4.view.accessibility.AccessibilityNodeInfoCompat\" target=\"_blank\" rel=\"external\">onInitializeAccessibilityNodeInfo</a></td>\n</tr>\n<tr>\n<td>OnPopulateAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent\" target=\"_blank\" rel=\"external\">onPopulateAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>OnRequestSendAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onRequestSendAccessibilityEvent(android.view.ViewGroup, android.view.View, android.view.accessibility.AccessibilityEvent\" target=\"_blank\" rel=\"external\">onRequestSendAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>PerformAccessibilityActionEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#performAccessibilityAction(android.view.View, int, android.os.Bundle\" target=\"_blank\" rel=\"external\">performAccessibilityAction</a></td>\n</tr>\n<tr>\n<td>SendAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEvent(android.view.View, int\" target=\"_blank\" rel=\"external\">sendAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>SendAccessibilityUncheckedEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEventUnchecked(android.view.View, android.view.accessibility.AccessibilityEvent\" target=\"_blank\" rel=\"external\">sendAccessibilityEventUnchecked</a></td>\n</tr>\n</tbody>\n</table>\n<p>设置任何这些事件的处理程序将会导致在挂载的View中设置AccessibilityDelegate，当调用相应的方法时，它将调用您的事件处理程序。</p>\n<p>如果你没有提供处理程序的方法被调用,delegate将会交由ANdroid view的默认实现去处理(类似于调用了super或者superDelegate的实现).</p>\n<p>举例来说,下面是覆写Component中onInitializeAccessibilityNodeInfo的步骤:<br>1.实现一个事件处理器:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnEvent</span>(OnInitializeAccessiblityNodeInfoEvent.class)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onInitializeAccessibilityNodeInfoEvent</span><span class=\"params\">(</span></span></div><div class=\"line\">    @FromEvent AccessibilityDelegateCompat superDelegate,</div><div class=\"line\">    @FromEvent View view,</div><div class=\"line\">    @FromEvent AccessibilityNodeInfoCompat node) &#123;</div><div class=\"line\">  <span class=\"comment\">// Equivalent to calling super on a regular AccessibilityDelegate, not required</span></div><div class=\"line\">  superDelegate.onInitializeAccessibilityNodeInfo(view, node);</div><div class=\"line\">  <span class=\"comment\">// My implementation</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2.把时间处理器设置到component中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .onInitializeAccessiblityNodeInfoHandler(MyComponent.onInitializeAccessibilityNodeInfoEvent(c))</div></pre></td></tr></table></figure></p>\n<p>AccessibilityDelegates的一个最好的特性之一就是它的甚至可以跨越视图的可重用性.而在Litho中,这也可以通过在Component中引入一个包含我们需要的事件处理器的包装spec来实现.例如.假设我们需要一个Component,它添加了”please”到了每一个它注释的AccessibilityEvent方法中.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoliteComponentWrapper</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop Component&lt;?&gt; content) &#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Layout.create(c, content)</div><div class=\"line\">        .onPopulateAccessibilityEventHandler(</div><div class=\"line\">            PoliteComponentWrapper.onPopulateAccessibilityEvent(c))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(OnPopulateAccessibilityEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPopulateAccessibilityEvent</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @FromEvent AccessibilityDelegateCompat superDelegate,</div><div class=\"line\">      @FromEvent View view</div><div class=\"line\">      @FromEvent AccessibilityEvent event) &#123;</div><div class=\"line\">    superDelegate.onPopulateAccessibilityEvent(view, event);</div><div class=\"line\">    event.getText().add(<span class=\"string\">\"please\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在你可以使用PoliteComponentWrapper来替代任何你原来使用你的Component的地方了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @Prop CharSequence text) &#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> PoliteComponentWrapper.create(c)</div><div class=\"line\">      .content(</div><div class=\"line\">           Text.create(c)</div><div class=\"line\">               .text(text))</div><div class=\"line\">      .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/accessibility\">Litho-doc</a></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><h3 id=\"无障碍环境\"><a href=\"#无障碍环境\" class=\"headerlink\" title=\"无障碍环境\"></a>无障碍环境</h3><p></p><br></p></p>\n<h4 id=\"内容描述\"><a href=\"#内容描述\" class=\"headerlink\" title=\"内容描述\"></a>内容描述</h4><hr>\n<p>所有的Component都默认支持内容描述.这意味着所有的布局builder都拥有一个CharSequence类型的prop叫做contentDescription.</p>\n<p>在任何component上设置内容描述都非常的简单:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Image.create(c)</div><div class=\"line\">    .imageRes(R.drawable.some_image)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .contentDescription(<span class=\"string\">\"This is an image\"</span>)</div><div class=\"line\">    .build())</div></pre></td></tr></table></figure>\n<p>在这里设置的内容描述与在Android view上设置的内容描述拥有同等的效果.</p>\n<p></p><br></p></p>\n<h4 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h4><hr>\n<p>在Mount Spec可以通过实现一个@OnPopulateAccessibilityNode方法来实现自定义的无障碍支持.这个方法接受一个AccessibilityNodeInfoCompat参数,也接受任何在其他spec方法中指定的prop参数.</p>\n<p>举例来说,Text的无障碍功能是使用下列方法指定的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnPopulateAccessibilityNode</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPopulateAccessibilityNode</span><span class=\"params\">(</div><div class=\"line\">    AccessibilityNodeInfoCompat accessibilityNode,</div><div class=\"line\">    @Prop CharSequence text)</span> </span>&#123;</div><div class=\"line\">  accessibilityNode.setText(text);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这仅适用于挂载drawable的Component,因为如果Component挂载一个view,则无障碍支持就是内置的了.</p>\n<p></p><br></p></p>\n<h4 id=\"额外的无障碍节点\"><a href=\"#额外的无障碍节点\" class=\"headerlink\" title=\"额外的无障碍节点\"></a>额外的无障碍节点</h4><hr>\n<p>如果是在更复杂的需要暴露更多额外的node给无障碍框架的mount spec中,你就必须使用以下的注释实现3个额外的方法:</p>\n<ul>\n<li>GetExtraAccessibilityNodesCount:返回Component暴露出的外的无障碍节点的个数.</li>\n<li>OnpopulateExtraAccessibilityNode:使用给定的边界填充额外的无障碍节点.</li>\n<li>GetExtraVirtualViewAt:返回Component中指定位置的额外无障碍节点的索引.</li>\n<li></p><br></p></li>\n</ul>\n<h4 id=\"无障碍的处理\"><a href=\"#无障碍的处理\" class=\"headerlink\" title=\"无障碍的处理\"></a>无障碍的处理</h4><hr>\n<p>所有的Component都支持一系列与<a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html\">AccessibilityDelegateCompat</a>方法相一致的事件.<br>这些事件拥有它们对应的AccessibilityDelegateCompat方法的参数,和一个额外的名叫superDelegate的AccessibilityDelegateCompat参数,它允许你在必要的时候显式的调用View的无障碍方法的默认实现.</p>\n<p>以下是支持的事件的总览:</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>ACCESSIBILITYDELEGATE方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DispatchPopulateAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#dispatchPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent\">dispatchPopulateAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>OnInitializeAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent\">onInitializeAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>OnInitializeAccessibilityNodeInfoEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onInitializeAccessibilityNodeInfo(android.view.View, android.support.v4.view.accessibility.AccessibilityNodeInfoCompat\">onInitializeAccessibilityNodeInfo</a></td>\n</tr>\n<tr>\n<td>OnPopulateAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onPopulateAccessibilityEvent(android.view.View, android.view.accessibility.AccessibilityEvent\">onPopulateAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>OnRequestSendAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#onRequestSendAccessibilityEvent(android.view.ViewGroup, android.view.View, android.view.accessibility.AccessibilityEvent\">onRequestSendAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>PerformAccessibilityActionEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#performAccessibilityAction(android.view.View, int, android.os.Bundle\">performAccessibilityAction</a></td>\n</tr>\n<tr>\n<td>SendAccessibilityEventEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEvent(android.view.View, int\">sendAccessibilityEvent</a></td>\n</tr>\n<tr>\n<td>SendAccessibilityUncheckedEvent</td>\n<td><a href=\"https://developer.android.com/reference/android/support/v4/view/AccessibilityDelegateCompat.html#sendAccessibilityEventUnchecked(android.view.View, android.view.accessibility.AccessibilityEvent\">sendAccessibilityEventUnchecked</a></td>\n</tr>\n</tbody>\n</table>\n<p>设置任何这些事件的处理程序将会导致在挂载的View中设置AccessibilityDelegate，当调用相应的方法时，它将调用您的事件处理程序。</p>\n<p>如果你没有提供处理程序的方法被调用,delegate将会交由ANdroid view的默认实现去处理(类似于调用了super或者superDelegate的实现).</p>\n<p>举例来说,下面是覆写Component中onInitializeAccessibilityNodeInfo的步骤:<br>1.实现一个事件处理器:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnEvent</span>(OnInitializeAccessiblityNodeInfoEvent.class)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onInitializeAccessibilityNodeInfoEvent</span><span class=\"params\">(</div><div class=\"line\">    @FromEvent AccessibilityDelegateCompat superDelegate,</div><div class=\"line\">    @FromEvent View view,</div><div class=\"line\">    @FromEvent AccessibilityNodeInfoCompat node)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Equivalent to calling super on a regular AccessibilityDelegate, not required</span></div><div class=\"line\">  superDelegate.onInitializeAccessibilityNodeInfo(view, node);</div><div class=\"line\">  <span class=\"comment\">// My implementation</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2.把时间处理器设置到component中.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .onInitializeAccessiblityNodeInfoHandler(MyComponent.onInitializeAccessibilityNodeInfoEvent(c))</div></pre></td></tr></table></figure></p>\n<p>AccessibilityDelegates的一个最好的特性之一就是它的甚至可以跨越视图的可重用性.而在Litho中,这也可以通过在Component中引入一个包含我们需要的事件处理器的包装spec来实现.例如.假设我们需要一个Component,它添加了”please”到了每一个它注释的AccessibilityEvent方法中.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoliteComponentWrapper</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop Component&lt;?&gt; content)</span> </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> Layout.create(c, content)</div><div class=\"line\">        .onPopulateAccessibilityEventHandler(</div><div class=\"line\">            PoliteComponentWrapper.onPopulateAccessibilityEvent(c))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnEvent</span>(OnPopulateAccessibilityEvent.class)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPopulateAccessibilityEvent</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @FromEvent AccessibilityDelegateCompat superDelegate,</div><div class=\"line\">      @FromEvent View view</div><div class=\"line\">      @FromEvent AccessibilityEvent event)</span> </span>&#123;</div><div class=\"line\">    superDelegate.onPopulateAccessibilityEvent(view, event);</div><div class=\"line\">    event.getText().add(<span class=\"string\">\"please\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在你可以使用PoliteComponentWrapper来替代任何你原来使用你的Component的地方了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @Prop CharSequence text)</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> PoliteComponentWrapper.create(c)</div><div class=\"line\">      .content(</div><div class=\"line\">           Text.create(c)</div><div class=\"line\">               .text(text))</div><div class=\"line\">      .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-TreeProp","date":"2017-05-10T03:47:43.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/tree-props)\n## 进阶指引\n### TreeProp\n\n</p>\n</p>\n\n@TreeProp是那些自动并且静默的从父Component传递给子Component的[prop](https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/).\n\nTreeProp非常方便,它能够在一个布局树上分享上下文数据或者工具而又不需要显式的传递prop给每一个层级结构上的Component.\n\n预加载器就是一个很好的例子,它能够在渲染图片之前从网络上预抓取图片.由于图片在程序中非常常见,预加载器也被广泛的应用.我们可以不用@Prop把预加载器传递给整个布局树,而是把预加载器的实现定义给那些需要使用它的Component.\n\n</p>\n</p>\n\n#### 声明一个TreeProp\n---\n每一个TreeProp都是在一个被注释为@OnCreateTreeProp的方法中被声明和定义的.\n\n``` java\n@LayoutSpec\npublic class ParentComponentSpec {\n  @OnCreateTreeProp\n  static Prefetcher onCreatePrefetcher(\n      ComponentContext c,\n      @Prop Prefetcher prefetcher) {\n      \n    return prefetcher;\n  }\n  \n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop Uri imageUri) {\n      \n    return ChildComponent.create(c)\n        .imageUri(imageUri)\n        .buildWithLayout();\n  }\n}\n```\n\n你只能为任何给定类型声明一个@TreeProp.如果一个ParentComponent的子类也定义了一个Prefetcher类型的@TreeProp,它将会覆写它的所有子类的相应的@TreeProp值(但是不包括它自己的值).\n\n</p>\n</p>\n\n#### 使用一个TreeProp\n---\n孩子component可以使用@TreeProp注释来声明一个和父亲Component的@OnCreateTreeProp方法中同样类型的参数的方式来访问TreeProp的值.\n\n``` java\n@LayoutSpec\nclass ChildComponentSpec {\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext context,\n      @TreeProp Prefetcher prefetcher,\n      @Prop Uri imageUri) {\n    if (prefetcher != null) {\n      prefetcher.prefetch(imageUri);\n    }\n    ...\n  }\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-TreeProp.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-TreeProp\ndate: 2017-05-10 11:47:43\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/tree-props)\n## 进阶指引\n### TreeProp\n\n</p>\n</p>\n\n@TreeProp是那些自动并且静默的从父Component传递给子Component的[prop](https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/).\n\nTreeProp非常方便,它能够在一个布局树上分享上下文数据或者工具而又不需要显式的传递prop给每一个层级结构上的Component.\n\n预加载器就是一个很好的例子,它能够在渲染图片之前从网络上预抓取图片.由于图片在程序中非常常见,预加载器也被广泛的应用.我们可以不用@Prop把预加载器传递给整个布局树,而是把预加载器的实现定义给那些需要使用它的Component.\n\n</p>\n</p>\n\n#### 声明一个TreeProp\n---\n每一个TreeProp都是在一个被注释为@OnCreateTreeProp的方法中被声明和定义的.\n\n``` java\n@LayoutSpec\npublic class ParentComponentSpec {\n  @OnCreateTreeProp\n  static Prefetcher onCreatePrefetcher(\n      ComponentContext c,\n      @Prop Prefetcher prefetcher) {\n      \n    return prefetcher;\n  }\n  \n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop Uri imageUri) {\n      \n    return ChildComponent.create(c)\n        .imageUri(imageUri)\n        .buildWithLayout();\n  }\n}\n```\n\n你只能为任何给定类型声明一个@TreeProp.如果一个ParentComponent的子类也定义了一个Prefetcher类型的@TreeProp,它将会覆写它的所有子类的相应的@TreeProp值(但是不包括它自己的值).\n\n</p>\n</p>\n\n#### 使用一个TreeProp\n---\n孩子component可以使用@TreeProp注释来声明一个和父亲Component的@OnCreateTreeProp方法中同样类型的参数的方式来访问TreeProp的值.\n\n``` java\n@LayoutSpec\nclass ChildComponentSpec {\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext context,\n      @TreeProp Prefetcher prefetcher,\n      @Prop Uri imageUri) {\n    if (prefetcher != null) {\n      prefetcher.prefetch(imageUri);\n    }\n    ...\n  }\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-TreeProp","published":1,"updated":"2017-05-11T09:31:29.725Z","_id":"cj2k76hri002kssrl1mb3s27h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/tree-props\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"TreeProp\"><a href=\"#TreeProp\" class=\"headerlink\" title=\"TreeProp\"></a>TreeProp</h3><p></p><br><p></p><p></p>\n<p>@TreeProp是那些自动并且静默的从父Component传递给子Component的<a href=\"https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/\">prop</a>.</p>\n<p>TreeProp非常方便,它能够在一个布局树上分享上下文数据或者工具而又不需要显式的传递prop给每一个层级结构上的Component.</p>\n<p>预加载器就是一个很好的例子,它能够在渲染图片之前从网络上预抓取图片.由于图片在程序中非常常见,预加载器也被广泛的应用.我们可以不用@Prop把预加载器传递给整个布局树,而是把预加载器的实现定义给那些需要使用它的Component.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"声明一个TreeProp\"><a href=\"#声明一个TreeProp\" class=\"headerlink\" title=\"声明一个TreeProp\"></a>声明一个TreeProp</h4><hr>\n<p>每一个TreeProp都是在一个被注释为@OnCreateTreeProp的方法中被声明和定义的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateTreeProp</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> Prefetcher <span class=\"title\">onCreatePrefetcher</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop Prefetcher prefetcher) &#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> prefetcher;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop Uri imageUri) &#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> ChildComponent.create(c)</div><div class=\"line\">        .imageUri(imageUri)</div><div class=\"line\">        .buildWithLayout();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你只能为任何给定类型声明一个@TreeProp.如果一个ParentComponent的子类也定义了一个Prefetcher类型的@TreeProp,它将会覆写它的所有子类的相应的@TreeProp值(但是不包括它自己的值).</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"使用一个TreeProp\"><a href=\"#使用一个TreeProp\" class=\"headerlink\" title=\"使用一个TreeProp\"></a>使用一个TreeProp</h4><hr>\n<p>孩子component可以使用@TreeProp注释来声明一个和父亲Component的@OnCreateTreeProp方法中同样类型的参数的方式来访问TreeProp的值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      @TreeProp Prefetcher prefetcher,</div><div class=\"line\">      @Prop Uri imageUri) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (prefetcher != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      prefetcher.prefetch(imageUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/tree-props\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"TreeProp\"><a href=\"#TreeProp\" class=\"headerlink\" title=\"TreeProp\"></a>TreeProp</h3><p></p><br></p></p>\n<p>@TreeProp是那些自动并且静默的从父Component传递给子Component的<a href=\"https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/\">prop</a>.</p>\n<p>TreeProp非常方便,它能够在一个布局树上分享上下文数据或者工具而又不需要显式的传递prop给每一个层级结构上的Component.</p>\n<p>预加载器就是一个很好的例子,它能够在渲染图片之前从网络上预抓取图片.由于图片在程序中非常常见,预加载器也被广泛的应用.我们可以不用@Prop把预加载器传递给整个布局树,而是把预加载器的实现定义给那些需要使用它的Component.</p>\n<p></p><br></p></p>\n<h4 id=\"声明一个TreeProp\"><a href=\"#声明一个TreeProp\" class=\"headerlink\" title=\"声明一个TreeProp\"></a>声明一个TreeProp</h4><hr>\n<p>每一个TreeProp都是在一个被注释为@OnCreateTreeProp的方法中被声明和定义的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateTreeProp</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> Prefetcher <span class=\"title\">onCreatePrefetcher</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop Prefetcher prefetcher)</span> </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> prefetcher;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop Uri imageUri)</span> </span>&#123;</div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">return</span> ChildComponent.create(c)</div><div class=\"line\">        .imageUri(imageUri)</div><div class=\"line\">        .buildWithLayout();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你只能为任何给定类型声明一个@TreeProp.如果一个ParentComponent的子类也定义了一个Prefetcher类型的@TreeProp,它将会覆写它的所有子类的相应的@TreeProp值(但是不包括它自己的值).</p>\n<p></p><br></p></p>\n<h4 id=\"使用一个TreeProp\"><a href=\"#使用一个TreeProp\" class=\"headerlink\" title=\"使用一个TreeProp\"></a>使用一个TreeProp</h4><hr>\n<p>孩子component可以使用@TreeProp注释来声明一个和父亲Component的@OnCreateTreeProp方法中同样类型的参数的方式来访问TreeProp的值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      @TreeProp Prefetcher prefetcher,</div><div class=\"line\">      @Prop Uri imageUri)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (prefetcher != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      prefetcher.prefetch(imageUri);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-创建一个ComponentTree","date":"2017-05-10T06:55:40.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/component-tree)\n## 进阶指引\n### 创建一个ComponentTree\n\n</p>\n</p>\n\n在[使用Component](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)指引中,我们看到了如何创建一个根Component并且把它传递给一个LithoView,接着LithoView将会处理使用给出的根Component创建[ComponentTree](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree)的其他步骤.ComponentTree会使用线程安全的方法来管理你的Component的生命周期,使得你可以在任何的线程中创建和使用它们.虽然通常你可以不需要去创建和管理你自己的ComponentTree,但是也有部分情况你需要自己去做.下面就会讲到是你应该如何创建一个ComponentTree,传递给它一个根Component,并且把它添加到一个LithoView中去.这个ComponentTree的create()方法会返回一个暴露出ComponentTree的设置方法的[Builder](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree.Builder).\n\n``` java\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    final LithoView lithoView = new LithoView(this);\n    final ComponentContext context = new ComponentContext(this);\n\n    final Component text = Text.create(context)\n        .text(\"Hello World\")\n        .textSizeDip(50)\n        .build();\n    final ComponentTree componentTree = ComponentTree.create(context, text).build();\n\n    lithoView.setComponentTree(componentTree);\n    setContentView(lithoView);\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","source":"_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-创建一个ComponentTree.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-创建一个ComponentTree\ndate: 2017-05-10 14:55:40\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/component-tree)\n## 进阶指引\n### 创建一个ComponentTree\n\n</p>\n</p>\n\n在[使用Component](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/)指引中,我们看到了如何创建一个根Component并且把它传递给一个LithoView,接着LithoView将会处理使用给出的根Component创建[ComponentTree](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree)的其他步骤.ComponentTree会使用线程安全的方法来管理你的Component的生命周期,使得你可以在任何的线程中创建和使用它们.虽然通常你可以不需要去创建和管理你自己的ComponentTree,但是也有部分情况你需要自己去做.下面就会讲到是你应该如何创建一个ComponentTree,传递给它一个根Component,并且把它添加到一个LithoView中去.这个ComponentTree的create()方法会返回一个暴露出ComponentTree的设置方法的[Builder](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree.Builder).\n\n``` java\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    final LithoView lithoView = new LithoView(this);\n    final ComponentContext context = new ComponentContext(this);\n\n    final Component text = Text.create(context)\n        .text(\"Hello World\")\n        .textSizeDip(50)\n        .build();\n    final ComponentTree componentTree = ComponentTree.create(context, text).build();\n\n    lithoView.setComponentTree(componentTree);\n    setContentView(lithoView);\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-创建一个ComponentTree","published":1,"updated":"2017-05-11T09:32:11.529Z","_id":"cj2k76hrj002ossrlqtc4vht4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/component-tree\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"创建一个ComponentTree\"><a href=\"#创建一个ComponentTree\" class=\"headerlink\" title=\"创建一个ComponentTree\"></a>创建一个ComponentTree</h3><p></p><br><p></p><p></p>\n<p>在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用Component</a>指引中,我们看到了如何创建一个根Component并且把它传递给一个LithoView,接着LithoView将会处理使用给出的根Component创建<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree\" target=\"_blank\" rel=\"external\">ComponentTree</a>的其他步骤.ComponentTree会使用线程安全的方法来管理你的Component的生命周期,使得你可以在任何的线程中创建和使用它们.虽然通常你可以不需要去创建和管理你自己的ComponentTree,但是也有部分情况你需要自己去做.下面就会讲到是你应该如何创建一个ComponentTree,传递给它一个根Component,并且把它添加到一个LithoView中去.这个ComponentTree的create()方法会返回一个暴露出ComponentTree的设置方法的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree.Builder\" target=\"_blank\" rel=\"external\">Builder</a>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> LithoView lithoView = <span class=\"keyword\">new</span> LithoView(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext context = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component text = Text.create(context)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">        .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">        .build();</div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentTree componentTree = ComponentTree.create(context, text).build();</div><div class=\"line\"></div><div class=\"line\">    lithoView.setComponentTree(componentTree);</div><div class=\"line\">    setContentView(lithoView);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/component-tree\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"创建一个ComponentTree\"><a href=\"#创建一个ComponentTree\" class=\"headerlink\" title=\"创建一个ComponentTree\"></a>创建一个ComponentTree</h3><p></p><br></p></p>\n<p>在<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Component/\">使用Component</a>指引中,我们看到了如何创建一个根Component并且把它传递给一个LithoView,接着LithoView将会处理使用给出的根Component创建<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree\">ComponentTree</a>的其他步骤.ComponentTree会使用线程安全的方法来管理你的Component的生命周期,使得你可以在任何的线程中创建和使用它们.虽然通常你可以不需要去创建和管理你自己的ComponentTree,但是也有部分情况你需要自己去做.下面就会讲到是你应该如何创建一个ComponentTree,传递给它一个根Component,并且把它添加到一个LithoView中去.这个ComponentTree的create()方法会返回一个暴露出ComponentTree的设置方法的<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree.Builder\">Builder</a>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> LithoView lithoView = <span class=\"keyword\">new</span> LithoView(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext context = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component text = Text.create(context)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">        .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">        .build();</div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentTree componentTree = ComponentTree.create(context, text).build();</div><div class=\"line\"></div><div class=\"line\">    lithoView.setComponentTree(componentTree);</div><div class=\"line\">    setContentView(lithoView);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载","date":"2017-05-10T06:37:16.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/inc-mount)\n## 进阶指引\n### 增量式挂载\n\n</p>\n</p>\n\n#### 手动增量式挂载\n---\n\n如果你没有使用[Recycler](http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler),你也仍然可以集成[增量式挂载](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)到你的现有的UI实现里.你必须在每次LithoView的可见区域发生变化的时候显式的通知框架,通过调用:\n\n``` java\nmyLithoView.performIncrementalMount();\n```\n\n举例来说,如果你在ListView中使用Component,你可以在一个OnScrollListener中调用performIncrementalMount().\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","source":"_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-手动增量式挂载.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-增量式挂载\ndate: 2017-05-10 14:37:16\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/inc-mount)\n## 进阶指引\n### 增量式挂载\n\n</p>\n</p>\n\n#### 手动增量式挂载\n---\n\n如果你没有使用[Recycler](http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler),你也仍然可以集成[增量式挂载](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/)到你的现有的UI实现里.你必须在每次LithoView的可见区域发生变化的时候显式的通知框架,通过调用:\n\n``` java\nmyLithoView.performIncrementalMount();\n```\n\n举例来说,如果你在ListView中使用Component,你可以在一个OnScrollListener中调用performIncrementalMount().\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-手动增量式挂载","published":1,"updated":"2017-05-11T09:31:50.744Z","_id":"cj2k76hrk002rssrlhw0j3l9i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/inc-mount\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a>增量式挂载</h3><p></p><br><p></p><p></p>\n<h4 id=\"手动增量式挂载\"><a href=\"#手动增量式挂载\" class=\"headerlink\" title=\"手动增量式挂载\"></a>手动增量式挂载</h4><hr>\n<p>如果你没有使用<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler\" target=\"_blank\" rel=\"external\">Recycler</a>,你也仍然可以集成<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载</a>到你的现有的UI实现里.你必须在每次LithoView的可见区域发生变化的时候显式的通知框架,通过调用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">myLithoView.performIncrementalMount();</div></pre></td></tr></table></figure>\n<p>举例来说,如果你在ListView中使用Component,你可以在一个OnScrollListener中调用performIncrementalMount().</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/inc-mount\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a>增量式挂载</h3><p></p><br></p></p>\n<h4 id=\"手动增量式挂载\"><a href=\"#手动增量式挂载\" class=\"headerlink\" title=\"手动增量式挂载\"></a>手动增量式挂载</h4><hr>\n<p>如果你没有使用<a href=\"http://fblitho.com/javadoc/com/facebook/litho/widget/Recycler\">Recycler</a>,你也仍然可以集成<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8C%82%E8%BD%BD/\">增量式挂载</a>到你的现有的UI实现里.你必须在每次LithoView的可见区域发生变化的时候显式的通知框架,通过调用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">myLithoView.performIncrementalMount();</div></pre></td></tr></table></figure>\n<p>举例来说,如果你在ListView中使用Component,你可以在一个OnScrollListener中调用performIncrementalMount().</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-最佳实践","date":"2017-05-10T08:23:58.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/best-practices)\n## 最佳实践\n\n</p>\n</p>\n\n#### 编码风格\n---\n指引:\n- 使用NAMEComponentSpec命名你的Spec来生成一个名叫NAMEComponent的Component.\n- ComponentContext参数应该被命名为c,这样能避免你的布局代码变得冗长并且能够使它变得可读性更强.\n- 在适当的地方使用资源类型(ResType.STRING, ResType.COLOR, ResType.DIMEN_SIZE等等)能够让用Android资源设置prop变得更简单.\n- 先定义所有必须的prop然后再定义可选的prop(optional=ture).\n- 使用静态导入所有的enum(YogaEdge,YogaAlign,YogaJustify等等)来减少你的布局代码,并使其变得可读性更强.\n- 对withLayout()下的prop不使用额外的缩进等级\n- 生命周期方法,例如@OnCreateLayout,是静态的并且对包外对象是私有的.\n- 如果可能的话,对可选的孩子Component使用内联选项,这样能使你的布局结构变得更加流畅.\n- 如果你正在构建一个孩子容器,在下一行添加该容器.这使布局代码显得更加结构化.\n\n使用推荐编码风格编码的实例代码如下:\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop(resType = STRING) String title,\n      @Prop(optional = true) Drawable image) {\n\n  return Row.create(c)\n      .alignItems(CENTER)\n      .paddingRes(R.dimen.some_dimen)\n      .child(\n          Image.create(c)\n              .drawable(image)\n              .withLayout()\n              .width(40)\n              .height(40)\n              .marginRes(RIGHT, R.dimen.my_margin))\n      .child(TextUtils.isEmpty(title) ? null :\n          Text.create(c)\n              .text(title)\n              .textColorAttr(R.attr.textColorTertiary)\n              .withLayout()\n              .marginDip(5)\n              .flexGrow(1f))\n      .build();\n  }\n}\n```\n</p>\n</p>\n\n#### Prop vs State\n---\nLitho Component一共有两种类型的数据模型:[Prop](https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/)和[State](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/).在你需要使用它们的时候,明白两种模型的差别是非常重要的.\n\nProp的作用是在树中把数据从Component传递给它的孩子们.Prop在定义一个Component模型的静态部分中是非常有用的,因为Prop是不可变的.\n\nState主要是用于处理那些与Component交互产生的更新或者那些只能被Component拦截到的更新.State是由组件自己管理的并且从外部是不可见的,Component的父级完全不知道它孩子的State的信息.\n\n以下是关于如何决定对Component中的某些数据是采用prop还是State的简要介绍:\n- 数据是否定义了一个属性并且值会保持不变?如果是,则它应该是一个Prop.\n- 数据是否应该由父级定义并且传递下来?如果是,则它应该是一个Prop.\n- 它是否应该在用户与这个Component交互后改变它的值(例如点击)?如果是,它应该是一个State.\n- 你是否能够通过其他已有的Prop和State的值来计算出它的值?如果是,你就不应该使用State.\n\n比起使用由上至下传递的Prop的方式,使用更多State的方式会让你的应用程序的复杂度升高,变得更加难以维护和更加难以推导出数据流.你应该尝试控制你的Compoennt中的State在最小的数量并且保持的数据流是从上到下的.如果你有多个兄弟Component并且他们的State是互相依赖的,这时你应该确定一个父级Component来替代孩子们持有并且管理它们的state.\n\n让我们举个拥有单选按钮的列表的例子,列表中不能同时选中多个项.列表中所有的单选按钮的state都取决于其他项被点击和选中的状态.比起让所有的单选按钮都使用state,你应该在父Component中持有\"哪一个列表项被点击\"的state,并且通过prop从上而下的把这个信息传递给它的孩子们.\n\n</p>\n</p>\n\n#### 不可变性\n---\n\nComponent本质上是一系列方法的集合,数据通过不可变的参数的方式传递给这些方法.当Component的prop或者state更新后,框架将会使用更新后的信息创建一个新的Component实例,因为先前的Component是不能改变的.\n\n虽然Component本身是不可变的,但是使用可变的对象来表示prop和state很容易就会使Component变得线程不安全.Litho[在后台线程中计算布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/),如果构成Component的Prop或者State的对象在另一个线程中被改变了,将会导致同样的Component渲染出不一样的效果.\n\n你必须保证你的prop和state是使用天生不可变的原始类型,如果做不到的话,也必须确保你使用的对象是不可变的.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-最佳实践.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-最佳实践\ndate: 2017-05-10 16:23:58\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/best-practices)\n## 最佳实践\n\n</p>\n</p>\n\n#### 编码风格\n---\n指引:\n- 使用NAMEComponentSpec命名你的Spec来生成一个名叫NAMEComponent的Component.\n- ComponentContext参数应该被命名为c,这样能避免你的布局代码变得冗长并且能够使它变得可读性更强.\n- 在适当的地方使用资源类型(ResType.STRING, ResType.COLOR, ResType.DIMEN_SIZE等等)能够让用Android资源设置prop变得更简单.\n- 先定义所有必须的prop然后再定义可选的prop(optional=ture).\n- 使用静态导入所有的enum(YogaEdge,YogaAlign,YogaJustify等等)来减少你的布局代码,并使其变得可读性更强.\n- 对withLayout()下的prop不使用额外的缩进等级\n- 生命周期方法,例如@OnCreateLayout,是静态的并且对包外对象是私有的.\n- 如果可能的话,对可选的孩子Component使用内联选项,这样能使你的布局结构变得更加流畅.\n- 如果你正在构建一个孩子容器,在下一行添加该容器.这使布局代码显得更加结构化.\n\n使用推荐编码风格编码的实例代码如下:\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop(resType = STRING) String title,\n      @Prop(optional = true) Drawable image) {\n\n  return Row.create(c)\n      .alignItems(CENTER)\n      .paddingRes(R.dimen.some_dimen)\n      .child(\n          Image.create(c)\n              .drawable(image)\n              .withLayout()\n              .width(40)\n              .height(40)\n              .marginRes(RIGHT, R.dimen.my_margin))\n      .child(TextUtils.isEmpty(title) ? null :\n          Text.create(c)\n              .text(title)\n              .textColorAttr(R.attr.textColorTertiary)\n              .withLayout()\n              .marginDip(5)\n              .flexGrow(1f))\n      .build();\n  }\n}\n```\n</p>\n</p>\n\n#### Prop vs State\n---\nLitho Component一共有两种类型的数据模型:[Prop](https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/)和[State](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/).在你需要使用它们的时候,明白两种模型的差别是非常重要的.\n\nProp的作用是在树中把数据从Component传递给它的孩子们.Prop在定义一个Component模型的静态部分中是非常有用的,因为Prop是不可变的.\n\nState主要是用于处理那些与Component交互产生的更新或者那些只能被Component拦截到的更新.State是由组件自己管理的并且从外部是不可见的,Component的父级完全不知道它孩子的State的信息.\n\n以下是关于如何决定对Component中的某些数据是采用prop还是State的简要介绍:\n- 数据是否定义了一个属性并且值会保持不变?如果是,则它应该是一个Prop.\n- 数据是否应该由父级定义并且传递下来?如果是,则它应该是一个Prop.\n- 它是否应该在用户与这个Component交互后改变它的值(例如点击)?如果是,它应该是一个State.\n- 你是否能够通过其他已有的Prop和State的值来计算出它的值?如果是,你就不应该使用State.\n\n比起使用由上至下传递的Prop的方式,使用更多State的方式会让你的应用程序的复杂度升高,变得更加难以维护和更加难以推导出数据流.你应该尝试控制你的Compoennt中的State在最小的数量并且保持的数据流是从上到下的.如果你有多个兄弟Component并且他们的State是互相依赖的,这时你应该确定一个父级Component来替代孩子们持有并且管理它们的state.\n\n让我们举个拥有单选按钮的列表的例子,列表中不能同时选中多个项.列表中所有的单选按钮的state都取决于其他项被点击和选中的状态.比起让所有的单选按钮都使用state,你应该在父Component中持有\"哪一个列表项被点击\"的state,并且通过prop从上而下的把这个信息传递给它的孩子们.\n\n</p>\n</p>\n\n#### 不可变性\n---\n\nComponent本质上是一系列方法的集合,数据通过不可变的参数的方式传递给这些方法.当Component的prop或者state更新后,框架将会使用更新后的信息创建一个新的Component实例,因为先前的Component是不能改变的.\n\n虽然Component本身是不可变的,但是使用可变的对象来表示prop和state很容易就会使Component变得线程不安全.Litho[在后台线程中计算布局](https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/),如果构成Component的Prop或者State的对象在另一个线程中被改变了,将会导致同样的Component渲染出不一样的效果.\n\n你必须保证你的prop和state是使用天生不可变的原始类型,如果做不到的话,也必须确保你使用的对象是不可变的.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-最佳实践","published":1,"updated":"2017-05-11T09:34:30.954Z","_id":"cj2k76hrl002vssrlzk88sgtk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/best-practices\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><p></p><br><p></p><p></p>\n<h4 id=\"编码风格\"><a href=\"#编码风格\" class=\"headerlink\" title=\"编码风格\"></a>编码风格</h4><hr>\n<p>指引:</p>\n<ul>\n<li>使用NAMEComponentSpec命名你的Spec来生成一个名叫NAMEComponent的Component.</li>\n<li>ComponentContext参数应该被命名为c,这样能避免你的布局代码变得冗长并且能够使它变得可读性更强.</li>\n<li>在适当的地方使用资源类型(ResType.STRING, ResType.COLOR, ResType.DIMEN_SIZE等等)能够让用Android资源设置prop变得更简单.</li>\n<li>先定义所有必须的prop然后再定义可选的prop(optional=ture).</li>\n<li>使用静态导入所有的enum(YogaEdge,YogaAlign,YogaJustify等等)来减少你的布局代码,并使其变得可读性更强.</li>\n<li>对withLayout()下的prop不使用额外的缩进等级</li>\n<li>生命周期方法,例如@OnCreateLayout,是静态的并且对包外对象是私有的.</li>\n<li>如果可能的话,对可选的孩子Component使用内联选项,这样能使你的布局结构变得更加流畅.</li>\n<li>如果你正在构建一个孩子容器,在下一行添加该容器.这使布局代码显得更加结构化.</li>\n</ul>\n<p>使用推荐编码风格编码的实例代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop(resType = STRING) String title,</div><div class=\"line\">      @<span class=\"title\">Prop</span><span class=\"params\">(optional = <span class=\"keyword\">true</span>)</span> Drawable image) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">      .alignItems(CENTER)</div><div class=\"line\">      .paddingRes(R.dimen.some_dimen)</div><div class=\"line\">      .child(</div><div class=\"line\">          Image.create(c)</div><div class=\"line\">              .drawable(image)</div><div class=\"line\">              .withLayout()</div><div class=\"line\">              .width(<span class=\"number\">40</span>)</div><div class=\"line\">              .height(<span class=\"number\">40</span>)</div><div class=\"line\">              .marginRes(RIGHT, R.dimen.my_margin))</div><div class=\"line\">      .child(TextUtils.isEmpty(title) ? <span class=\"keyword\">null</span> :</div><div class=\"line\">          Text.create(c)</div><div class=\"line\">              .text(title)</div><div class=\"line\">              .textColorAttr(R.attr.textColorTertiary)</div><div class=\"line\">              .withLayout()</div><div class=\"line\">              .marginDip(<span class=\"number\">5</span>)</div><div class=\"line\">              .flexGrow(<span class=\"number\">1f</span>))</div><div class=\"line\">      .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"Prop-vs-State\"><a href=\"#Prop-vs-State\" class=\"headerlink\" title=\"Prop vs State\"></a>Prop vs State</h4><hr>\n<p>Litho Component一共有两种类型的数据模型:<a href=\"https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/\">Prop</a>和<a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/\">State</a>.在你需要使用它们的时候,明白两种模型的差别是非常重要的.</p>\n<p>Prop的作用是在树中把数据从Component传递给它的孩子们.Prop在定义一个Component模型的静态部分中是非常有用的,因为Prop是不可变的.</p>\n<p>State主要是用于处理那些与Component交互产生的更新或者那些只能被Component拦截到的更新.State是由组件自己管理的并且从外部是不可见的,Component的父级完全不知道它孩子的State的信息.</p>\n<p>以下是关于如何决定对Component中的某些数据是采用prop还是State的简要介绍:</p>\n<ul>\n<li>数据是否定义了一个属性并且值会保持不变?如果是,则它应该是一个Prop.</li>\n<li>数据是否应该由父级定义并且传递下来?如果是,则它应该是一个Prop.</li>\n<li>它是否应该在用户与这个Component交互后改变它的值(例如点击)?如果是,它应该是一个State.</li>\n<li>你是否能够通过其他已有的Prop和State的值来计算出它的值?如果是,你就不应该使用State.</li>\n</ul>\n<p>比起使用由上至下传递的Prop的方式,使用更多State的方式会让你的应用程序的复杂度升高,变得更加难以维护和更加难以推导出数据流.你应该尝试控制你的Compoennt中的State在最小的数量并且保持的数据流是从上到下的.如果你有多个兄弟Component并且他们的State是互相依赖的,这时你应该确定一个父级Component来替代孩子们持有并且管理它们的state.</p>\n<p>让我们举个拥有单选按钮的列表的例子,列表中不能同时选中多个项.列表中所有的单选按钮的state都取决于其他项被点击和选中的状态.比起让所有的单选按钮都使用state,你应该在父Component中持有”哪一个列表项被点击”的state,并且通过prop从上而下的把这个信息传递给它的孩子们.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><hr>\n<p>Component本质上是一系列方法的集合,数据通过不可变的参数的方式传递给这些方法.当Component的prop或者state更新后,框架将会使用更新后的信息创建一个新的Component实例,因为先前的Component是不能改变的.</p>\n<p>虽然Component本身是不可变的,但是使用可变的对象来表示prop和state很容易就会使Component变得线程不安全.Litho<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">在后台线程中计算布局</a>,如果构成Component的Prop或者State的对象在另一个线程中被改变了,将会导致同样的Component渲染出不一样的效果.</p>\n<p>你必须保证你的prop和state是使用天生不可变的原始类型,如果做不到的话,也必须确保你使用的对象是不可变的.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/best-practices\">Litho-doc</a></p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><p></p><br></p></p>\n<h4 id=\"编码风格\"><a href=\"#编码风格\" class=\"headerlink\" title=\"编码风格\"></a>编码风格</h4><hr>\n<p>指引:</p>\n<ul>\n<li>使用NAMEComponentSpec命名你的Spec来生成一个名叫NAMEComponent的Component.</li>\n<li>ComponentContext参数应该被命名为c,这样能避免你的布局代码变得冗长并且能够使它变得可读性更强.</li>\n<li>在适当的地方使用资源类型(ResType.STRING, ResType.COLOR, ResType.DIMEN_SIZE等等)能够让用Android资源设置prop变得更简单.</li>\n<li>先定义所有必须的prop然后再定义可选的prop(optional=ture).</li>\n<li>使用静态导入所有的enum(YogaEdge,YogaAlign,YogaJustify等等)来减少你的布局代码,并使其变得可读性更强.</li>\n<li>对withLayout()下的prop不使用额外的缩进等级</li>\n<li>生命周期方法,例如@OnCreateLayout,是静态的并且对包外对象是私有的.</li>\n<li>如果可能的话,对可选的孩子Component使用内联选项,这样能使你的布局结构变得更加流畅.</li>\n<li>如果你正在构建一个孩子容器,在下一行添加该容器.这使布局代码显得更加结构化.</li>\n</ul>\n<p>使用推荐编码风格编码的实例代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop(resType = STRING)</span> String title,</div><div class=\"line\">      @<span class=\"title\">Prop</span><span class=\"params\">(optional = <span class=\"keyword\">true</span>)</span> Drawable image) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">      .alignItems(CENTER)</div><div class=\"line\">      .paddingRes(R.dimen.some_dimen)</div><div class=\"line\">      .child(</div><div class=\"line\">          Image.create(c)</div><div class=\"line\">              .drawable(image)</div><div class=\"line\">              .withLayout()</div><div class=\"line\">              .width(<span class=\"number\">40</span>)</div><div class=\"line\">              .height(<span class=\"number\">40</span>)</div><div class=\"line\">              .marginRes(RIGHT, R.dimen.my_margin))</div><div class=\"line\">      .child(TextUtils.isEmpty(title) ? <span class=\"keyword\">null</span> :</div><div class=\"line\">          Text.create(c)</div><div class=\"line\">              .text(title)</div><div class=\"line\">              .textColorAttr(R.attr.textColorTertiary)</div><div class=\"line\">              .withLayout()</div><div class=\"line\">              .marginDip(<span class=\"number\">5</span>)</div><div class=\"line\">              .flexGrow(<span class=\"number\">1f</span>))</div><div class=\"line\">      .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"Prop-vs-State\"><a href=\"#Prop-vs-State\" class=\"headerlink\" title=\"Prop vs State\"></a>Prop vs State</h4><hr>\n<p>Litho Component一共有两种类型的数据模型:<a href=\"https://shikieiki.github.io/2017/05/02/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Props/\">Prop</a>和<a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-State/\">State</a>.在你需要使用它们的时候,明白两种模型的差别是非常重要的.</p>\n<p>Prop的作用是在树中把数据从Component传递给它的孩子们.Prop在定义一个Component模型的静态部分中是非常有用的,因为Prop是不可变的.</p>\n<p>State主要是用于处理那些与Component交互产生的更新或者那些只能被Component拦截到的更新.State是由组件自己管理的并且从外部是不可见的,Component的父级完全不知道它孩子的State的信息.</p>\n<p>以下是关于如何决定对Component中的某些数据是采用prop还是State的简要介绍:</p>\n<ul>\n<li>数据是否定义了一个属性并且值会保持不变?如果是,则它应该是一个Prop.</li>\n<li>数据是否应该由父级定义并且传递下来?如果是,则它应该是一个Prop.</li>\n<li>它是否应该在用户与这个Component交互后改变它的值(例如点击)?如果是,它应该是一个State.</li>\n<li>你是否能够通过其他已有的Prop和State的值来计算出它的值?如果是,你就不应该使用State.</li>\n</ul>\n<p>比起使用由上至下传递的Prop的方式,使用更多State的方式会让你的应用程序的复杂度升高,变得更加难以维护和更加难以推导出数据流.你应该尝试控制你的Compoennt中的State在最小的数量并且保持的数据流是从上到下的.如果你有多个兄弟Component并且他们的State是互相依赖的,这时你应该确定一个父级Component来替代孩子们持有并且管理它们的state.</p>\n<p>让我们举个拥有单选按钮的列表的例子,列表中不能同时选中多个项.列表中所有的单选按钮的state都取决于其他项被点击和选中的状态.比起让所有的单选按钮都使用state,你应该在父Component中持有”哪一个列表项被点击”的state,并且通过prop从上而下的把这个信息传递给它的孩子们.</p>\n<p></p><br></p></p>\n<h4 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h4><hr>\n<p>Component本质上是一系列方法的集合,数据通过不可变的参数的方式传递给这些方法.当Component的prop或者state更新后,框架将会使用更新后的信息创建一个新的Component实例,因为先前的Component是不能改变的.</p>\n<p>虽然Component本身是不可变的,但是使用可变的对象来表示prop和state很容易就会使Component变得线程不安全.Litho<a href=\"https://shikieiki.github.io/2017/04/27/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%BC%82%E6%AD%A5%E5%B8%83%E5%B1%80/\">在后台线程中计算布局</a>,如果构成Component的Prop或者State的对象在另一个线程中被改变了,将会导致同样的Component渲染出不一样的效果.</p>\n<p>你必须保证你的prop和state是使用天生不可变的原始类型,如果做不到的话,也必须确保你使用的对象是不可变的.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-自定义布局","date":"2017-05-10T03:01:27.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/custom-layout)\n## 进阶指引\n### 自定义布局\n\n</p>\n</p>\n\nLitho依赖[Yoga](https://facebook.github.io/yoga/)(一个可以创建复杂UI的强大的布局引擎)来进行布局计算.然而,也会存在一些例外情况,这些时候只使用Yoga还不够,你可能还需要自己实现测量和布局的工作.\n\nLitho提供了一套自定义布局的API,用来在[ComponentTree](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree)被创建的和被测量时访问尺寸信息,或者在一个隔离的环境中测量Component.\n\n**重要,请注意**:这些API会造成**不可忽略**的性能开销,因此,我们建议仅仅在确定有必要使用它们的时候再去使用它们.\n\n</p>\n</p>\n\n#### 用例\n---\n\n- **一个Component布局树依赖于它自己的大小 和/或 它的孩子的大小**.例如这种情况:一个Component布局只能在它的孩子们的大小符合父亲的限制的时候才使用它们,如果不符合,这个布局就需要使用作为后备的孩子来代替.\n- **一个容器的孩子们必须根据它们的大小或者它们父亲的大小进行绝对位置的手动定位**.Yoga可以绝对定位孩子在父亲中的位置.然而,这个位置本身可能取决于使用父母的大小限制计算后的孩子的大小尺寸.如果需要,margin或者padding也需要手动被计算在内.\n\n</p>\n</p>\n\n#### 大小约束\n---\n\n在使用API之前,你需要已经熟悉了传统Android View的onMeasure方法并且了解什么是MeasureSpec,因为Litho使用了一个类似的概念,名叫SizeSpec.\n\n类似于Android的MeasureSpec,Litho的SizeSpec也是由size和mode组成的.可用的mode与MeasureSpec一样,有三种:UNSPECIFIED,EXACTLY和AT_MOST.\n\n</p>\n</p>\n\n#### 测量一个Component\n---\n我们可以使用给定的SizeSpec在隔离环境下测量Component.结果将会被填充进一个作为参数传递进去的Size对象中.\n\n在下面的例子中,我们使用一个UNSPECIFIED的SizeSpec去测量一个Text Component,这表示文字的一行能够是无限长的.\n\n``` java\nfinal Component<Text> textComponent = Text.create(c)\n    .textSizeSp(16)\n    .text(“Some text to measure.”)\n    .build();\n\nfinal Size outputSize = new Size();\ntextComponent.measure(\n    c, \n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    outputSize);\n\nfinal int textComponentWidth = outputSize.width;\nfinal int textComponentHeight = outputSize.height;\n```\n\n</p>\n</p>\n\n#### SizeSpec\n---\n\n在布局创建期间,API可以提供Component将要被测量时使用的SizeSpec信息.为了获取这些信息,我们需要用一个新的@OnCreateLayoutWithSizeSpec注释替代原来的@OnCreateLayout.新的注释方法的参数,除了标准的ComponentContext,还有两个整型,它们分别代表width spec和height spec.\n\n在下面的例子中,我们测量了一个Text Component来检查给定的文字是否适合可用的空间.如果不适合,则使用一个Image Component代替Text Component.\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  static ComponentLayout onCreateLayoutWithSizeSpec(\n      ComponentContext c,\n      int widthSpec,\n      int heightSpec,\n      @Prop SomeObject someProp) {\n\n    final Component<Text> textComponent = Text.create(c)\n        .textSizeSp(16)\n        .text(“Some text to measure.”)\n        .build();\n\n    // UNSPECIFIED sizeSpecs will measure the text as being one line only,\n    // having unlimited width.\n    final Size textOutputSize = new Size();\n    textComponent.measure(\n        c, \n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize);\n\n    // Small component to use in case textComponent doesn’t fit within\n    // the current layout.\n    final Component<Image> imageComponent = Image.create(c)\n        .srcRes(R.drawable.some_icon)\n        .build();\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    final int layoutWidth = SizeSpec.getSize(widthSpec);\n    final boolean textFits = (textOutputSize.width <= layoutWidth);\n    \n    return Layout.create(c, textFits ? textComponent : imageComponent)\n        .build();\n  }\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-10-Facebook出品的Android声明式开源新框架Litho文档翻译-自定义布局.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-自定义布局\ndate: 2017-05-10 11:01:27\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/custom-layout)\n## 进阶指引\n### 自定义布局\n\n</p>\n</p>\n\nLitho依赖[Yoga](https://facebook.github.io/yoga/)(一个可以创建复杂UI的强大的布局引擎)来进行布局计算.然而,也会存在一些例外情况,这些时候只使用Yoga还不够,你可能还需要自己实现测量和布局的工作.\n\nLitho提供了一套自定义布局的API,用来在[ComponentTree](http://fblitho.com/javadoc/com/facebook/litho/ComponentTree)被创建的和被测量时访问尺寸信息,或者在一个隔离的环境中测量Component.\n\n**重要,请注意**:这些API会造成**不可忽略**的性能开销,因此,我们建议仅仅在确定有必要使用它们的时候再去使用它们.\n\n</p>\n</p>\n\n#### 用例\n---\n\n- **一个Component布局树依赖于它自己的大小 和/或 它的孩子的大小**.例如这种情况:一个Component布局只能在它的孩子们的大小符合父亲的限制的时候才使用它们,如果不符合,这个布局就需要使用作为后备的孩子来代替.\n- **一个容器的孩子们必须根据它们的大小或者它们父亲的大小进行绝对位置的手动定位**.Yoga可以绝对定位孩子在父亲中的位置.然而,这个位置本身可能取决于使用父母的大小限制计算后的孩子的大小尺寸.如果需要,margin或者padding也需要手动被计算在内.\n\n</p>\n</p>\n\n#### 大小约束\n---\n\n在使用API之前,你需要已经熟悉了传统Android View的onMeasure方法并且了解什么是MeasureSpec,因为Litho使用了一个类似的概念,名叫SizeSpec.\n\n类似于Android的MeasureSpec,Litho的SizeSpec也是由size和mode组成的.可用的mode与MeasureSpec一样,有三种:UNSPECIFIED,EXACTLY和AT_MOST.\n\n</p>\n</p>\n\n#### 测量一个Component\n---\n我们可以使用给定的SizeSpec在隔离环境下测量Component.结果将会被填充进一个作为参数传递进去的Size对象中.\n\n在下面的例子中,我们使用一个UNSPECIFIED的SizeSpec去测量一个Text Component,这表示文字的一行能够是无限长的.\n\n``` java\nfinal Component<Text> textComponent = Text.create(c)\n    .textSizeSp(16)\n    .text(“Some text to measure.”)\n    .build();\n\nfinal Size outputSize = new Size();\ntextComponent.measure(\n    c, \n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    outputSize);\n\nfinal int textComponentWidth = outputSize.width;\nfinal int textComponentHeight = outputSize.height;\n```\n\n</p>\n</p>\n\n#### SizeSpec\n---\n\n在布局创建期间,API可以提供Component将要被测量时使用的SizeSpec信息.为了获取这些信息,我们需要用一个新的@OnCreateLayoutWithSizeSpec注释替代原来的@OnCreateLayout.新的注释方法的参数,除了标准的ComponentContext,还有两个整型,它们分别代表width spec和height spec.\n\n在下面的例子中,我们测量了一个Text Component来检查给定的文字是否适合可用的空间.如果不适合,则使用一个Image Component代替Text Component.\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  static ComponentLayout onCreateLayoutWithSizeSpec(\n      ComponentContext c,\n      int widthSpec,\n      int heightSpec,\n      @Prop SomeObject someProp) {\n\n    final Component<Text> textComponent = Text.create(c)\n        .textSizeSp(16)\n        .text(“Some text to measure.”)\n        .build();\n\n    // UNSPECIFIED sizeSpecs will measure the text as being one line only,\n    // having unlimited width.\n    final Size textOutputSize = new Size();\n    textComponent.measure(\n        c, \n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize);\n\n    // Small component to use in case textComponent doesn’t fit within\n    // the current layout.\n    final Component<Image> imageComponent = Image.create(c)\n        .srcRes(R.drawable.some_icon)\n        .build();\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    final int layoutWidth = SizeSpec.getSize(widthSpec);\n    final boolean textFits = (textOutputSize.width <= layoutWidth);\n    \n    return Layout.create(c, textFits ? textComponent : imageComponent)\n        .build();\n  }\n}\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-自定义布局","published":1,"updated":"2017-05-11T09:31:06.911Z","_id":"cj2k76hrm002yssrlll2tgjox","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/custom-layout\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a>自定义布局</h3><p></p><br><p></p><p></p>\n<p>Litho依赖<a href=\"https://facebook.github.io/yoga/\" target=\"_blank\" rel=\"external\">Yoga</a>(一个可以创建复杂UI的强大的布局引擎)来进行布局计算.然而,也会存在一些例外情况,这些时候只使用Yoga还不够,你可能还需要自己实现测量和布局的工作.</p>\n<p>Litho提供了一套自定义布局的API,用来在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree\" target=\"_blank\" rel=\"external\">ComponentTree</a>被创建的和被测量时访问尺寸信息,或者在一个隔离的环境中测量Component.</p>\n<p><strong>重要,请注意</strong>:这些API会造成<strong>不可忽略</strong>的性能开销,因此,我们建议仅仅在确定有必要使用它们的时候再去使用它们.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"用例\"><a href=\"#用例\" class=\"headerlink\" title=\"用例\"></a>用例</h4><hr>\n<ul>\n<li><strong>一个Component布局树依赖于它自己的大小 和/或 它的孩子的大小</strong>.例如这种情况:一个Component布局只能在它的孩子们的大小符合父亲的限制的时候才使用它们,如果不符合,这个布局就需要使用作为后备的孩子来代替.</li>\n<li><strong>一个容器的孩子们必须根据它们的大小或者它们父亲的大小进行绝对位置的手动定位</strong>.Yoga可以绝对定位孩子在父亲中的位置.然而,这个位置本身可能取决于使用父母的大小限制计算后的孩子的大小尺寸.如果需要,margin或者padding也需要手动被计算在内.</li>\n</ul>\n<p></p><br><p></p><p></p>\n<h4 id=\"大小约束\"><a href=\"#大小约束\" class=\"headerlink\" title=\"大小约束\"></a>大小约束</h4><hr>\n<p>在使用API之前,你需要已经熟悉了传统Android View的onMeasure方法并且了解什么是MeasureSpec,因为Litho使用了一个类似的概念,名叫SizeSpec.</p>\n<p>类似于Android的MeasureSpec,Litho的SizeSpec也是由size和mode组成的.可用的mode与MeasureSpec一样,有三种:UNSPECIFIED,EXACTLY和AT_MOST.</p>\n<p></p><br><p></p><p></p>\n<h4 id=\"测量一个Component\"><a href=\"#测量一个Component\" class=\"headerlink\" title=\"测量一个Component\"></a>测量一个Component</h4><hr>\n<p>我们可以使用给定的SizeSpec在隔离环境下测量Component.结果将会被填充进一个作为参数传递进去的Size对象中.</p>\n<p>在下面的例子中,我们使用一个UNSPECIFIED的SizeSpec去测量一个Text Component,这表示文字的一行能够是无限长的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component&lt;Text&gt; textComponent = Text.create(c)</div><div class=\"line\">    .textSizeSp(<span class=\"number\">16</span>)</div><div class=\"line\">    .text(“Some text to measure.”)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> Size outputSize = <span class=\"keyword\">new</span> Size();</div><div class=\"line\">textComponent.measure(</div><div class=\"line\">    c, </div><div class=\"line\">    SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">    SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">    outputSize);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textComponentWidth = outputSize.width;</div><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textComponentHeight = outputSize.height;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><p></p>\n<h4 id=\"SizeSpec\"><a href=\"#SizeSpec\" class=\"headerlink\" title=\"SizeSpec\"></a>SizeSpec</h4><hr>\n<p>在布局创建期间,API可以提供Component将要被测量时使用的SizeSpec信息.为了获取这些信息,我们需要用一个新的@OnCreateLayoutWithSizeSpec注释替代原来的@OnCreateLayout.新的注释方法的参数,除了标准的ComponentContext,还有两个整型,它们分别代表width spec和height spec.</p>\n<p>在下面的例子中,我们测量了一个Text Component来检查给定的文字是否适合可用的空间.如果不适合,则使用一个Image Component代替Text Component.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayoutWithSizeSpec</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayoutWithSizeSpec</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      <span class=\"keyword\">int</span> widthSpec,</div><div class=\"line\">      <span class=\"keyword\">int</span> heightSpec,</div><div class=\"line\">      @Prop SomeObject someProp) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component&lt;Text&gt; textComponent = Text.create(c)</div><div class=\"line\">        .textSizeSp(<span class=\"number\">16</span>)</div><div class=\"line\">        .text(“Some text to measure.”)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// UNSPECIFIED sizeSpecs will measure the text as being one line only,</span></div><div class=\"line\">    <span class=\"comment\">// having unlimited width.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Size textOutputSize = <span class=\"keyword\">new</span> Size();</div><div class=\"line\">    textComponent.measure(</div><div class=\"line\">        c, </div><div class=\"line\">        SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">        SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">        textOutputSize);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Small component to use in case textComponent doesn’t fit within</span></div><div class=\"line\">    <span class=\"comment\">// the current layout.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Component&lt;Image&gt; imageComponent = Image.create(c)</div><div class=\"line\">        .srcRes(R.drawable.some_icon)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> layoutWidth = SizeSpec.getSize(widthSpec);</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> textFits = (textOutputSize.width &lt;= layoutWidth);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> Layout.create(c, textFits ? textComponent : imageComponent)</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/custom-layout\">Litho-doc</a></p>\n<h2 id=\"进阶指引\"><a href=\"#进阶指引\" class=\"headerlink\" title=\"进阶指引\"></a>进阶指引</h2><h3 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a>自定义布局</h3><p></p><br></p></p>\n<p>Litho依赖<a href=\"https://facebook.github.io/yoga/\">Yoga</a>(一个可以创建复杂UI的强大的布局引擎)来进行布局计算.然而,也会存在一些例外情况,这些时候只使用Yoga还不够,你可能还需要自己实现测量和布局的工作.</p>\n<p>Litho提供了一套自定义布局的API,用来在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/ComponentTree\">ComponentTree</a>被创建的和被测量时访问尺寸信息,或者在一个隔离的环境中测量Component.</p>\n<p><strong>重要,请注意</strong>:这些API会造成<strong>不可忽略</strong>的性能开销,因此,我们建议仅仅在确定有必要使用它们的时候再去使用它们.</p>\n<p></p><br></p></p>\n<h4 id=\"用例\"><a href=\"#用例\" class=\"headerlink\" title=\"用例\"></a>用例</h4><hr>\n<ul>\n<li><strong>一个Component布局树依赖于它自己的大小 和/或 它的孩子的大小</strong>.例如这种情况:一个Component布局只能在它的孩子们的大小符合父亲的限制的时候才使用它们,如果不符合,这个布局就需要使用作为后备的孩子来代替.</li>\n<li><strong>一个容器的孩子们必须根据它们的大小或者它们父亲的大小进行绝对位置的手动定位</strong>.Yoga可以绝对定位孩子在父亲中的位置.然而,这个位置本身可能取决于使用父母的大小限制计算后的孩子的大小尺寸.如果需要,margin或者padding也需要手动被计算在内.</li>\n</ul>\n<p></p><br></p></p>\n<h4 id=\"大小约束\"><a href=\"#大小约束\" class=\"headerlink\" title=\"大小约束\"></a>大小约束</h4><hr>\n<p>在使用API之前,你需要已经熟悉了传统Android View的onMeasure方法并且了解什么是MeasureSpec,因为Litho使用了一个类似的概念,名叫SizeSpec.</p>\n<p>类似于Android的MeasureSpec,Litho的SizeSpec也是由size和mode组成的.可用的mode与MeasureSpec一样,有三种:UNSPECIFIED,EXACTLY和AT_MOST.</p>\n<p></p><br></p></p>\n<h4 id=\"测量一个Component\"><a href=\"#测量一个Component\" class=\"headerlink\" title=\"测量一个Component\"></a>测量一个Component</h4><hr>\n<p>我们可以使用给定的SizeSpec在隔离环境下测量Component.结果将会被填充进一个作为参数传递进去的Size对象中.</p>\n<p>在下面的例子中,我们使用一个UNSPECIFIED的SizeSpec去测量一个Text Component,这表示文字的一行能够是无限长的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component&lt;Text&gt; textComponent = Text.create(c)</div><div class=\"line\">    .textSizeSp(<span class=\"number\">16</span>)</div><div class=\"line\">    .text(“Some text to measure.”)</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> Size outputSize = <span class=\"keyword\">new</span> Size();</div><div class=\"line\">textComponent.measure(</div><div class=\"line\">    c, </div><div class=\"line\">    SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">    SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">    outputSize);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textComponentWidth = outputSize.width;</div><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textComponentHeight = outputSize.height;</div></pre></td></tr></table></figure>\n<p></p><br></p></p>\n<h4 id=\"SizeSpec\"><a href=\"#SizeSpec\" class=\"headerlink\" title=\"SizeSpec\"></a>SizeSpec</h4><hr>\n<p>在布局创建期间,API可以提供Component将要被测量时使用的SizeSpec信息.为了获取这些信息,我们需要用一个新的@OnCreateLayoutWithSizeSpec注释替代原来的@OnCreateLayout.新的注释方法的参数,除了标准的ComponentContext,还有两个整型,它们分别代表width spec和height spec.</p>\n<p>在下面的例子中,我们测量了一个Text Component来检查给定的文字是否适合可用的空间.如果不适合,则使用一个Image Component代替Text Component.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayoutWithSizeSpec</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayoutWithSizeSpec</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      <span class=\"keyword\">int</span> widthSpec,</div><div class=\"line\">      <span class=\"keyword\">int</span> heightSpec,</div><div class=\"line\">      @Prop SomeObject someProp)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component&lt;Text&gt; textComponent = Text.create(c)</div><div class=\"line\">        .textSizeSp(<span class=\"number\">16</span>)</div><div class=\"line\">        .text(“Some text to measure.”)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// UNSPECIFIED sizeSpecs will measure the text as being one line only,</span></div><div class=\"line\">    <span class=\"comment\">// having unlimited width.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Size textOutputSize = <span class=\"keyword\">new</span> Size();</div><div class=\"line\">    textComponent.measure(</div><div class=\"line\">        c, </div><div class=\"line\">        SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">        SizeSpec.makeSizeSpec(<span class=\"number\">0</span>, UNSPECIFIED),</div><div class=\"line\">        textOutputSize);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Small component to use in case textComponent doesn’t fit within</span></div><div class=\"line\">    <span class=\"comment\">// the current layout.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Component&lt;Image&gt; imageComponent = Image.create(c)</div><div class=\"line\">        .srcRes(R.drawable.some_icon)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> layoutWidth = SizeSpec.getSize(widthSpec);</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> textFits = (textOutputSize.width &lt;= layoutWidth);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> Layout.create(c, textFits ? textComponent : imageComponent)</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-仓库架构","date":"2017-05-11T08:17:41.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/repo-structure)\n## 参与\n### 仓库架构\n\n</p>\n</p>\n\n这是一个描述仓库中什么东西在哪儿的快速细分文档.\n \n/docs/\n\n---\n这个目录存放了你现在看到的这些GitHub页的Jekyll文件.\n\n</p>\n</p>\n\n/lib/\n\n---\n在这个子文件夹中可以找到很多扩展库.他们大致可以被分为两个类别.\n- **可拉取的库:**这些库都存放在jCenter上./lib/中相应的子文件夹中只包含了一个写有拉取这个库的命令的BUCK文件.\n- **打包的库:**这些库都被完整的存放在文件夹里.这是[正确的buck方式](https://buckbuild.com/command/fetch).然而,他们极大的增加了仓库的大小,因此它们只在绝对必要的时候才被包含进来.\n\n</p>\n</p>\n\n/sample-barebones/\n\n---\n在这里可以找到[准系统教程](http://fblitho.com/tutorial/)的成品源码.如果你修改了这个教程,你必须在这里更新源码.\n\n</p>\n</p>\n\n/sample/\n\n---\n在这个文件夹下可以找到Litho示例程序的代码.它包含了playground,你必须使用它来进行所有的测试/调试报告.\n\n</p>\n</p>\n\n/litho-*/\n\n---\nLitho被切分成为了几个子工程,所以终端用户可以选择框架中他们需要的部分来使用.可用的工程如下:\n- litho-annotation是一个纯净的,包含了用户使用注释处理器所必须的注释的java库.\n- litho-core包含了核心框架代码\n- litho-fresco包含了用户使用Fresco图形库所需的Component.\n- litho-it包含了对框架的集成测试.引入这个子工程是非常必要的,因为它可以避免循环引用.\n- litho-it-powermock包含了框架使用PowerMock的集成测试.查看文件夹下的README可以了解更多.\n- litho-processor包含了单例的注释处理器\n- litho-stetho包含了Stetho的集成,它可以让你更轻松的开发和调试.\n- litho-stubs包含了一些为了显示列表的魔法效果所需的Android框架类.\n- litho-testing包含了测试Litho Component的工具.\n- litho-widget包含了几个常用的Android控件的mount spec.\n\n</p>\n</p>\n\n/COMPONENTS_DEFS和/BUCK\n\n---\n这些文件定义了如何构建Litho.BUCK文件是[buck](https://buckbuild.com/)的输入,/COMPONENTS_DEFS文件包含了一些buck在仓库中查找目标所需的常量.它会被导入到/BUCK.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","source":"_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-仓库架构.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-仓库架构\ndate: 2017-05-11 16:17:41\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/repo-structure)\n## 参与\n### 仓库架构\n\n</p>\n</p>\n\n这是一个描述仓库中什么东西在哪儿的快速细分文档.\n \n/docs/\n\n---\n这个目录存放了你现在看到的这些GitHub页的Jekyll文件.\n\n</p>\n</p>\n\n/lib/\n\n---\n在这个子文件夹中可以找到很多扩展库.他们大致可以被分为两个类别.\n- **可拉取的库:**这些库都存放在jCenter上./lib/中相应的子文件夹中只包含了一个写有拉取这个库的命令的BUCK文件.\n- **打包的库:**这些库都被完整的存放在文件夹里.这是[正确的buck方式](https://buckbuild.com/command/fetch).然而,他们极大的增加了仓库的大小,因此它们只在绝对必要的时候才被包含进来.\n\n</p>\n</p>\n\n/sample-barebones/\n\n---\n在这里可以找到[准系统教程](http://fblitho.com/tutorial/)的成品源码.如果你修改了这个教程,你必须在这里更新源码.\n\n</p>\n</p>\n\n/sample/\n\n---\n在这个文件夹下可以找到Litho示例程序的代码.它包含了playground,你必须使用它来进行所有的测试/调试报告.\n\n</p>\n</p>\n\n/litho-*/\n\n---\nLitho被切分成为了几个子工程,所以终端用户可以选择框架中他们需要的部分来使用.可用的工程如下:\n- litho-annotation是一个纯净的,包含了用户使用注释处理器所必须的注释的java库.\n- litho-core包含了核心框架代码\n- litho-fresco包含了用户使用Fresco图形库所需的Component.\n- litho-it包含了对框架的集成测试.引入这个子工程是非常必要的,因为它可以避免循环引用.\n- litho-it-powermock包含了框架使用PowerMock的集成测试.查看文件夹下的README可以了解更多.\n- litho-processor包含了单例的注释处理器\n- litho-stetho包含了Stetho的集成,它可以让你更轻松的开发和调试.\n- litho-stubs包含了一些为了显示列表的魔法效果所需的Android框架类.\n- litho-testing包含了测试Litho Component的工具.\n- litho-widget包含了几个常用的Android控件的mount spec.\n\n</p>\n</p>\n\n/COMPONENTS_DEFS和/BUCK\n\n---\n这些文件定义了如何构建Litho.BUCK文件是[buck](https://buckbuild.com/)的输入,/COMPONENTS_DEFS文件包含了一些buck在仓库中查找目标所需的常量.它会被导入到/BUCK.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-仓库架构","published":1,"updated":"2017-05-11T09:36:31.834Z","_id":"cj2k76hrn0032ssrl6xc8a23s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/repo-structure\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h2><h3 id=\"仓库架构\"><a href=\"#仓库架构\" class=\"headerlink\" title=\"仓库架构\"></a>仓库架构</h3><p></p><br><p></p><p></p>\n<p>这是一个描述仓库中什么东西在哪儿的快速细分文档.</p>\n<p>/docs/</p>\n<hr>\n<p>这个目录存放了你现在看到的这些GitHub页的Jekyll文件.</p>\n<p></p><br><p></p><p></p>\n<p>/lib/</p>\n<hr>\n<p>在这个子文件夹中可以找到很多扩展库.他们大致可以被分为两个类别.</p>\n<ul>\n<li><strong>可拉取的库:</strong>这些库都存放在jCenter上./lib/中相应的子文件夹中只包含了一个写有拉取这个库的命令的BUCK文件.</li>\n<li><strong>打包的库:</strong>这些库都被完整的存放在文件夹里.这是<a href=\"https://buckbuild.com/command/fetch\" target=\"_blank\" rel=\"external\">正确的buck方式</a>.然而,他们极大的增加了仓库的大小,因此它们只在绝对必要的时候才被包含进来.</li>\n</ul>\n<p></p><br><p></p><p></p>\n<p>/sample-barebones/</p>\n<hr>\n<p>在这里可以找到<a href=\"http://fblitho.com/tutorial/\" target=\"_blank\" rel=\"external\">准系统教程</a>的成品源码.如果你修改了这个教程,你必须在这里更新源码.</p>\n<p></p><br><p></p><p></p>\n<p>/sample/</p>\n<hr>\n<p>在这个文件夹下可以找到Litho示例程序的代码.它包含了playground,你必须使用它来进行所有的测试/调试报告.</p>\n<p></p><br><p></p><p></p>\n<p>/litho-*/</p>\n<hr>\n<p>Litho被切分成为了几个子工程,所以终端用户可以选择框架中他们需要的部分来使用.可用的工程如下:</p>\n<ul>\n<li>litho-annotation是一个纯净的,包含了用户使用注释处理器所必须的注释的java库.</li>\n<li>litho-core包含了核心框架代码</li>\n<li>litho-fresco包含了用户使用Fresco图形库所需的Component.</li>\n<li>litho-it包含了对框架的集成测试.引入这个子工程是非常必要的,因为它可以避免循环引用.</li>\n<li>litho-it-powermock包含了框架使用PowerMock的集成测试.查看文件夹下的README可以了解更多.</li>\n<li>litho-processor包含了单例的注释处理器</li>\n<li>litho-stetho包含了Stetho的集成,它可以让你更轻松的开发和调试.</li>\n<li>litho-stubs包含了一些为了显示列表的魔法效果所需的Android框架类.</li>\n<li>litho-testing包含了测试Litho Component的工具.</li>\n<li>litho-widget包含了几个常用的Android控件的mount spec.</li>\n</ul>\n<p></p><br><p></p><p></p>\n<p>/COMPONENTS_DEFS和/BUCK</p>\n<hr>\n<p>这些文件定义了如何构建Litho.BUCK文件是<a href=\"https://buckbuild.com/\" target=\"_blank\" rel=\"external\">buck</a>的输入,/COMPONENTS_DEFS文件包含了一些buck在仓库中查找目标所需的常量.它会被导入到/BUCK.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/repo-structure\">Litho-doc</a></p>\n<h2 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h2><h3 id=\"仓库架构\"><a href=\"#仓库架构\" class=\"headerlink\" title=\"仓库架构\"></a>仓库架构</h3><p></p><br></p></p>\n<p>这是一个描述仓库中什么东西在哪儿的快速细分文档.</p>\n<p>/docs/</p>\n<hr>\n<p>这个目录存放了你现在看到的这些GitHub页的Jekyll文件.</p>\n<p></p><br></p></p>\n<p>/lib/</p>\n<hr>\n<p>在这个子文件夹中可以找到很多扩展库.他们大致可以被分为两个类别.</p>\n<ul>\n<li><strong>可拉取的库:</strong>这些库都存放在jCenter上./lib/中相应的子文件夹中只包含了一个写有拉取这个库的命令的BUCK文件.</li>\n<li><strong>打包的库:</strong>这些库都被完整的存放在文件夹里.这是<a href=\"https://buckbuild.com/command/fetch\">正确的buck方式</a>.然而,他们极大的增加了仓库的大小,因此它们只在绝对必要的时候才被包含进来.</li>\n</ul>\n<p></p><br></p></p>\n<p>/sample-barebones/</p>\n<hr>\n<p>在这里可以找到<a href=\"http://fblitho.com/tutorial/\">准系统教程</a>的成品源码.如果你修改了这个教程,你必须在这里更新源码.</p>\n<p></p><br></p></p>\n<p>/sample/</p>\n<hr>\n<p>在这个文件夹下可以找到Litho示例程序的代码.它包含了playground,你必须使用它来进行所有的测试/调试报告.</p>\n<p></p><br></p></p>\n<p>/litho-*/</p>\n<hr>\n<p>Litho被切分成为了几个子工程,所以终端用户可以选择框架中他们需要的部分来使用.可用的工程如下:</p>\n<ul>\n<li>litho-annotation是一个纯净的,包含了用户使用注释处理器所必须的注释的java库.</li>\n<li>litho-core包含了核心框架代码</li>\n<li>litho-fresco包含了用户使用Fresco图形库所需的Component.</li>\n<li>litho-it包含了对框架的集成测试.引入这个子工程是非常必要的,因为它可以避免循环引用.</li>\n<li>litho-it-powermock包含了框架使用PowerMock的集成测试.查看文件夹下的README可以了解更多.</li>\n<li>litho-processor包含了单例的注释处理器</li>\n<li>litho-stetho包含了Stetho的集成,它可以让你更轻松的开发和调试.</li>\n<li>litho-stubs包含了一些为了显示列表的魔法效果所需的Android框架类.</li>\n<li>litho-testing包含了测试Litho Component的工具.</li>\n<li>litho-widget包含了几个常用的Android控件的mount spec.</li>\n</ul>\n<p></p><br></p></p>\n<p>/COMPONENTS_DEFS和/BUCK</p>\n<hr>\n<p>这些文件定义了如何构建Litho.BUCK文件是<a href=\"https://buckbuild.com/\">buck</a>的输入,/COMPONENTS_DEFS文件包含了一些buck在仓库中查找目标所需的常量.它会被导入到/BUCK.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-开发者选项","date":"2017-05-11T06:52:00.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/developer-options)\n## 工具\n### 开发者选项\n\n</p>\n</p>\n\n除了Stetho之外,我们还提供了两个编译时标志,用于可视化你的应用程序的Component层级结构.这类似于Android的内部设置:显示View边界,但是由于Litho并不是总是使用Android View,所以我们实现了我们自己的方式使它变得更加实用.\n\n在[ComponentsConfiguration](http://fblitho.com/javadoc/com/facebook/litho/config/ComponentsConfiguration)类中有两个字段来控制这些.\n\n</p>\n</p>\n\n##### debugHighlightInteractiveBounds\n---\n高亮显示Component的交互边界以及Component的扩展触摸边界(如果存在的话).\n\n</p>\n</p>\n\n##### debugHighlightMountBounds\n---\n高亮显示可挂载的drawable和view的边界.由框架自动添加(例如,在Component被点击的时候)的View将会被使用不同的颜色来高亮显示.\n\n</p>\n</p>\n\n这些是默认关闭的.如果你想要在你的程序中打开它们,你可以在你的程序中的任何地方覆写他们:\n\n``` java\nComponentsConfiguration.debugHighlightInteractiveBounds = true;\nComponentsConfiguration.debugHighlightMountBounds = true;\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-开发者选项.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-开发者选项\ndate: 2017-05-11 14:52:00\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/developer-options)\n## 工具\n### 开发者选项\n\n</p>\n</p>\n\n除了Stetho之外,我们还提供了两个编译时标志,用于可视化你的应用程序的Component层级结构.这类似于Android的内部设置:显示View边界,但是由于Litho并不是总是使用Android View,所以我们实现了我们自己的方式使它变得更加实用.\n\n在[ComponentsConfiguration](http://fblitho.com/javadoc/com/facebook/litho/config/ComponentsConfiguration)类中有两个字段来控制这些.\n\n</p>\n</p>\n\n##### debugHighlightInteractiveBounds\n---\n高亮显示Component的交互边界以及Component的扩展触摸边界(如果存在的话).\n\n</p>\n</p>\n\n##### debugHighlightMountBounds\n---\n高亮显示可挂载的drawable和view的边界.由框架自动添加(例如,在Component被点击的时候)的View将会被使用不同的颜色来高亮显示.\n\n</p>\n</p>\n\n这些是默认关闭的.如果你想要在你的程序中打开它们,你可以在你的程序中的任何地方覆写他们:\n\n``` java\nComponentsConfiguration.debugHighlightInteractiveBounds = true;\nComponentsConfiguration.debugHighlightMountBounds = true;\n```\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-开发者选项","published":1,"updated":"2017-05-11T09:35:14.995Z","_id":"cj2k76hrp0035ssrls8so813m","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/developer-options\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a>开发者选项</h3><p></p><br><p></p><p></p>\n<p>除了Stetho之外,我们还提供了两个编译时标志,用于可视化你的应用程序的Component层级结构.这类似于Android的内部设置:显示View边界,但是由于Litho并不是总是使用Android View,所以我们实现了我们自己的方式使它变得更加实用.</p>\n<p>在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/config/ComponentsConfiguration\" target=\"_blank\" rel=\"external\">ComponentsConfiguration</a>类中有两个字段来控制这些.</p>\n<p></p><br><p></p><p></p>\n<h5 id=\"debugHighlightInteractiveBounds\"><a href=\"#debugHighlightInteractiveBounds\" class=\"headerlink\" title=\"debugHighlightInteractiveBounds\"></a>debugHighlightInteractiveBounds</h5><hr>\n<p>高亮显示Component的交互边界以及Component的扩展触摸边界(如果存在的话).</p>\n<p></p><br><p></p><p></p>\n<h5 id=\"debugHighlightMountBounds\"><a href=\"#debugHighlightMountBounds\" class=\"headerlink\" title=\"debugHighlightMountBounds\"></a>debugHighlightMountBounds</h5><hr>\n<p>高亮显示可挂载的drawable和view的边界.由框架自动添加(例如,在Component被点击的时候)的View将会被使用不同的颜色来高亮显示.</p>\n<p></p><br><p></p><p></p>\n<p>这些是默认关闭的.如果你想要在你的程序中打开它们,你可以在你的程序中的任何地方覆写他们:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentsConfiguration.debugHighlightInteractiveBounds = <span class=\"keyword\">true</span>;</div><div class=\"line\">ComponentsConfiguration.debugHighlightMountBounds = <span class=\"keyword\">true</span>;</div></pre></td></tr></table></figure>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/developer-options\">Litho-doc</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a>开发者选项</h3><p></p><br></p></p>\n<p>除了Stetho之外,我们还提供了两个编译时标志,用于可视化你的应用程序的Component层级结构.这类似于Android的内部设置:显示View边界,但是由于Litho并不是总是使用Android View,所以我们实现了我们自己的方式使它变得更加实用.</p>\n<p>在<a href=\"http://fblitho.com/javadoc/com/facebook/litho/config/ComponentsConfiguration\">ComponentsConfiguration</a>类中有两个字段来控制这些.</p>\n<p></p><br></p></p>\n<h5 id=\"debugHighlightInteractiveBounds\"><a href=\"#debugHighlightInteractiveBounds\" class=\"headerlink\" title=\"debugHighlightInteractiveBounds\"></a>debugHighlightInteractiveBounds</h5><hr>\n<p>高亮显示Component的交互边界以及Component的扩展触摸边界(如果存在的话).</p>\n<p></p><br></p></p>\n<h5 id=\"debugHighlightMountBounds\"><a href=\"#debugHighlightMountBounds\" class=\"headerlink\" title=\"debugHighlightMountBounds\"></a>debugHighlightMountBounds</h5><hr>\n<p>高亮显示可挂载的drawable和view的边界.由框架自动添加(例如,在Component被点击的时候)的View将会被使用不同的颜色来高亮显示.</p>\n<p></p><br></p></p>\n<p>这些是默认关闭的.如果你想要在你的程序中打开它们,你可以在你的程序中的任何地方覆写他们:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ComponentsConfiguration.debugHighlightInteractiveBounds = <span class=\"keyword\">true</span>;</div><div class=\"line\">ComponentsConfiguration.debugHighlightMountBounds = <span class=\"keyword\">true</span>;</div></pre></td></tr></table></figure>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-如何参与","date":"2017-05-11T08:13:56.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/contributing)\n## 参与\n### 如何参与\n\n</p>\n</p>\n\nFacebook Litho团队非常欢迎你的参与.\n\n我们使用GitHub的Pull系统进行操作.请在[这里](https://github.com/facebook/litho/blob/master/CONTRIBUTING.md)查看详细信息.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-如何参与.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-如何参与\ndate: 2017-05-11 16:13:56\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/contributing)\n## 参与\n### 如何参与\n\n</p>\n</p>\n\nFacebook Litho团队非常欢迎你的参与.\n\n我们使用GitHub的Pull系统进行操作.请在[这里](https://github.com/facebook/litho/blob/master/CONTRIBUTING.md)查看详细信息.\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-如何参与","published":1,"updated":"2017-05-11T09:35:57.243Z","_id":"cj2k76hrq0039ssrlxxs74a1z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/contributing\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h2><h3 id=\"如何参与\"><a href=\"#如何参与\" class=\"headerlink\" title=\"如何参与\"></a>如何参与</h3><p></p><br><p></p><p></p>\n<p>Facebook Litho团队非常欢迎你的参与.</p>\n<p>我们使用GitHub的Pull系统进行操作.请在<a href=\"https://github.com/facebook/litho/blob/master/CONTRIBUTING.md\" target=\"_blank\" rel=\"external\">这里</a>查看详细信息.</p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/contributing\">Litho-doc</a></p>\n<h2 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h2><h3 id=\"如何参与\"><a href=\"#如何参与\" class=\"headerlink\" title=\"如何参与\"></a>如何参与</h3><p></p><br></p></p>\n<p>Facebook Litho团队非常欢迎你的参与.</p>\n<p>我们使用GitHub的Pull系统进行操作.请在<a href=\"https://github.com/facebook/litho/blob/master/CONTRIBUTING.md\">这里</a>查看详细信息.</p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译-调试","date":"2017-05-11T06:21:44.000Z","_content":"\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/debugging)\n## 工具\n### 调试\n\n</p>\n</p>\n\n#### Stetho\n---\n[Stetho](http://facebook.github.io/stetho/)是一个非常好的Android调试工具,我们已经确保了它能够与Litho一起使用.为了在Stetho中启用Litho调试,需要在你的Application实现中的onCreate()方法里添加下列的代码:\n``` java\npublic class SampleApplication extends Application {\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    SoLoader.init(this, false);\n    \n    Stetho.initialize(\n        Stetho.newInitializerBuilder(this)\n              .enableWebKitInspector(new LithoWebKitInspector(this))\n              .build());\n  }\n}\n```\n\n这会使Litho完全集成进stetho中.启用了Litho支持之后,你只用打开你的app然后再你的浏览器中打开chrome://inspect\n\n![](/image/20170511142823.png)\n\n点击你想查看的程序的查看链接(我们使用的是Litho sample app).这将会打开一个UI查看器,你可以在其中查看你程序的View和Component的层级结构.\n\n![](/image/20170511143232.png)\n\n当查看一个Litho Component的时候,你也可以直接在查看器中更改你的UI中的内容!这样就可以在不重新编译和运行你的程序的情况下,通过调整margin,padding或者其他属性来实现快速设计迭代.你也可以使用它来快速测试你的UI是否能处理不同长度的文本.\n![](/image/20170511143319.png)\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","source":"_posts/2017-05-11-Facebook出品的Android声明式开源新框架Litho文档翻译-调试.md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译-调试\ndate: 2017-05-11 14:21:44\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n英文原文文档地址: [Litho-doc](http://fblitho.com/docs/debugging)\n## 工具\n### 调试\n\n</p>\n</p>\n\n#### Stetho\n---\n[Stetho](http://facebook.github.io/stetho/)是一个非常好的Android调试工具,我们已经确保了它能够与Litho一起使用.为了在Stetho中启用Litho调试,需要在你的Application实现中的onCreate()方法里添加下列的代码:\n``` java\npublic class SampleApplication extends Application {\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    SoLoader.init(this, false);\n    \n    Stetho.initialize(\n        Stetho.newInitializerBuilder(this)\n              .enableWebKitInspector(new LithoWebKitInspector(this))\n              .build());\n  }\n}\n```\n\n这会使Litho完全集成进stetho中.启用了Litho支持之后,你只用打开你的app然后再你的浏览器中打开chrome://inspect\n\n![](/image/20170511142823.png)\n\n点击你想查看的程序的查看链接(我们使用的是Litho sample app).这将会打开一个UI查看器,你可以在其中查看你程序的View和Component的层级结构.\n\n![](/image/20170511143232.png)\n\n当查看一个Litho Component的时候,你也可以直接在查看器中更改你的UI中的内容!这样就可以在不重新编译和运行你的程序的情况下,通过调整margin,padding或者其他属性来实现快速设计迭代.你也可以使用它来快速测试你的UI是否能处理不同长度的文本.\n![](/image/20170511143319.png)\n\n</p>\n</p>\n</p>\n</p>\n\n##### [回到导航页](https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/)\n</p>\n</p>\n</p>\n</p>","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译-调试","published":1,"updated":"2017-05-11T09:34:51.732Z","_id":"cj2k76hrr003cssrll1vgbyby","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/debugging\" target=\"_blank\" rel=\"external\">Litho-doc</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p></p><br><p></p><p></p>\n<h4 id=\"Stetho\"><a href=\"#Stetho\" class=\"headerlink\" title=\"Stetho\"></a>Stetho</h4><hr>\n<p><a href=\"http://facebook.github.io/stetho/\" target=\"_blank\" rel=\"external\">Stetho</a>是一个非常好的Android调试工具,我们已经确保了它能够与Litho一起使用.为了在Stetho中启用Litho调试,需要在你的Application实现中的onCreate()方法里添加下列的代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">    </div><div class=\"line\">    Stetho.initialize(</div><div class=\"line\">        Stetho.newInitializerBuilder(<span class=\"keyword\">this</span>)</div><div class=\"line\">              .enableWebKitInspector(<span class=\"keyword\">new</span> LithoWebKitInspector(<span class=\"keyword\">this</span>))</div><div class=\"line\">              .build());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这会使Litho完全集成进stetho中.启用了Litho支持之后,你只用打开你的app然后再你的浏览器中打开chrome://inspect</p>\n<p><img src=\"/image/20170511142823.png\" alt=\"\"></p>\n<p>点击你想查看的程序的查看链接(我们使用的是Litho sample app).这将会打开一个UI查看器,你可以在其中查看你程序的View和Component的层级结构.</p>\n<p><img src=\"/image/20170511143232.png\" alt=\"\"></p>\n<p>当查看一个Litho Component的时候,你也可以直接在查看器中更改你的UI中的内容!这样就可以在不重新编译和运行你的程序的情况下,通过调整margin,padding或者其他属性来实现快速设计迭代.你也可以使用它来快速测试你的UI是否能处理不同长度的文本.<br><img src=\"/image/20170511143319.png\" alt=\"\"></p>\n<p></p><br><p></p><br><p></p><br><p></p><p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br><p></p><br><p></p><br><p></p><p></p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.<br>英文原文文档地址: <a href=\"http://fblitho.com/docs/debugging\">Litho-doc</a></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p></p><br></p></p>\n<h4 id=\"Stetho\"><a href=\"#Stetho\" class=\"headerlink\" title=\"Stetho\"></a>Stetho</h4><hr>\n<p><a href=\"http://facebook.github.io/stetho/\">Stetho</a>是一个非常好的Android调试工具,我们已经确保了它能够与Litho一起使用.为了在Stetho中启用Litho调试,需要在你的Application实现中的onCreate()方法里添加下列的代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">    </div><div class=\"line\">    Stetho.initialize(</div><div class=\"line\">        Stetho.newInitializerBuilder(<span class=\"keyword\">this</span>)</div><div class=\"line\">              .enableWebKitInspector(<span class=\"keyword\">new</span> LithoWebKitInspector(<span class=\"keyword\">this</span>))</div><div class=\"line\">              .build());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这会使Litho完全集成进stetho中.启用了Litho支持之后,你只用打开你的app然后再你的浏览器中打开chrome://inspect</p>\n<p><img src=\"/image/20170511142823.png\" alt=\"\"></p>\n<p>点击你想查看的程序的查看链接(我们使用的是Litho sample app).这将会打开一个UI查看器,你可以在其中查看你程序的View和Component的层级结构.</p>\n<p><img src=\"/image/20170511143232.png\" alt=\"\"></p>\n<p>当查看一个Litho Component的时候,你也可以直接在查看器中更改你的UI中的内容!这样就可以在不重新编译和运行你的程序的情况下,通过调整margin,padding或者其他属性来实现快速设计迭代.你也可以使用它来快速测试你的UI是否能处理不同长度的文本.<br><img src=\"/image/20170511143319.png\" alt=\"\"></p>\n<p></p><br></p><br></p><br></p></p>\n<h5 id=\"回到导航页\"><a href=\"#回到导航页\" class=\"headerlink\" title=\"回到导航页\"></a><a href=\"https://shikieiki.github.io/2017/05/04/Facebook%E5%87%BA%E5%93%81%E7%9A%84Android%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%80%E6%BA%90%E6%96%B0%E6%A1%86%E6%9E%B6Litho%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%80%BB%E8%A7%88%E5%92%8C%E5%AF%BC%E8%88%AA/\">回到导航页</a></h5><p></p><br></p><br></p><br></p></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj2k76hq00008ssrlj8yys9c0","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hq4000dssrld86k6ba7"},{"post_id":"cj2k76hpp0003ssrlv7bg5yhr","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hq6000hssrlj6ls7f4j"},{"post_id":"cj2k76hq10009ssrl25ckqrkz","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hq8000kssrluhwyxqyl"},{"post_id":"cj2k76hq3000cssrluc252det","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqa000pssrlabcinjwp"},{"post_id":"cj2k76hpv0004ssrl3oqfdpby","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqc000rssrl3rjoikla"},{"post_id":"cj2k76hq7000issrl4ow0mqtl","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqd000ussrlohmh2yq0"},{"post_id":"cj2k76hpz0007ssrlc2kmhy78","category_id":"cj2k76hq6000fssrla3wubs4m","_id":"cj2k76hqf000wssrlda176kc1"},{"post_id":"cj2k76hq8000lssrl43ie3ngk","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqo0010ssrly0nkyvvh"},{"post_id":"cj2k76hqb000qssrlabrbig9t","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqp0013ssrl71ofiwjh"},{"post_id":"cj2k76hq5000essrltlydhxkh","category_id":"cj2k76hq9000nssrl1t0x5pbk","_id":"cj2k76hqq0016ssrl262wtrdh"},{"post_id":"cj2k76hqc000sssrlhexy2l6r","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqs001assrlrhves650"},{"post_id":"cj2k76hqd000vssrlj6cblmj6","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqx001dssrllxx48zi2"},{"post_id":"cj2k76hqg000xssrlifz572v4","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hqz001hssrlrh771b5o"},{"post_id":"cj2k76hqo0011ssrluxk7acre","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr0001kssrl7bner79u"},{"post_id":"cj2k76hqp0014ssrl9bkomunl","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr1001ossrlaguewraa"},{"post_id":"cj2k76hqq0018ssrlx5jt09y7","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr2001rssrl853pl5r2"},{"post_id":"cj2k76hqs001bssrlmq1oal9b","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr4001vssrluhhtyec5"},{"post_id":"cj2k76hqx001fssrl1mbp7you","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr5001yssrl6jgsqdah"},{"post_id":"cj2k76hqz001issrlqi7j99vf","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr70022ssrlbq8ek1dd"},{"post_id":"cj2k76hr0001mssrlvykj30xf","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hr80025ssrlhvs511pl"},{"post_id":"cj2k76hr2001pssrl06uxzfcy","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrb0029ssrlw9ucpi5k"},{"post_id":"cj2k76hr3001tssrlcb0539s8","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hre002cssrlc5514n13"},{"post_id":"cj2k76hr4001wssrlju6gknxb","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrf002gssrl19ltlihf"},{"post_id":"cj2k76hr60020ssrlfdhnp3hu","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hri002jssrloy19aqzf"},{"post_id":"cj2k76hr70023ssrltd4h8cb3","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrj002nssrl57kq2gxt"},{"post_id":"cj2k76hr80027ssrlgev0jteu","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrk002qssrlc6l6x204"},{"post_id":"cj2k76hrc002assrltpojk0ab","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrl002ussrl3v38ulcd"},{"post_id":"cj2k76hre002dssrln2mq958z","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrm002xssrlgwtiztug"},{"post_id":"cj2k76hrf002hssrl73vsx686","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrn0031ssrl6efmitcf"},{"post_id":"cj2k76hri002kssrl1mb3s27h","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrp0034ssrl24f5dqc0"},{"post_id":"cj2k76hrj002ossrlqtc4vht4","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrq0038ssrlvfgo707z"},{"post_id":"cj2k76hrk002rssrlhw0j3l9i","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrr003bssrlci8u7h0o"},{"post_id":"cj2k76hrl002vssrlzk88sgtk","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrs003fssrleusks1yy"},{"post_id":"cj2k76hrm002yssrlll2tgjox","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrs003hssrlkdu5mgr1"},{"post_id":"cj2k76hrn0032ssrl6xc8a23s","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrs003jssrlz9i0ibel"},{"post_id":"cj2k76hrp0035ssrls8so813m","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrs003lssrltml7nhvs"},{"post_id":"cj2k76hrq0039ssrlxxs74a1z","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hrt003nssrlax7p8gy9"},{"post_id":"cj2k76hrr003cssrll1vgbyby","category_id":"cj2k76hpx0005ssrln7qav6z1","_id":"cj2k76hru003pssrl7144f1tg"}],"PostTag":[{"post_id":"cj2k76hpp0003ssrlv7bg5yhr","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hq8000jssrl4ql8ukg8"},{"post_id":"cj2k76hpp0003ssrlv7bg5yhr","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hq9000mssrlixxf008h"},{"post_id":"cj2k76hqd000vssrlj6cblmj6","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hqo000zssrlj6f9m78r"},{"post_id":"cj2k76hqd000vssrlj6cblmj6","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hqp0012ssrl2hrqxgij"},{"post_id":"cj2k76hqd000vssrlj6cblmj6","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hqq0015ssrlen2lhajk"},{"post_id":"cj2k76hpv0004ssrl3oqfdpby","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hqs0019ssrlmdao1376"},{"post_id":"cj2k76hpv0004ssrl3oqfdpby","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hqx001cssrlhwcvesdp"},{"post_id":"cj2k76hpv0004ssrl3oqfdpby","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hqz001gssrlacm8psdj"},{"post_id":"cj2k76hqg000xssrlifz572v4","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hr0001jssrlnxna8yur"},{"post_id":"cj2k76hqg000xssrlifz572v4","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hr1001nssrlzmtrkrfd"},{"post_id":"cj2k76hqg000xssrlifz572v4","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hr2001qssrlue07bfyq"},{"post_id":"cj2k76hqo0011ssrluxk7acre","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hr4001ussrlnthfuedi"},{"post_id":"cj2k76hqo0011ssrluxk7acre","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hr5001xssrl0hksz64z"},{"post_id":"cj2k76hqo0011ssrluxk7acre","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hr70021ssrl7fj1k2nl"},{"post_id":"cj2k76hpz0007ssrlc2kmhy78","tag_id":"cj2k76hqn000yssrlbkstcizy","_id":"cj2k76hr80024ssrl3shk6rju"},{"post_id":"cj2k76hqp0014ssrl9bkomunl","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrb0028ssrlzaqyd269"},{"post_id":"cj2k76hqp0014ssrl9bkomunl","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hre002bssrlx6m6j8cz"},{"post_id":"cj2k76hqp0014ssrl9bkomunl","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrf002fssrl6og5wk9i"},{"post_id":"cj2k76hqq0018ssrlx5jt09y7","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrh002issrlvhyx68y7"},{"post_id":"cj2k76hqq0018ssrlx5jt09y7","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hri002mssrljgx9mfs0"},{"post_id":"cj2k76hqq0018ssrlx5jt09y7","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrk002pssrlnen5ob9g"},{"post_id":"cj2k76hqs001bssrlmq1oal9b","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrl002tssrlaibc7sqt"},{"post_id":"cj2k76hqs001bssrlmq1oal9b","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrm002wssrlf77qzb10"},{"post_id":"cj2k76hqs001bssrlmq1oal9b","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrn0030ssrlq3rh1iq2"},{"post_id":"cj2k76hqx001fssrl1mbp7you","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hro0033ssrl88v0xywz"},{"post_id":"cj2k76hqx001fssrl1mbp7you","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrq0037ssrl9c18n54s"},{"post_id":"cj2k76hqx001fssrl1mbp7you","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrr003assrlaz1ftx71"},{"post_id":"cj2k76hq00008ssrlj8yys9c0","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrs003essrlp1cdxr6v"},{"post_id":"cj2k76hq00008ssrlj8yys9c0","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrs003gssrlrpcw467e"},{"post_id":"cj2k76hq00008ssrlj8yys9c0","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrs003issrl4igsgvut"},{"post_id":"cj2k76hqz001issrlqi7j99vf","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrs003kssrlid25e22f"},{"post_id":"cj2k76hqz001issrlqi7j99vf","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrt003mssrljcfm4umw"},{"post_id":"cj2k76hqz001issrlqi7j99vf","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hru003ossrll2pwjlhw"},{"post_id":"cj2k76hr0001mssrlvykj30xf","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hru003qssrloqc8bds7"},{"post_id":"cj2k76hr0001mssrlvykj30xf","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hru003rssrlvaqxjgef"},{"post_id":"cj2k76hr0001mssrlvykj30xf","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrv003sssrl19bqslpj"},{"post_id":"cj2k76hr2001pssrl06uxzfcy","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrv003tssrljliyvvap"},{"post_id":"cj2k76hr2001pssrl06uxzfcy","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrv003ussrlzyumtxt9"},{"post_id":"cj2k76hr2001pssrl06uxzfcy","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrv003vssrl9hip0e24"},{"post_id":"cj2k76hr3001tssrlcb0539s8","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrv003wssrl9pzlh5og"},{"post_id":"cj2k76hr3001tssrlcb0539s8","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrw003xssrlpj17yfgo"},{"post_id":"cj2k76hr3001tssrlcb0539s8","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrw003yssrlvg5gen8f"},{"post_id":"cj2k76hq10009ssrl25ckqrkz","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrw003zssrljurt6ubb"},{"post_id":"cj2k76hq10009ssrl25ckqrkz","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrw0040ssrlcwa1htnx"},{"post_id":"cj2k76hq10009ssrl25ckqrkz","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrw0041ssrllftv2bof"},{"post_id":"cj2k76hr4001wssrlju6gknxb","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrw0042ssrlwini1eic"},{"post_id":"cj2k76hr4001wssrlju6gknxb","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrw0043ssrltp7hd5f4"},{"post_id":"cj2k76hr4001wssrlju6gknxb","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrw0044ssrl6ejy4iyv"},{"post_id":"cj2k76hr60020ssrlfdhnp3hu","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrw0045ssrl5agqxbr1"},{"post_id":"cj2k76hr60020ssrlfdhnp3hu","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrw0046ssrltlgfwkw3"},{"post_id":"cj2k76hr60020ssrlfdhnp3hu","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrw0047ssrlpy1t00k7"},{"post_id":"cj2k76hq3000cssrluc252det","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrw0048ssrlazzb4pp4"},{"post_id":"cj2k76hq3000cssrluc252det","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrw0049ssrlpc23uwn9"},{"post_id":"cj2k76hq3000cssrluc252det","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrw004assrlt0btrxq5"},{"post_id":"cj2k76hr70023ssrltd4h8cb3","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrw004bssrl18p3to41"},{"post_id":"cj2k76hr70023ssrltd4h8cb3","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrx004cssrla651seib"},{"post_id":"cj2k76hr70023ssrltd4h8cb3","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrx004dssrlwczshffv"},{"post_id":"cj2k76hr80027ssrlgev0jteu","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrx004essrli25ju9im"},{"post_id":"cj2k76hr80027ssrlgev0jteu","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrx004fssrl9ga8far3"},{"post_id":"cj2k76hr80027ssrlgev0jteu","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrx004gssrlxkyt8cdv"},{"post_id":"cj2k76hrc002assrltpojk0ab","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrx004hssrlpmetuna6"},{"post_id":"cj2k76hrc002assrltpojk0ab","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrx004issrlrsvzp63t"},{"post_id":"cj2k76hrc002assrltpojk0ab","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrx004jssrlqmrrtnqo"},{"post_id":"cj2k76hre002dssrln2mq958z","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrx004kssrliay0128w"},{"post_id":"cj2k76hre002dssrln2mq958z","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrx004lssrlujud5cmh"},{"post_id":"cj2k76hre002dssrln2mq958z","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrx004mssrl5w86c8of"},{"post_id":"cj2k76hrf002hssrl73vsx686","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrx004nssrl4cy0f4yh"},{"post_id":"cj2k76hrf002hssrl73vsx686","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrx004ossrlchw5tm20"},{"post_id":"cj2k76hrf002hssrl73vsx686","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrx004pssrl1885oh43"},{"post_id":"cj2k76hri002kssrl1mb3s27h","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrx004qssrldy9fco6q"},{"post_id":"cj2k76hri002kssrl1mb3s27h","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hry004rssrl8vrahgvc"},{"post_id":"cj2k76hri002kssrl1mb3s27h","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hry004sssrlotl4qtfo"},{"post_id":"cj2k76hrj002ossrlqtc4vht4","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hry004tssrl68z7pesw"},{"post_id":"cj2k76hrj002ossrlqtc4vht4","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hry004ussrld6tlbft5"},{"post_id":"cj2k76hrj002ossrlqtc4vht4","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hry004vssrlwdrwekst"},{"post_id":"cj2k76hq5000essrltlydhxkh","tag_id":"cj2k76hr80026ssrlw3adlog4","_id":"cj2k76hry004wssrl1jkz7deh"},{"post_id":"cj2k76hq5000essrltlydhxkh","tag_id":"cj2k76hrf002essrl0qi4howb","_id":"cj2k76hry004xssrllg4sghdi"},{"post_id":"cj2k76hq5000essrltlydhxkh","tag_id":"cj2k76hqn000yssrlbkstcizy","_id":"cj2k76hry004yssrl47gsbqhr"},{"post_id":"cj2k76hrk002rssrlhw0j3l9i","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hry004zssrl1zhq24su"},{"post_id":"cj2k76hrk002rssrlhw0j3l9i","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hry0050ssrli8f5tsja"},{"post_id":"cj2k76hrk002rssrlhw0j3l9i","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hry0051ssrlsxkg62gl"},{"post_id":"cj2k76hrl002vssrlzk88sgtk","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hry0052ssrl3a1wsj8m"},{"post_id":"cj2k76hrl002vssrlzk88sgtk","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrz0053ssrl0zg5esw2"},{"post_id":"cj2k76hrl002vssrlzk88sgtk","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrz0054ssrljxapgocj"},{"post_id":"cj2k76hq7000issrl4ow0mqtl","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrz0055ssrl1pobatci"},{"post_id":"cj2k76hq7000issrl4ow0mqtl","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrz0056ssrlexkj8mtk"},{"post_id":"cj2k76hq7000issrl4ow0mqtl","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrz0057ssrl61fu2r72"},{"post_id":"cj2k76hrm002yssrlll2tgjox","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrz0058ssrlb91s7jtt"},{"post_id":"cj2k76hrm002yssrlll2tgjox","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrz0059ssrlzk5co75z"},{"post_id":"cj2k76hrm002yssrlll2tgjox","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrz005assrl0j6h4x34"},{"post_id":"cj2k76hrn0032ssrl6xc8a23s","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrz005bssrlncsy9zpk"},{"post_id":"cj2k76hrn0032ssrl6xc8a23s","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrz005cssrl9zpr3jjf"},{"post_id":"cj2k76hrn0032ssrl6xc8a23s","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hrz005dssrlkniwe4uh"},{"post_id":"cj2k76hq8000lssrl43ie3ngk","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hrz005essrlbnfn6641"},{"post_id":"cj2k76hq8000lssrl43ie3ngk","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hrz005fssrlkfktzwq2"},{"post_id":"cj2k76hq8000lssrl43ie3ngk","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hs0005gssrlnl6gvl48"},{"post_id":"cj2k76hrp0035ssrls8so813m","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hs0005hssrls3l18hb8"},{"post_id":"cj2k76hrp0035ssrls8so813m","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hs0005issrll6i9ixum"},{"post_id":"cj2k76hrp0035ssrls8so813m","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hs0005jssrl29eygkp3"},{"post_id":"cj2k76hrq0039ssrlxxs74a1z","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hs0005kssrly2mvmgfz"},{"post_id":"cj2k76hrq0039ssrlxxs74a1z","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hs0005lssrlwae9zito"},{"post_id":"cj2k76hrq0039ssrlxxs74a1z","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hs0005mssrlfuagpzeu"},{"post_id":"cj2k76hqb000qssrlabrbig9t","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hs0005nssrl0wxzyfst"},{"post_id":"cj2k76hqb000qssrlabrbig9t","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hs0005ossrlljg6fxca"},{"post_id":"cj2k76hqb000qssrlabrbig9t","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hs0005pssrlns9954ai"},{"post_id":"cj2k76hrr003cssrll1vgbyby","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hs0005qssrl8783sej4"},{"post_id":"cj2k76hrr003cssrll1vgbyby","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hs0005rssrl1vq0attu"},{"post_id":"cj2k76hrr003cssrll1vgbyby","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hs0005sssrlus7efnep"},{"post_id":"cj2k76hqc000sssrlhexy2l6r","tag_id":"cj2k76hpz0006ssrlx3h9hy61","_id":"cj2k76hs0005tssrlna3vehxh"},{"post_id":"cj2k76hqc000sssrlhexy2l6r","tag_id":"cj2k76hq2000bssrl7bzlq5sh","_id":"cj2k76hs1005ussrlzdo7dxp0"},{"post_id":"cj2k76hqc000sssrlhexy2l6r","tag_id":"cj2k76hqd000tssrldy4f2xfq","_id":"cj2k76hs1005vssrlw13sf8vc"}],"Tag":[{"name":"Android","_id":"cj2k76hpz0006ssrlx3h9hy61"},{"name":"实用库","_id":"cj2k76hq2000bssrl7bzlq5sh"},{"name":"Litho","_id":"cj2k76hqd000tssrldy4f2xfq"},{"name":"github","_id":"cj2k76hqn000yssrlbkstcizy"},{"name":"Hexo","_id":"cj2k76hr80026ssrlw3adlog4"},{"name":"Web","_id":"cj2k76hrf002essrl0qi4howb"}]}}