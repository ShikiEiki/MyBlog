{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/20170223175427.png","path":"image/20170223175427.png","modified":0,"renderable":0},{"_id":"source/image/20170223174812.png","path":"image/20170223174812.png","modified":0,"renderable":0},{"_id":"source/image/20170223175801.png","path":"image/20170223175801.png","modified":0,"renderable":0},{"_id":"source/image/20170301152451.png","path":"image/20170301152451.png","modified":0,"renderable":0},{"_id":"source/image/20170301152527.png","path":"image/20170301152527.png","modified":0,"renderable":0},{"_id":"source/image/20170301153213.png","path":"image/20170301153213.png","modified":0,"renderable":0},{"_id":"source/image/20170301161732.png","path":"image/20170301161732.png","modified":0,"renderable":0},{"_id":"source/image/20170426150321.png","path":"image/20170426150321.png","modified":0,"renderable":0},{"_id":"source/image/20170426150749.png","path":"image/20170426150749.png","modified":0,"renderable":0},{"_id":"source/image/20170426150806.png","path":"image/20170426150806.png","modified":0,"renderable":0},{"_id":"source/image/20170428092530.png","path":"image/20170428092530.png","modified":0,"renderable":0},{"_id":"source/image/20170428102947.png","path":"image/20170428102947.png","modified":0,"renderable":0},{"_id":"source/image/20170428105417.png","path":"image/20170428105417.png","modified":0,"renderable":0},{"_id":"source/image/20170428111627.png","path":"image/20170428111627.png","modified":0,"renderable":0},{"_id":"source/image/20170301160933.png","path":"image/20170301160933.png","modified":0,"renderable":0},{"_id":"source/image/20170224160822.png","path":"image/20170224160822.png","modified":0,"renderable":0},{"_id":"themes/alpha-dust/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/image/20170224163724.png","path":"image/20170224163724.png","modified":0,"renderable":0},{"_id":"source/image/20170426171157.gif","path":"image/20170426171157.gif","modified":0,"renderable":0},{"_id":"source/image/20170426172130.gif","path":"image/20170426172130.gif","modified":0,"renderable":0},{"_id":"source/image/20170426172051.gif","path":"image/20170426172051.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/about.md","hash":"e75793b62ed63ee419006f053b344c1717b5b061","modified":1487927574256},{"_id":"source/contact.md","hash":"cd90d4181e9cc3b0371e7e1021fbe191a3100061","modified":1487927574256},{"_id":"source/hello-world.md","hash":"10d93534fe6733d4ffb81e97f82cf4971900ade1","modified":1487927574256},{"_id":"themes/alpha-dust/.gitignore","hash":"a5a49e4d5dfb97857856eb6b0cdb2c93a387718f","modified":1487927574259},{"_id":"themes/alpha-dust/README.md","hash":"402518c350275303ede195a62e9e05bfa236b190","modified":1487927574259},{"_id":"themes/alpha-dust/LICENSE","hash":"9603ca6555bd5f0710038003b8a503bd29ca67a1","modified":1487927574259},{"_id":"themes/alpha-dust/_config.yml","hash":"9ba4a7c54b4aa7d28558575cc3644aec24d66452","modified":1487927574259},{"_id":"source/_posts/2017-02-23-如何使用gitHub和Hexo搭建个人博客.md","hash":"958c959ba9d8f897880c46de98cdbb9eacf766df","modified":1493087250892},{"_id":"source/_posts/2017-03-01-为你的Github生成漂亮的徽章和进度条.md","hash":"2d2bf8637c3110504d75eece008e3c90f3dd4256","modified":1488358910710},{"_id":"source/_posts/2017-02-28-一个好用的Android比例自动适配的库.md","hash":"8fb1fbe763358aa115888948da2a6d12be5d7b16","modified":1488275966594},{"_id":"source/_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译(一).md","hash":"45f8a841b11b50bdd34140e2572955fe2529f0a4","modified":1493259121171},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译(二).md","hash":"8169fbf2f6e8a4bca5430a514fbe1df287698df4","modified":1493359290384},{"_id":"source/_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译(八).md","hash":"615e5e56d9eef5942a0af33b02b53ac459a94869","modified":1493280293079},{"_id":"source/_posts/2017-04-28-Facebook出品的Android声明式开源新框架Litho文档翻译(三).md","hash":"8f2d1c036271b888d0c29c3639a6f4883a884696","modified":1493693426151},{"_id":"source/image/20170223175427.png","hash":"b3c0933df333bb88719d045ee3f2a099749aecdb","modified":1487927574256},{"_id":"source/image/20170223174812.png","hash":"7c70d7271498cf2b11de6924c91a8c8e0c3e4245","modified":1487927574256},{"_id":"source/image/20170223175801.png","hash":"96e6764bb6097dcd32c456b66fbfcd4ef9493953","modified":1487927574257},{"_id":"source/image/20170301152451.png","hash":"e6b1eb88957315ff55c8375522e1772975c2c5c2","modified":1488353110456},{"_id":"source/image/20170301152527.png","hash":"3704209e21d7f61c41216ce73bf78dccc55e5055","modified":1488353133799},{"_id":"source/image/20170301153213.png","hash":"da06ba8864110695cf3c9392b52bb234ff55ec8f","modified":1488353540712},{"_id":"source/image/20170301161732.png","hash":"296c24ee7c17bf75a6298e8df11fdbf44e746c31","modified":1488356258956},{"_id":"source/image/20170426150321.png","hash":"7a6f44b19c2879511525d3a434ed5fc03efaef1b","modified":1493190124761},{"_id":"source/image/20170426150749.png","hash":"f092255a963446010c8d52c0911e577215ab5537","modified":1493190475840},{"_id":"source/image/20170426150806.png","hash":"cdb20c98ab94e410f43379847117bd27e05b46b9","modified":1493190491751},{"_id":"source/image/20170428092530.png","hash":"5abfc4c1af4f32fc701e3824106d5e57f4c5ab2c","modified":1493342747921},{"_id":"source/image/20170428102947.png","hash":"b8b29817ff1d481d40ef573c128e8492fcfb0614","modified":1493346598682},{"_id":"source/image/20170428105417.png","hash":"fb887ae2242263691fb76ff975089974a092bbf6","modified":1493348066017},{"_id":"source/image/20170428111627.png","hash":"d10672f222e60d1a7c763554ae603874e7111336","modified":1493349394240},{"_id":"themes/alpha-dust/languages/default.yml","hash":"f0e62ce15272b2c59c9ae7f7615a286c69bf7113","modified":1487927574260},{"_id":"themes/alpha-dust/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1487927574260},{"_id":"themes/alpha-dust/languages/en.yml","hash":"f0e62ce15272b2c59c9ae7f7615a286c69bf7113","modified":1487927574260},{"_id":"themes/alpha-dust/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1487927574260},{"_id":"themes/alpha-dust/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1487927574260},{"_id":"themes/alpha-dust/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1487927574260},{"_id":"themes/alpha-dust/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1487927574261},{"_id":"themes/alpha-dust/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1487927574261},{"_id":"themes/alpha-dust/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1487927574261},{"_id":"themes/alpha-dust/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1487927574261},{"_id":"themes/alpha-dust/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1487927574261},{"_id":"themes/alpha-dust/layout/archive.ejs","hash":"30620dd5e4f24e9d624c235dd16396c5e130deef","modified":1487927574264},{"_id":"themes/alpha-dust/layout/index.ejs","hash":"0dcf6f1b66722ddadb7479f4edf20281d30a7879","modified":1487927574264},{"_id":"themes/alpha-dust/layout/page.ejs","hash":"953256db94b3ed9ce2870d4b9203fe3a1e5b37bb","modified":1487927574265},{"_id":"themes/alpha-dust/layout/post.ejs","hash":"4030d46464fd653c0e72a7615c19e7b2d73aa21d","modified":1487927574265},{"_id":"themes/alpha-dust/layout/layout.ejs","hash":"9d1ba5fb467ab4269cbc925b3f2122a29b821b8d","modified":1487927574264},{"_id":"themes/alpha-dust/template/archive.html","hash":"6152dc2e093c1431cbe2fa6bc9cb54751c2a7f86","modified":1487927574269},{"_id":"themes/alpha-dust/template/index.html","hash":"674b2011f068af9bf464ac77aafccf6867fcd7c0","modified":1487927574277},{"_id":"themes/alpha-dust/template/post.html","hash":"daed2747ec15affef2fe1d5cc05432361a2ed6f9","modified":1487927574278},{"_id":"source/image/20170301160933.png","hash":"525587c28c79b8a23be9794f18c5bc766bc9358b","modified":1488355780489},{"_id":"source/image/20170224160822.png","hash":"78a9edac5da4fb320dcabea116452c127123ecf1","modified":1487927574258},{"_id":"themes/alpha-dust/layout/_partial/after-footer.ejs","hash":"43ad85ba781c3c98354e9873fe8a49fe50f08bb4","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/article-archive.ejs","hash":"f9608407a583bff104acb07c03fd8108056798c7","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/article-short.ejs","hash":"8158759b81ea61b07873f4e7360ec631ca0930ca","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/article-long.ejs","hash":"65df8414a4b479033c0f67e066064351f0b2216f","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/comments.ejs","hash":"b0bb9c59f517302348aafcb2b832513d53d59055","modified":1487927574262},{"_id":"themes/alpha-dust/layout/_partial/footer.ejs","hash":"b07b8f7f43811e1b6f5382f6eb4cd778a70bd3cc","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/footer_categories.ejs","hash":"f85cb280ae965fdd1d92af8bc0ece6c4d826a449","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/footer_recent_posts.ejs","hash":"8c20579849498be304e47d0f10d42149971eb352","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/gallery.ejs","hash":"63c93ed2dc9c5d9eefeaa8130e9728848731fa64","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1487927574263},{"_id":"themes/alpha-dust/layout/_partial/head.ejs","hash":"3132acfe6658f31db95a4dae6d818b09b9156d59","modified":1487927574264},{"_id":"themes/alpha-dust/layout/_partial/header.ejs","hash":"4fa635135f97eaa5f324cf83cb04b083ffdd979f","modified":1487927574264},{"_id":"themes/alpha-dust/layout/_partial/menu.ejs","hash":"760cdaf07f808c9e8637f58e412aea43c4021ec2","modified":1487927574264},{"_id":"themes/alpha-dust/layout/_partial/pagination.ejs","hash":"58982acc8dc2b83c6c2cdf64a2c4156e947254d0","modified":1487927574264},{"_id":"themes/alpha-dust/source/css/style.styl","hash":"17454ba3eef92075c4848bb43fd626b53760334b","modified":1487927574267},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1487927574268},{"_id":"themes/alpha-dust/source/js/main.js","hash":"e644dd5c0742f209072c48499c1beba20bc1e496","modified":1487927574268},{"_id":"themes/alpha-dust/template/css/font-awesome.css","hash":"a02674d823c7b577d38c3cdb91953993b6e4b3a0","modified":1487927574269},{"_id":"themes/alpha-dust/template/css/font-awesome.min.css","hash":"3c1d63dd1176c77f9f4cdb1616fbb08c31b9822f","modified":1487927574269},{"_id":"themes/alpha-dust/template/css/style.styl","hash":"a3d739266fbf9aff73443cf745e4a4d5c284cffc","modified":1487927574270},{"_id":"themes/alpha-dust/template/css/style.css","hash":"9c3710b32a4466c3ea5b6232a1af8fccc5877216","modified":1487927574270},{"_id":"themes/alpha-dust/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1487927574276},{"_id":"themes/alpha-dust/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1487927574276},{"_id":"themes/alpha-dust/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1487927574276},{"_id":"themes/alpha-dust/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1487927574276},{"_id":"themes/alpha-dust/template/js/main.js","hash":"ed46e32f0bf6f4502a6558f9ad03843031dc318d","modified":1487927574277},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1487927574272},{"_id":"themes/alpha-dust/template/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1487927574271},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1487927574274},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1487927574275},{"_id":"themes/alpha-dust/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1487927574277},{"_id":"source/image/20170224163724.png","hash":"70da4674d268cc70a0ff1f4189e67dab5639563d","modified":1487927574259},{"_id":"themes/alpha-dust/source/css/_partial/archive.styl","hash":"e51d15046b9e10d4342b67bb83fd3a0c42f5d60e","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/base.styl","hash":"00300febf434b78ad93087e83481d2bf9d2c54a5","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/code.styl","hash":"6c0788e0616a366234157abd18cb6a11b4dc8bfc","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/footer.styl","hash":"a741adad7f208787c5d863a443da9a3438a01331","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/header.styl","hash":"d74c2d8968b909c4e2cdab2235b5cebf6eef91c8","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/post-content.styl","hash":"c3f0ae13c8a953e957da23db6ef7dab2b8217352","modified":1487927574267},{"_id":"themes/alpha-dust/source/css/_partial/pagination.styl","hash":"7dfcf43dd05063115f7ebf9e63219a102b35a3ba","modified":1487927574267},{"_id":"themes/alpha-dust/source/css/_partial/menu.styl","hash":"7419c10bf98d059fa0263427c68e009cc0d4c4fa","modified":1487927574266},{"_id":"themes/alpha-dust/source/css/_partial/post-layout.styl","hash":"bc8376e97266f047457117a965321efdd58e68a3","modified":1487927574267},{"_id":"themes/alpha-dust/source/css/_partial/variables.styl","hash":"f1dbc90648d67e03ba3b311c967977aa50888b38","modified":1487927574267},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1487927574274},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1487927574273},{"_id":"source/image/20170426171157.gif","hash":"bd4dfe2a3d2ffd23d444cfe97ea847041716b4d3","modified":1493109084536},{"_id":"source/image/20170426172130.gif","hash":"119c6cdd9b78eec8c7d5e16488b786eb3039d13f","modified":1493112975924},{"_id":"source/image/20170426172051.gif","hash":"7e4ac1c0cc36974a196e2bcee8a12bc9a1277889","modified":1493112978032},{"_id":"public/about.html","hash":"a8dd048839909501e4b9c2723c063e9929c6cd45","modified":1493693553770},{"_id":"public/contact.html","hash":"4ab4046fe8dfc6653f3240da82bc0877f3449abc","modified":1493693553770},{"_id":"public/hello-world.html","hash":"a00bb5cce5f36b6c6228950e67aca2b7b57baaa3","modified":1493693553770},{"_id":"public/2017/04/25/Facebook出品的Android声明式开源新框架Litho文档翻译(一)/index.html","hash":"68fd7a415cfe171ebdacdc2b474ed630ec4adefc","modified":1493693553770},{"_id":"public/2017/03/01/为你的Github生成漂亮的徽章和进度条/index.html","hash":"cafb92eefcf38c6bc8cc9a11f52989b9da47109a","modified":1493693553770},{"_id":"public/archives/index.html","hash":"5b4bf209550694b182bc749668ab5c31143595ab","modified":1493693553770},{"_id":"public/archives/2017/index.html","hash":"e996358f0d138b9ebc384f8483144131238e2a9e","modified":1493693553770},{"_id":"public/archives/2017/02/index.html","hash":"8b807b6d5d219e0d0065070ea0a083bae589006b","modified":1493693553770},{"_id":"public/archives/2017/03/index.html","hash":"78e9ccf7707c4aa610daf93f82a195f0758d4244","modified":1493693553770},{"_id":"public/archives/2017/04/index.html","hash":"51c264de5440426af970c53be82ecdb29f5edb4c","modified":1493693553770},{"_id":"public/categories/Android知识/index.html","hash":"a706e99fe5d35a3fa0d1d4c2d9f3adf6245913a5","modified":1493373445166},{"_id":"public/categories/其他知识/index.html","hash":"62f7e37f95994561c9eeb9f66e55542d0135380a","modified":1493373445166},{"_id":"public/categories/Web前端知识/index.html","hash":"923abb34ecba3cd17f56cda241cf31e397bbcd4d","modified":1493373445166},{"_id":"public/tags/Android/index.html","hash":"12f613c89fb1e623d57e3f6782bab9fc11495af7","modified":1493373445167},{"_id":"public/tags/github/index.html","hash":"761b66d0841851964ca409df77a1a2994893b92e","modified":1493373445167},{"_id":"public/tags/实用库/index.html","hash":"d9bf20369347a57e85aa5fa95e51d705ccbdaa8a","modified":1493373445167},{"_id":"public/tags/Hexo/index.html","hash":"dd1f2522c5ed88cbda398486836563c77c121874","modified":1493373445167},{"_id":"public/tags/Web/index.html","hash":"094734a0756277ea8ed182be63729b90c428c3fa","modified":1493373445167},{"_id":"public/tags/Litho/index.html","hash":"810e950c354f7e586804e27fc68c4bba791bf43d","modified":1493373445167},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译(二)/index.html","hash":"24dd1d5efa88c327be1ccf1169ef8591b2f2f7d8","modified":1493693553770},{"_id":"public/2017/04/27/Facebook出品的Android声明式开源新框架Litho文档翻译(八)/index.html","hash":"b72d476584a370bd72a7eaa2baee3eda3b53d2f4","modified":1493693553771},{"_id":"public/2017/02/28/一个好用的Android比例自动适配的库/index.html","hash":"2006bc297b4aaf429ff96601ecc5d2781932f93c","modified":1493693553771},{"_id":"public/2017/02/23/如何使用gitHub和Hexo搭建个人博客/index.html","hash":"b5d4187b20b0d9bd4d4359b213904bd5391cb5ad","modified":1493693553771},{"_id":"public/index.html","hash":"809f5ccc0e2f3cfb0a04d48e0e1c82a4b96baebf","modified":1493693529643},{"_id":"public/2017/04/28/Facebook出品的Android声明式开源新框架Litho文档翻译(三)/index.html","hash":"92361aafc55a797e6922fe6d011dbf784c5c1a56","modified":1493693553770},{"_id":"public/image/20170223175427.png","hash":"b3c0933df333bb88719d045ee3f2a099749aecdb","modified":1493373445175},{"_id":"public/image/20170223174812.png","hash":"7c70d7271498cf2b11de6924c91a8c8e0c3e4245","modified":1493373445175},{"_id":"public/image/20170223175801.png","hash":"96e6764bb6097dcd32c456b66fbfcd4ef9493953","modified":1493373445175},{"_id":"public/image/20170301152451.png","hash":"e6b1eb88957315ff55c8375522e1772975c2c5c2","modified":1493373445175},{"_id":"public/image/20170301152527.png","hash":"3704209e21d7f61c41216ce73bf78dccc55e5055","modified":1493373445175},{"_id":"public/image/20170301153213.png","hash":"da06ba8864110695cf3c9392b52bb234ff55ec8f","modified":1493373445175},{"_id":"public/image/20170426150321.png","hash":"7a6f44b19c2879511525d3a434ed5fc03efaef1b","modified":1493373445175},{"_id":"public/image/20170301161732.png","hash":"296c24ee7c17bf75a6298e8df11fdbf44e746c31","modified":1493373445175},{"_id":"public/image/20170426150749.png","hash":"f092255a963446010c8d52c0911e577215ab5537","modified":1493373445175},{"_id":"public/image/20170428092530.png","hash":"5abfc4c1af4f32fc701e3824106d5e57f4c5ab2c","modified":1493373445175},{"_id":"public/image/20170428102947.png","hash":"b8b29817ff1d481d40ef573c128e8492fcfb0614","modified":1493373445175},{"_id":"public/image/20170428105417.png","hash":"fb887ae2242263691fb76ff975089974a092bbf6","modified":1493373445175},{"_id":"public/image/20170428111627.png","hash":"d10672f222e60d1a7c763554ae603874e7111336","modified":1493373445175},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1493373445175},{"_id":"public/image/20170426150806.png","hash":"cdb20c98ab94e410f43379847117bd27e05b46b9","modified":1493373445175},{"_id":"public/image/20170301160933.png","hash":"525587c28c79b8a23be9794f18c5bc766bc9358b","modified":1493373445443},{"_id":"public/css/style.css","hash":"a8b4312a0a6e600e3c1629df20e2860757370d10","modified":1493373445447},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1493373445447},{"_id":"public/image/20170224160822.png","hash":"78a9edac5da4fb320dcabea116452c127123ecf1","modified":1493373445447},{"_id":"public/image/20170224163724.png","hash":"70da4674d268cc70a0ff1f4189e67dab5639563d","modified":1493373445450},{"_id":"public/image/20170426171157.gif","hash":"bd4dfe2a3d2ffd23d444cfe97ea847041716b4d3","modified":1493373445476},{"_id":"public/image/20170426172130.gif","hash":"119c6cdd9b78eec8c7d5e16488b786eb3039d13f","modified":1493373445479},{"_id":"public/image/20170426172051.gif","hash":"7e4ac1c0cc36974a196e2bcee8a12bc9a1277889","modified":1493373445495}],"Category":[{"name":"Android知识","_id":"cj21nzol300051srl4agx23sj"},{"name":"其他知识","_id":"cj21nzolb000a1srl91sc4ad3"},{"name":"Web前端知识","_id":"cj21nzole000f1srl83wem1mb"}],"Data":[],"Page":[{"title":"ABOUT","_content":"\nHi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.\n\n本博客使用[Hexo](https://hexo.io/)搭建,部署在[GitHub Pages](https://pages.github.com/)上.使用[alpha-dust](https://github.com/klugjo/hexo-theme-alpha-dust)主题.\n\n感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢[klugjo](https://github.com/klugjo)提供了这个充满科技感的Hexo主题.","source":"about.md","raw":"---\ntitle: ABOUT\n---\n\nHi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.\n\n本博客使用[Hexo](https://hexo.io/)搭建,部署在[GitHub Pages](https://pages.github.com/)上.使用[alpha-dust](https://github.com/klugjo/hexo-theme-alpha-dust)主题.\n\n感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢[klugjo](https://github.com/klugjo)提供了这个充满科技感的Hexo主题.","date":"2017-03-02T09:55:40.727Z","updated":"2017-02-24T09:12:54.256Z","path":"about.html","comments":1,"layout":"page","_id":"cj21nzoke00001srl1k4k7q1d","content":"<p>Hi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.</p>\n<p>本博客使用<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>搭建,部署在<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a>上.使用<a href=\"https://github.com/klugjo/hexo-theme-alpha-dust\" target=\"_blank\" rel=\"external\">alpha-dust</a>主题.</p>\n<p>感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢<a href=\"https://github.com/klugjo\" target=\"_blank\" rel=\"external\">klugjo</a>提供了这个充满科技感的Hexo主题.</p>\n","excerpt":"","more":"<p>Hi,欢迎访问我的博客,博主的工作是Android App开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Android开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.</p>\n<p>本博客使用<a href=\"https://hexo.io/\">Hexo</a>搭建,部署在<a href=\"https://pages.github.com/\">GitHub Pages</a>上.使用<a href=\"https://github.com/klugjo/hexo-theme-alpha-dust\">alpha-dust</a>主题.</p>\n<p>感谢Hexo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢<a href=\"https://github.com/klugjo\">klugjo</a>提供了这个充满科技感的Hexo主题.</p>\n"},{"title":"CONTACT","_content":"\n- Email : [515073770@qq.com](mailto:515073770@qq.com)\n- GitHub : [https://github.com/ShikiEiki](https://github.com/ShikiEiki)\n- Weibo : [猫山四季](http://weibo.com/fhshiki)\n- QQ : 515073770","source":"contact.md","raw":"---\ntitle: CONTACT\n---\n\n- Email : [515073770@qq.com](mailto:515073770@qq.com)\n- GitHub : [https://github.com/ShikiEiki](https://github.com/ShikiEiki)\n- Weibo : [猫山四季](http://weibo.com/fhshiki)\n- QQ : 515073770","date":"2017-03-02T09:55:40.728Z","updated":"2017-02-24T09:12:54.256Z","path":"contact.html","comments":1,"layout":"page","_id":"cj21nzokg00011srlh3pbcl6e","content":"<ul>\n<li>Email : <a href=\"mailto:515073770@qq.com\" target=\"_blank\" rel=\"external\">515073770@qq.com</a></li>\n<li>GitHub : <a href=\"https://github.com/ShikiEiki\" target=\"_blank\" rel=\"external\">https://github.com/ShikiEiki</a></li>\n<li>Weibo : <a href=\"http://weibo.com/fhshiki\" target=\"_blank\" rel=\"external\">猫山四季</a></li>\n<li>QQ : 515073770</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>Email : <a href=\"mailto:515073770@qq.com\">515073770@qq.com</a></li>\n<li>GitHub : <a href=\"https://github.com/ShikiEiki\">https://github.com/ShikiEiki</a></li>\n<li>Weibo : <a href=\"http://weibo.com/fhshiki\">猫山四季</a></li>\n<li>QQ : 515073770</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n$ hexo sadfdsaf\n$ hexo sdfsadfs\n```\n\n``` java\nint i = 0;\nint j = 0;\nbreak;\nObject o = new Object(this);\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n$ hexo sadfdsaf\n$ hexo sdfsadfs\n```\n\n``` java\nint i = 0;\nint j = 0;\nbreak;\nObject o = new Object(this);\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","date":"2017-03-02T09:55:40.730Z","updated":"2017-02-24T09:12:54.256Z","path":"hello-world.html","comments":1,"layout":"page","_id":"cj21nzokg00021srln7et7gpa","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div><div class=\"line\">$ hexo sadfdsaf</div><div class=\"line\">$ hexo sdfsadfs</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">break</span>;</div><div class=\"line\">Object o = <span class=\"keyword\">new</span> Object(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div><div class=\"line\">$ hexo sadfdsaf</div><div class=\"line\">$ hexo sdfsadfs</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">break</span>;</div><div class=\"line\">Object o = <span class=\"keyword\">new</span> Object(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"Post":[{"title":"一个好用的Android比例自动适配的库","date":"2017-02-28T07:59:42.000Z","_content":"\n今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.\n刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.\n\n### 优势\n这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.\n而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.\n\n### 原理\n简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.\n\n这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.\n\n### 使用\n1.首先添加库引用.\n\n``` gradle\ndependencies {\n    compile 'com.zhy:autolayout:1.4.5'\n} \n```\n\n2.在项目的AndroidManifest中注明设计稿的尺寸。\n\n``` xml\n<meta-data android:name=\"design_width\" android:value=\"768\">\n</meta-data>\n<meta-data android:name=\"design_height\" android:value=\"1280\">\n</meta-data>\n```\n\n3.界面的改动.\n- Activity界面的用法\n\n让Activity继承AutoLayoutActivity\n\n``` java\npublic class MainActivity extends AutoLayoutActivity {\n\n.......\n\n}\n\n```\n\n- Fragment界面的用法\n\n在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).\n\n``` java \n@Nullable\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\tView view = inflater.inflate(.......);\n\t.........\n\t.........\n\tAutoUtils.autoSize(view);\n\treturn view;\n}\n```\n\n- 动态生成的view的用法\n\n以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.\n\n``` java\n//动态生成pageBtn,并且动态设置宽高间隔等\nTextView pageBtn = new TextView(getApplicationContext());\npageBtn.setPadding(10 , 20 , 30 , 40);\npageBtn.setTextSize(25);\nLinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(40 , 40);\nlayoutParams.setMargins(10 , 20 , 30 , 40);\n\n//在全部生成完毕后,添加至容器之前调整大小.\nAutoUtils.autoSize(pageBtn);\n\npageBtnContainer.addView(pageBtn , layoutParams);\n```\n\n做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.\n集成完毕,适配完成,就这么简单~\n\n### 其他\n感谢张鸿阳大神提供这么好用的库.\n\n[AndroidAutoLayout的github](https://github.com/hongyangAndroid/AndroidAutoLayout)\n[鸿神写的AutoLayout的介绍文章](http://blog.csdn.net/lmj623565791/article/details/49990941)\n[AndroidAutoLayout的项目介绍](https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md)\n\n以上介绍中还附上了许多进阶用法,学习中...","source":"_posts/2017-02-28-一个好用的Android比例自动适配的库.md","raw":"---\ntitle: 一个好用的Android比例自动适配的库\ndate: 2017-02-28 15:59:42\ntags: [Android,实用库]\ncategory: Android知识\n---\n\n今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.\n刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.\n\n### 优势\n这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.\n而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.\n\n### 原理\n简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.\n\n这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.\n\n### 使用\n1.首先添加库引用.\n\n``` gradle\ndependencies {\n    compile 'com.zhy:autolayout:1.4.5'\n} \n```\n\n2.在项目的AndroidManifest中注明设计稿的尺寸。\n\n``` xml\n<meta-data android:name=\"design_width\" android:value=\"768\">\n</meta-data>\n<meta-data android:name=\"design_height\" android:value=\"1280\">\n</meta-data>\n```\n\n3.界面的改动.\n- Activity界面的用法\n\n让Activity继承AutoLayoutActivity\n\n``` java\npublic class MainActivity extends AutoLayoutActivity {\n\n.......\n\n}\n\n```\n\n- Fragment界面的用法\n\n在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).\n\n``` java \n@Nullable\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\tView view = inflater.inflate(.......);\n\t.........\n\t.........\n\tAutoUtils.autoSize(view);\n\treturn view;\n}\n```\n\n- 动态生成的view的用法\n\n以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.\n\n``` java\n//动态生成pageBtn,并且动态设置宽高间隔等\nTextView pageBtn = new TextView(getApplicationContext());\npageBtn.setPadding(10 , 20 , 30 , 40);\npageBtn.setTextSize(25);\nLinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(40 , 40);\nlayoutParams.setMargins(10 , 20 , 30 , 40);\n\n//在全部生成完毕后,添加至容器之前调整大小.\nAutoUtils.autoSize(pageBtn);\n\npageBtnContainer.addView(pageBtn , layoutParams);\n```\n\n做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.\n集成完毕,适配完成,就这么简单~\n\n### 其他\n感谢张鸿阳大神提供这么好用的库.\n\n[AndroidAutoLayout的github](https://github.com/hongyangAndroid/AndroidAutoLayout)\n[鸿神写的AutoLayout的介绍文章](http://blog.csdn.net/lmj623565791/article/details/49990941)\n[AndroidAutoLayout的项目介绍](https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md)\n\n以上介绍中还附上了许多进阶用法,学习中...","slug":"一个好用的Android比例自动适配的库","published":1,"updated":"2017-02-28T09:59:26.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj21nzokx00031srlcm48esv2","content":"<p>今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.<br>刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.<br>而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.</p>\n<p>这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>1.首先添加库引用.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'com.zhy:autolayout:1.4.5'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.在项目的AndroidManifest中注明设计稿的尺寸。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_width\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"768\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_height\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"1280\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>3.界面的改动.</p>\n<ul>\n<li>Activity界面的用法</li>\n</ul>\n<p>让Activity继承AutoLayoutActivity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AutoLayoutActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">.......</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Fragment界面的用法</li>\n</ul>\n<p>在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Nullable</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\tView view = inflater.inflate(.......);</div><div class=\"line\">\t.........</div><div class=\"line\">\t.........</div><div class=\"line\">\tAutoUtils.autoSize(view);</div><div class=\"line\">\t<span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>动态生成的view的用法</li>\n</ul>\n<p>以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//动态生成pageBtn,并且动态设置宽高间隔等</span></div><div class=\"line\">TextView pageBtn = <span class=\"keyword\">new</span> TextView(getApplicationContext());</div><div class=\"line\">pageBtn.setPadding(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\">pageBtn.setTextSize(<span class=\"number\">25</span>);</div><div class=\"line\">LinearLayout.LayoutParams layoutParams = <span class=\"keyword\">new</span> LinearLayout.LayoutParams(<span class=\"number\">40</span> , <span class=\"number\">40</span>);</div><div class=\"line\">layoutParams.setMargins(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在全部生成完毕后,添加至容器之前调整大小.</span></div><div class=\"line\">AutoUtils.autoSize(pageBtn);</div><div class=\"line\"></div><div class=\"line\">pageBtnContainer.addView(pageBtn , layoutParams);</div></pre></td></tr></table></figure>\n<p>做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.<br>集成完毕,适配完成,就这么简单~</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>感谢张鸿阳大神提供这么好用的库.</p>\n<p><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout\" target=\"_blank\" rel=\"external\">AndroidAutoLayout的github</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/49990941\" target=\"_blank\" rel=\"external\">鸿神写的AutoLayout的介绍文章</a><br><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md\" target=\"_blank\" rel=\"external\">AndroidAutoLayout的项目介绍</a></p>\n<p>以上介绍中还附上了许多进阶用法,学习中…</p>\n","excerpt":"","more":"<p>今天刷github的时候发现一个鸿神写的很牛逼的适配库——AndroidAutoLayout.<br>刚好公司需要适配不同大小的屏幕,就简单试用了一下,感觉不错.集成简单,支持的控件广泛,使用灵活,虽然已经是15年写的了,但是现在用起来也没有发现什么冲突和崩溃.所以写到博客上推荐给大家.</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>这个库实现的最方便的功能是:我们拿到UI部门给出的以px为单位标注的设计图后,直接照抄上面的px尺寸就能写出一套适配于所有分辨率的xml layout.不仅免去了对着设计图把px转成dp的麻烦,而且也不用为不同的屏幕编写多套layout.很有一套UI打遍天下的感觉.<br>而且使用这个库理论上完全可以使用一个FrameLayout,里面的view使用margin定位,不用嵌套就能完成UI,对UI效率也有很大提升.</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>简单学习了一下源码,这个库的核心思想是,事先按照设计图设定好设计图的宽高(design_width/design_height),然后把设计图上所有控件的px尺寸按原单位px填入xml文件中,最终这个库会根据设计图总体尺寸和控件尺寸,算出控件在设计图上占的宽高比,再根据实际屏幕大小动态放大或缩小控件以保证控件在实际屏幕上占的比例和在设计图上占的比例一致.</p>\n<p>这种按比例缩放的方法不仅可以用在控件本身的大小上,也可以同理应用到控件的margin/padding/textSize等跟大小相关的属性上,统一缩放以后,在不同的屏幕上显示的效果就都跟设计图上一致了.</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>1.首先添加库引用.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'com.zhy:autolayout:1.4.5'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.在项目的AndroidManifest中注明设计稿的尺寸。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_width\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"768\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"design_height\"</span> <span class=\"attr\">android:value</span>=<span class=\"string\">\"1280\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">meta-data</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>3.界面的改动.</p>\n<ul>\n<li>Activity界面的用法</li>\n</ul>\n<p>让Activity继承AutoLayoutActivity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AutoLayoutActivity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">.......</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>Fragment界面的用法</li>\n</ul>\n<p>在onCreateView生成返回生成的view之前使用AutoUtils重新计算view的大小(一定要在对view的全部处理完成后再调整大小).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Nullable</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\tView view = inflater.inflate(.......);</div><div class=\"line\">\t.........</div><div class=\"line\">\t.........</div><div class=\"line\">\tAutoUtils.autoSize(view);</div><div class=\"line\">\t<span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>动态生成的view的用法</li>\n</ul>\n<p>以上两种都是对xml中写好的静态的layout进行大小适配的用法.如果需要动态生成view,比如生成页码按钮,添加到页码容器中,需要在生成结束后,添加到容器之前调用AutoUtils进行大小调整.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//动态生成pageBtn,并且动态设置宽高间隔等</span></div><div class=\"line\">TextView pageBtn = <span class=\"keyword\">new</span> TextView(getApplicationContext());</div><div class=\"line\">pageBtn.setPadding(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\">pageBtn.setTextSize(<span class=\"number\">25</span>);</div><div class=\"line\">LinearLayout.LayoutParams layoutParams = <span class=\"keyword\">new</span> LinearLayout.LayoutParams(<span class=\"number\">40</span> , <span class=\"number\">40</span>);</div><div class=\"line\">layoutParams.setMargins(<span class=\"number\">10</span> , <span class=\"number\">20</span> , <span class=\"number\">30</span> , <span class=\"number\">40</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在全部生成完毕后,添加至容器之前调整大小.</span></div><div class=\"line\">AutoUtils.autoSize(pageBtn);</div><div class=\"line\"></div><div class=\"line\">pageBtnContainer.addView(pageBtn , layoutParams);</div></pre></td></tr></table></figure>\n<p>做完之后,记得把dp换成px,大小换成跟设计图上标注的一样的px值.<br>集成完毕,适配完成,就这么简单~</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>感谢张鸿阳大神提供这么好用的库.</p>\n<p><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout\">AndroidAutoLayout的github</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/49990941\">鸿神写的AutoLayout的介绍文章</a><br><a href=\"https://github.com/hongyangAndroid/AndroidAutoLayout/blob/master/README.md\">AndroidAutoLayout的项目介绍</a></p>\n<p>以上介绍中还附上了许多进阶用法,学习中…</p>\n"},{"title":"为你的Github README生成漂亮的徽章和进度条","date":"2017-03-01T07:08:41.000Z","_content":"### github上常见的徽章标签和进度条\n平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如\n![](https://img.shields.io/github/release/qubyte/rubidium.svg)\n\n![](https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg)\n\n这样的徽章样式的标签.\n\n甚至还有些文章会有\n![](http://progressed.io/bar/28?title=progress)\n\n![](http://progressed.io/bar/91?title=done)\n这样的进度条,简直炫酷.这是怎么做到的呢?\n\n### 已有的标签小程序\n网上搜了一下,用[shields.io](http://shields.io/)就可以解决!\n但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.\n\n我的理解这个网站提供了一批\"标签小程序\",他们的作用是抓取一些动态的数据并自动生成标签图片.\n比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.\n使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.\n\n举例来说:\n![](/image/20170301152451.png)\n\n这一行的小程序功能就是用来展示某一个github项目最新的release版本号.\n\n点开你可以看到如下界面\n\n![](/image/20170301152527.png)\n\nImage这一行就是小程序的URL,前面的\n``` html\nhttps://img.shields.io/github/release/\n```\n是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目\n\n![](/image/20170301153213.png)\n\n它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成\n``` html\nhttps://img.shields.io/github/release/Tencent/tinker.svg\n```\n\n这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下\n![](https://img.shields.io/github/release/Tencent/tinker.svg)\n是不是很炫酷?\n再上[tinker-release](https://github.com/Tencent/tinker/releases)的github上看一下,果然显示的版本号就是tinker最新的版本号.\n\n等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?\n其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:\nLink后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.\n\n填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.\n\n最下方的\n```\nDocumentation\n\nIf your GitHub badge errors, it might be because you hit GitHub's rate limits.\nYou can increase Shields.io's rate limit by going to this page to add Shields as a GitHub application on your GitHub account.\n\n```\n\n的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.\n\n### 生成自定义徽章标签\n\n那么,如果我们想要生成的徽章字样和颜色[shields.io](http://shields.io/)上面没有怎么办?\n例如我们想生成一个\n![](https://img.shields.io/badge/Hey!-Bro~-red.svg)\n的徽章我们应该怎么做呢?\n\n把shields的网站拉到最后,可以看见\n\n![](/image/20170301160933.png)\n\n对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!\ncolor的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦\n\n### 生成进度条标签\n\n最后,我们想生成进度条怎么办?\n\n使用[progressed.io](https://github.com/fehmicansaglam/progressed.io)很简单就能生成!\n\n如图\n\n![](/image/20170301161732.png)\n\n只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.\n\n### 其他\n- 如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.\n\n``` markdown\n[![](徽章/进度条URL)](点击超链接)\n```\n\n- 自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.\n","source":"_posts/2017-03-01-为你的Github生成漂亮的徽章和进度条.md","raw":"---\ntitle: 为你的Github README生成漂亮的徽章和进度条\ndate: 2017-03-01 15:08:41\ntags: [github]\ncategory: 其他知识\n---\n### github上常见的徽章标签和进度条\n平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如\n![](https://img.shields.io/github/release/qubyte/rubidium.svg)\n\n![](https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg)\n\n这样的徽章样式的标签.\n\n甚至还有些文章会有\n![](http://progressed.io/bar/28?title=progress)\n\n![](http://progressed.io/bar/91?title=done)\n这样的进度条,简直炫酷.这是怎么做到的呢?\n\n### 已有的标签小程序\n网上搜了一下,用[shields.io](http://shields.io/)就可以解决!\n但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.\n\n我的理解这个网站提供了一批\"标签小程序\",他们的作用是抓取一些动态的数据并自动生成标签图片.\n比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.\n使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.\n\n举例来说:\n![](/image/20170301152451.png)\n\n这一行的小程序功能就是用来展示某一个github项目最新的release版本号.\n\n点开你可以看到如下界面\n\n![](/image/20170301152527.png)\n\nImage这一行就是小程序的URL,前面的\n``` html\nhttps://img.shields.io/github/release/\n```\n是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目\n\n![](/image/20170301153213.png)\n\n它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成\n``` html\nhttps://img.shields.io/github/release/Tencent/tinker.svg\n```\n\n这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下\n![](https://img.shields.io/github/release/Tencent/tinker.svg)\n是不是很炫酷?\n再上[tinker-release](https://github.com/Tencent/tinker/releases)的github上看一下,果然显示的版本号就是tinker最新的版本号.\n\n等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?\n其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:\nLink后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.\n\n填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.\n\n最下方的\n```\nDocumentation\n\nIf your GitHub badge errors, it might be because you hit GitHub's rate limits.\nYou can increase Shields.io's rate limit by going to this page to add Shields as a GitHub application on your GitHub account.\n\n```\n\n的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.\n\n### 生成自定义徽章标签\n\n那么,如果我们想要生成的徽章字样和颜色[shields.io](http://shields.io/)上面没有怎么办?\n例如我们想生成一个\n![](https://img.shields.io/badge/Hey!-Bro~-red.svg)\n的徽章我们应该怎么做呢?\n\n把shields的网站拉到最后,可以看见\n\n![](/image/20170301160933.png)\n\n对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!\ncolor的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦\n\n### 生成进度条标签\n\n最后,我们想生成进度条怎么办?\n\n使用[progressed.io](https://github.com/fehmicansaglam/progressed.io)很简单就能生成!\n\n如图\n\n![](/image/20170301161732.png)\n\n只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.\n\n### 其他\n- 如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.\n\n``` markdown\n[![](徽章/进度条URL)](点击超链接)\n```\n\n- 自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.\n","slug":"为你的Github生成漂亮的徽章和进度条","published":1,"updated":"2017-03-01T09:01:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj21nzol000041srlcdpe48vy","content":"<h3 id=\"github上常见的徽章标签和进度条\"><a href=\"#github上常见的徽章标签和进度条\" class=\"headerlink\" title=\"github上常见的徽章标签和进度条\"></a>github上常见的徽章标签和进度条</h3><p>平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如<br><img src=\"https://img.shields.io/github/release/qubyte/rubidium.svg\" alt=\"\"></p>\n<p><img src=\"https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg\" alt=\"\"></p>\n<p>这样的徽章样式的标签.</p>\n<p>甚至还有些文章会有<br><img src=\"http://progressed.io/bar/28?title=progress\" alt=\"\"></p>\n<p><img src=\"http://progressed.io/bar/91?title=done\" alt=\"\"><br>这样的进度条,简直炫酷.这是怎么做到的呢?</p>\n<h3 id=\"已有的标签小程序\"><a href=\"#已有的标签小程序\" class=\"headerlink\" title=\"已有的标签小程序\"></a>已有的标签小程序</h3><p>网上搜了一下,用<a href=\"http://shields.io/\" target=\"_blank\" rel=\"external\">shields.io</a>就可以解决!<br>但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.</p>\n<p>我的理解这个网站提供了一批”标签小程序”,他们的作用是抓取一些动态的数据并自动生成标签图片.<br>比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.<br>使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.</p>\n<p>举例来说:<br><img src=\"/image/20170301152451.png\" alt=\"\"></p>\n<p>这一行的小程序功能就是用来展示某一个github项目最新的release版本号.</p>\n<p>点开你可以看到如下界面</p>\n<p><img src=\"/image/20170301152527.png\" alt=\"\"></p>\n<p>Image这一行就是小程序的URL,前面的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/</div></pre></td></tr></table></figure></p>\n<p>是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目</p>\n<p><img src=\"/image/20170301153213.png\" alt=\"\"></p>\n<p>它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/Tencent/tinker.svg</div></pre></td></tr></table></figure></p>\n<p>这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下<br><img src=\"https://img.shields.io/github/release/Tencent/tinker.svg\" alt=\"\"><br>是不是很炫酷?<br>再上<a href=\"https://github.com/Tencent/tinker/releases\" target=\"_blank\" rel=\"external\">tinker-release</a>的github上看一下,果然显示的版本号就是tinker最新的版本号.</p>\n<p>等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?<br>其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:<br>Link后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.</p>\n<p>填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.</p>\n<p>最下方的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Documentation</div><div class=\"line\"></div><div class=\"line\">If your GitHub badge errors, it might be because you hit GitHub&apos;s rate limits.</div><div class=\"line\">You can increase Shields.io&apos;s rate limit by going to this page to add Shields as a GitHub application on your GitHub account.</div></pre></td></tr></table></figure></p>\n<p>的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.</p>\n<h3 id=\"生成自定义徽章标签\"><a href=\"#生成自定义徽章标签\" class=\"headerlink\" title=\"生成自定义徽章标签\"></a>生成自定义徽章标签</h3><p>那么,如果我们想要生成的徽章字样和颜色<a href=\"http://shields.io/\" target=\"_blank\" rel=\"external\">shields.io</a>上面没有怎么办?<br>例如我们想生成一个<br><img src=\"https://img.shields.io/badge/Hey!-Bro~-red.svg\" alt=\"\"><br>的徽章我们应该怎么做呢?</p>\n<p>把shields的网站拉到最后,可以看见</p>\n<p><img src=\"/image/20170301160933.png\" alt=\"\"></p>\n<p>对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!<br>color的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦</p>\n<h3 id=\"生成进度条标签\"><a href=\"#生成进度条标签\" class=\"headerlink\" title=\"生成进度条标签\"></a>生成进度条标签</h3><p>最后,我们想生成进度条怎么办?</p>\n<p>使用<a href=\"https://github.com/fehmicansaglam/progressed.io\" target=\"_blank\" rel=\"external\">progressed.io</a>很简单就能生成!</p>\n<p>如图</p>\n<p><img src=\"/image/20170301161732.png\" alt=\"\"></p>\n<p>只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">![</span>](<span class=\"link\">徽章/进度条URL</span>)](<span class=\"link\">点击超链接</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"github上常见的徽章标签和进度条\"><a href=\"#github上常见的徽章标签和进度条\" class=\"headerlink\" title=\"github上常见的徽章标签和进度条\"></a>github上常见的徽章标签和进度条</h3><p>平时在上github的时候看到别人写的精美的README,我总是感到非常的羡慕.近来我也开始使用markdown写博客,看到之前有一些项目的README的开始部分总是会有例如<br><img src=\"https://img.shields.io/github/release/qubyte/rubidium.svg\" alt=\"\"></p>\n<p><img src=\"https://img.shields.io/circleci/project/github/RedSparr0w/node-csgo-parser.svg\" alt=\"\"></p>\n<p>这样的徽章样式的标签.</p>\n<p>甚至还有些文章会有<br><img src=\"http://progressed.io/bar/28?title=progress\" alt=\"\"></p>\n<p><img src=\"http://progressed.io/bar/91?title=done\" alt=\"\"><br>这样的进度条,简直炫酷.这是怎么做到的呢?</p>\n<h3 id=\"已有的标签小程序\"><a href=\"#已有的标签小程序\" class=\"headerlink\" title=\"已有的标签小程序\"></a>已有的标签小程序</h3><p>网上搜了一下,用<a href=\"http://shields.io/\">shields.io</a>就可以解决!<br>但是这个网站怎么用?貌似写的不太清楚,网上也没有详细一点的介绍微博,只能自己试验了一下.</p>\n<p>我的理解这个网站提供了一批”标签小程序”,他们的作用是抓取一些动态的数据并自动生成标签图片.<br>比如抓取github上项目的最新的release版本号生成release标签,抓取twitter的账号关注人数生成关注标签等等.<br>使用这种标签能够保证每次刷新网页都会重新抓取数据,并且重新更新标签上的文字.这样就实现了动态变化的徽章标签.</p>\n<p>举例来说:<br><img src=\"/image/20170301152451.png\" alt=\"\"></p>\n<p>这一行的小程序功能就是用来展示某一个github项目最新的release版本号.</p>\n<p>点开你可以看到如下界面</p>\n<p><img src=\"/image/20170301152527.png\" alt=\"\"></p>\n<p>Image这一行就是小程序的URL,前面的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/</div></pre></td></tr></table></figure></p>\n<p>是小程序的位置,后面需要填写要获取的github用户名和项目名.svg,例如著名的tinker项目</p>\n<p><img src=\"/image/20170301153213.png\" alt=\"\"></p>\n<p>它的用户名是Tencent,项目名是tinker,所以我们把上面的小程序的URL补全成<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://img.shields.io/github/release/Tencent/tinker.svg</div></pre></td></tr></table></figure></p>\n<p>这样一个小勋章就做好了,我们可以把上面的URL粘贴到浏览器地址栏试一下<br><img src=\"https://img.shields.io/github/release/Tencent/tinker.svg\" alt=\"\"><br>是不是很炫酷?<br>再上<a href=\"https://github.com/Tencent/tinker/releases\">tinker-release</a>的github上看一下,果然显示的版本号就是tinker最新的版本号.</p>\n<p>等等,这就生成好了?那上面的小程序界面其他的部分是做什么的呢?<br>其实小程序只是为我们提供了一个便捷生成markdown图片链接的方式:<br>Link后面可以填写我们希望点击徽章跳转到的URL,注意这个地址跟徽章上显示什么毫无关系.能够影响徽章上的文字的只有Image后面的URL.</p>\n<p>填写了Link后,下方的Markdown后就会自动生成对应的markdown语法生成的徽章图片链接.如果我们在写github的README,就可以直接复制Markdown后面的文字,粘贴到README里面,是不是很方便.</p>\n<p>最下方的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Documentation</div><div class=\"line\"></div><div class=\"line\">If your GitHub badge errors, it might be because you hit GitHub&apos;s rate limits.</div><div class=\"line\">You can increase Shields.io&apos;s rate limit by going to this page to add Shields as a GitHub application on your GitHub account.</div></pre></td></tr></table></figure></p>\n<p>的意思是如果小程序无法自动获得版本号,可能是由于github对小程序有限制,想要减少这种限制可以点击going to this page 去授权Shields访问github.</p>\n<h3 id=\"生成自定义徽章标签\"><a href=\"#生成自定义徽章标签\" class=\"headerlink\" title=\"生成自定义徽章标签\"></a>生成自定义徽章标签</h3><p>那么,如果我们想要生成的徽章字样和颜色<a href=\"http://shields.io/\">shields.io</a>上面没有怎么办?<br>例如我们想生成一个<br><img src=\"https://img.shields.io/badge/Hey!-Bro~-red.svg\" alt=\"\"><br>的徽章我们应该怎么做呢?</p>\n<p>把shields的网站拉到最后,可以看见</p>\n<p><img src=\"/image/20170301160933.png\" alt=\"\"></p>\n<p>对,就是这里!像我这样填,再点击Make Badge按钮就可以生成我们想要的任何徽章了!<br>color的颜色如果不知道怎么填,可以点击输入框会有下拉项提供选择哦</p>\n<h3 id=\"生成进度条标签\"><a href=\"#生成进度条标签\" class=\"headerlink\" title=\"生成进度条标签\"></a>生成进度条标签</h3><p>最后,我们想生成进度条怎么办?</p>\n<p>使用<a href=\"https://github.com/fehmicansaglam/progressed.io\">progressed.io</a>很简单就能生成!</p>\n<p>如图</p>\n<p><img src=\"/image/20170301161732.png\" alt=\"\"></p>\n<p>只要把URL中的数字换成自己想要的,就可以生成各种样式和颜色的进度条了.</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>如果我们在写markdown的时候想为我们的徽章或者进度条添加点击跳转的超链接,可以使用超链接和图片的语法嵌套来写,具体可以参照markdown标准语法.</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">![</span>](<span class=\"link\">徽章/进度条URL</span>)](<span class=\"link\">点击超链接</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义徽章和进度条由于参数是写死的,不会根据网络的数据自动变化上面的文字,所以,这些标签是静态的,修改的时候需要我们手动更改URL.</li>\n</ul>\n"},{"title":"如何使用github和Hexo搭建个人博客","date":"2017-02-23T07:05:13.000Z","_content":"\n\n## 为什么要写个人博客?\n这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.\n\n之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^\n\n## 为什么要自己搭建博客系统?\n想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?\n\n所以,我果断放弃了博客平台,自己搭架子!开干!\n\n## 大体上需要做什么工作?\n博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.\n\n1. 怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?\n2. 我们的博客网页文件放在什么地方?\n\n### 博客框架介绍\n以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.\n那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.\n\n博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!\n\n\n而博客框架一般分为**动态页面框架**和**静态页面框架**两种.\n#### 动态框架\n动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.\n由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.\n\n#### 静态框架\n这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.\n这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).\n\n### 网页存放空间介绍\n我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.\n\n#### 购买VPS\nVPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.\n由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.\n\n#### 使用Github pages\nGitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.\n\n## 为什么选择GitHub pages + Hexo?\n看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!\n一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!\n对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.\n\n那么,既然方案确定了,那就剩实施了,我们一步一步来完成:\n\n\n## 如何获得github page网页空间?\n使用github我们当然需要先安装git,如果你没有用过git,请先学习一下[Git使用教程](http://www.cnblogs.com/tugenhua0707/p/4050072.html).\n获得github page空间非常简单.首先,你得有一个女朋...啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去[注册一个](https://github.com/join?source=header-home),这个网站对程序员非常有用,真的!\n\n有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).\n\n第一步我们点击sign in登录github.\n![](/image/20170223175427.png)\n\n第二步我们点击New repository建立一个新的仓库\n![](/image/20170223174812.png)\n\n第三步在仓库名称里面输入**我们的用户名.github.io**.\n注意!必须是这个名字,其他的名字不行!\n比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io\n![](/image/20170223175801.png)\n\n第四步选择public,并且点击create repository建立仓库\n\n建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过\n``` \nhttp://我们的用户名.github.io\n```\n就能访问我们的博客啦.\n\n今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.\n\n## 如何部署Hexo框架?\nHexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs\n\n在[Nodejs官网](https://nodejs.org/en/)上下载并安装Nodejs.\n\n安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog\n\n在文件夹里右键选择git bash 打开命令行\n\n使用npm安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.\n由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.\n\n由于我们要提交到github上,我们还需要安装hexo git提交插件.\n``` base\nnpm install hexo-deployer-git --save\n```\n\n下面初始化博客工程\n\n``` bash\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n上面的folder为博客的工程名,我们可以自己起,例如testBlog\n\n完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.\n\n> title: 这里填写博客的标题\n> subtitle: 这里填写博客的副标题\n> description: 这里填写博客的描述\n> author: 这里填写博客的作者\n> language: 这里填写博客的语言,如果是中文填写\"zh\"\n> url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为\"aaa\",这里就填写\"http://aaa.github.io\"\n> deploy:\n> type: 这里填写\"git\"\n> repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为\"aaa\",则此处填写\"git@github.com:aaa/aaa.github.io.git\"\n\n暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.\n如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看[官方配置说明](https://hexo.io/docs/configuration.html)\n\n此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.\n\n``` base\nhexo g -d\n```\n\n这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.\n等待命令执行完毕.\n\n好了,现在我们访问我们的博客试一下,打开浏览器输入\n```\nhttp://你的github用户名.github.io \n```\n然后回车.\n![](/image/20170224160822.png)\n哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.\n\n## 如何写文章?\n博客架好了,可是我们怎么写文章呢?\n也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例\n``` base\ncd /d/blog/testBlog\nhexo new goodDay\n```\n这样我们就建立了一篇名叫goodDay的新文章.\n\n此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\\\_posts.\n我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.\n从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看[markdown入门](http://sspai.com/25137/)\n虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如[MarkdownPad](http://markdownpad.com),来编辑,可以方便的实现边编辑边预览,非常方便.\n文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.\n\n打开goodDay.md,我们可以看到如下的内容\n```\n---\ntitle: xxx\ndate: xxx\n---\n```\n这些以---开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为\"好天气\",文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:\"前端知识\",方便以后管理.\ngoodDay.md修改如下\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n```\n\n在---下方我们可以编辑我们文章的正文了,我们简单写两句\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n\n## 好天气啊\n### What a Good Day!\n真是适合春游的好天气\n```\n\n保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?\n``` base\nhexo g -d\n```\n\n这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~\\(^o^)/~\n![](/image/20170224163724.png)\n\n好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.\n\n由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.\n\n感谢各位能看到这里.希望大家都能玩的开心.\n\n\n\n","source":"_posts/2017-02-23-如何使用gitHub和Hexo搭建个人博客.md","raw":"---\ntitle: 如何使用github和Hexo搭建个人博客\ndate: 2017-02-23 15:05:13\ntags: [Hexo,Web,github]\ncategory: Web前端知识\n---\n\n\n## 为什么要写个人博客?\n这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.\n\n之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^\n\n## 为什么要自己搭建博客系统?\n想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?\n\n所以,我果断放弃了博客平台,自己搭架子!开干!\n\n## 大体上需要做什么工作?\n博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.\n\n1. 怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?\n2. 我们的博客网页文件放在什么地方?\n\n### 博客框架介绍\n以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.\n那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.\n\n博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!\n\n\n而博客框架一般分为**动态页面框架**和**静态页面框架**两种.\n#### 动态框架\n动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.\n由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.\n\n#### 静态框架\n这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.\n这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).\n\n### 网页存放空间介绍\n我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.\n\n#### 购买VPS\nVPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.\n由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.\n\n#### 使用Github pages\nGitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.\n\n## 为什么选择GitHub pages + Hexo?\n看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!\n一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!\n对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.\n\n那么,既然方案确定了,那就剩实施了,我们一步一步来完成:\n\n\n## 如何获得github page网页空间?\n使用github我们当然需要先安装git,如果你没有用过git,请先学习一下[Git使用教程](http://www.cnblogs.com/tugenhua0707/p/4050072.html).\n获得github page空间非常简单.首先,你得有一个女朋...啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去[注册一个](https://github.com/join?source=header-home),这个网站对程序员非常有用,真的!\n\n有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).\n\n第一步我们点击sign in登录github.\n![](/image/20170223175427.png)\n\n第二步我们点击New repository建立一个新的仓库\n![](/image/20170223174812.png)\n\n第三步在仓库名称里面输入**我们的用户名.github.io**.\n注意!必须是这个名字,其他的名字不行!\n比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io\n![](/image/20170223175801.png)\n\n第四步选择public,并且点击create repository建立仓库\n\n建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过\n``` \nhttp://我们的用户名.github.io\n```\n就能访问我们的博客啦.\n\n今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.\n\n## 如何部署Hexo框架?\nHexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs\n\n在[Nodejs官网](https://nodejs.org/en/)上下载并安装Nodejs.\n\n安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog\n\n在文件夹里右键选择git bash 打开命令行\n\n使用npm安装Hexo\n\n``` bash\nnpm install -g hexo-cli\n```\n-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.\n由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.\n\n由于我们要提交到github上,我们还需要安装hexo git提交插件.\n``` base\nnpm install hexo-deployer-git --save\n```\n\n下面初始化博客工程\n\n``` bash\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n上面的folder为博客的工程名,我们可以自己起,例如testBlog\n\n完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.\n\n> title: 这里填写博客的标题\n> subtitle: 这里填写博客的副标题\n> description: 这里填写博客的描述\n> author: 这里填写博客的作者\n> language: 这里填写博客的语言,如果是中文填写\"zh\"\n> url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为\"aaa\",这里就填写\"http://aaa.github.io\"\n> deploy:\n> type: 这里填写\"git\"\n> repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为\"aaa\",则此处填写\"git@github.com:aaa/aaa.github.io.git\"\n\n暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.\n如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看[官方配置说明](https://hexo.io/docs/configuration.html)\n\n此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.\n\n``` base\nhexo g -d\n```\n\n这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.\n等待命令执行完毕.\n\n好了,现在我们访问我们的博客试一下,打开浏览器输入\n```\nhttp://你的github用户名.github.io \n```\n然后回车.\n![](/image/20170224160822.png)\n哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.\n\n## 如何写文章?\n博客架好了,可是我们怎么写文章呢?\n也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例\n``` base\ncd /d/blog/testBlog\nhexo new goodDay\n```\n这样我们就建立了一篇名叫goodDay的新文章.\n\n此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\\\_posts.\n我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.\n从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看[markdown入门](http://sspai.com/25137/)\n虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如[MarkdownPad](http://markdownpad.com),来编辑,可以方便的实现边编辑边预览,非常方便.\n文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.\n\n打开goodDay.md,我们可以看到如下的内容\n```\n---\ntitle: xxx\ndate: xxx\n---\n```\n这些以---开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为\"好天气\",文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:\"前端知识\",方便以后管理.\ngoodDay.md修改如下\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n```\n\n在---下方我们可以编辑我们文章的正文了,我们简单写两句\n```\n---\ntitle: 好天气\ndate: 2017-02-24 15:00\ntags: [t1,t2]\ncategories: 前端知识\n---\n\n## 好天气啊\n### What a Good Day!\n真是适合春游的好天气\n```\n\n保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?\n``` base\nhexo g -d\n```\n\n这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~\\(^o^)/~\n![](/image/20170224163724.png)\n\n好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.\n\n由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.\n\n感谢各位能看到这里.希望大家都能玩的开心.\n\n\n\n","slug":"如何使用gitHub和Hexo搭建个人博客","published":1,"updated":"2017-04-25T02:27:30.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj21nzol600071srlnd05g2rf","content":"<h2 id=\"为什么要写个人博客\"><a href=\"#为什么要写个人博客\" class=\"headerlink\" title=\"为什么要写个人博客?\"></a>为什么要写个人博客?</h2><p>这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.</p>\n<p>之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^</p>\n<h2 id=\"为什么要自己搭建博客系统\"><a href=\"#为什么要自己搭建博客系统\" class=\"headerlink\" title=\"为什么要自己搭建博客系统?\"></a>为什么要自己搭建博客系统?</h2><p>想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?</p>\n<p>所以,我果断放弃了博客平台,自己搭架子!开干!</p>\n<h2 id=\"大体上需要做什么工作\"><a href=\"#大体上需要做什么工作\" class=\"headerlink\" title=\"大体上需要做什么工作?\"></a>大体上需要做什么工作?</h2><p>博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.</p>\n<ol>\n<li>怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?</li>\n<li>我们的博客网页文件放在什么地方?</li>\n</ol>\n<h3 id=\"博客框架介绍\"><a href=\"#博客框架介绍\" class=\"headerlink\" title=\"博客框架介绍\"></a>博客框架介绍</h3><p>以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.<br>那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.</p>\n<p>博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!</p>\n<p>而博客框架一般分为<strong>动态页面框架</strong>和<strong>静态页面框架</strong>两种.</p>\n<h4 id=\"动态框架\"><a href=\"#动态框架\" class=\"headerlink\" title=\"动态框架\"></a>动态框架</h4><p>动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.<br>由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.</p>\n<h4 id=\"静态框架\"><a href=\"#静态框架\" class=\"headerlink\" title=\"静态框架\"></a>静态框架</h4><p>这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.<br>这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).</p>\n<h3 id=\"网页存放空间介绍\"><a href=\"#网页存放空间介绍\" class=\"headerlink\" title=\"网页存放空间介绍\"></a>网页存放空间介绍</h3><p>我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.</p>\n<h4 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h4><p>VPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.<br>由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.</p>\n<h4 id=\"使用Github-pages\"><a href=\"#使用Github-pages\" class=\"headerlink\" title=\"使用Github pages\"></a>使用Github pages</h4><p>GitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.</p>\n<h2 id=\"为什么选择GitHub-pages-Hexo\"><a href=\"#为什么选择GitHub-pages-Hexo\" class=\"headerlink\" title=\"为什么选择GitHub pages + Hexo?\"></a>为什么选择GitHub pages + Hexo?</h2><p>看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!<br>一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!<br>对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.</p>\n<p>那么,既然方案确定了,那就剩实施了,我们一步一步来完成:</p>\n<h2 id=\"如何获得github-page网页空间\"><a href=\"#如何获得github-page网页空间\" class=\"headerlink\" title=\"如何获得github page网页空间?\"></a>如何获得github page网页空间?</h2><p>使用github我们当然需要先安装git,如果你没有用过git,请先学习一下<a href=\"http://www.cnblogs.com/tugenhua0707/p/4050072.html\" target=\"_blank\" rel=\"external\">Git使用教程</a>.<br>获得github page空间非常简单.首先,你得有一个女朋…啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去<a href=\"https://github.com/join?source=header-home\" target=\"_blank\" rel=\"external\">注册一个</a>,这个网站对程序员非常有用,真的!</p>\n<p>有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).</p>\n<p>第一步我们点击sign in登录github.<br><img src=\"/image/20170223175427.png\" alt=\"\"></p>\n<p>第二步我们点击New repository建立一个新的仓库<br><img src=\"/image/20170223174812.png\" alt=\"\"></p>\n<p>第三步在仓库名称里面输入<strong>我们的用户名.github.io</strong>.<br>注意!必须是这个名字,其他的名字不行!<br>比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io<br><img src=\"/image/20170223175801.png\" alt=\"\"></p>\n<p>第四步选择public,并且点击create repository建立仓库</p>\n<p>建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://我们的用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>就能访问我们的博客啦.</p>\n<p>今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.</p>\n<h2 id=\"如何部署Hexo框架\"><a href=\"#如何部署Hexo框架\" class=\"headerlink\" title=\"如何部署Hexo框架?\"></a>如何部署Hexo框架?</h2><p>Hexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs</p>\n<p>在<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Nodejs官网</a>上下载并安装Nodejs.</p>\n<p>安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog</p>\n<p>在文件夹里右键选择git bash 打开命令行</p>\n<p>使用npm安装Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.<br>由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.</p>\n<p>由于我们要提交到github上,我们还需要安装hexo git提交插件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>下面初始化博客工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>上面的folder为博客的工程名,我们可以自己起,例如testBlog</p>\n<p>完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.</p>\n<blockquote>\n<p>title: 这里填写博客的标题<br>subtitle: 这里填写博客的副标题<br>description: 这里填写博客的描述<br>author: 这里填写博客的作者<br>language: 这里填写博客的语言,如果是中文填写”zh”<br>url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为”aaa”,这里就填写”<a href=\"http://aaa.github.io\" target=\"_blank\" rel=\"external\">http://aaa.github.io</a>“<br>deploy:<br>type: 这里填写”git”<br>repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为”aaa”,则此处填写”git@github.com:aaa/aaa.github.io.git”</p>\n</blockquote>\n<p>暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.<br>如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看<a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"external\">官方配置说明</a></p>\n<p>此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<p>这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.<br>等待命令执行完毕.</p>\n<p>好了,现在我们访问我们的博客试一下,打开浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://你的github用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>然后回车.<br><img src=\"/image/20170224160822.png\" alt=\"\"><br>哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.</p>\n<h2 id=\"如何写文章\"><a href=\"#如何写文章\" class=\"headerlink\" title=\"如何写文章?\"></a>如何写文章?</h2><p>博客架好了,可是我们怎么写文章呢?<br>也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /d/blog/testBlog</div><div class=\"line\">hexo new goodDay</div></pre></td></tr></table></figure></p>\n<p>这样我们就建立了一篇名叫goodDay的新文章.</p>\n<p>此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\_posts.<br>我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.<br>从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看<a href=\"http://sspai.com/25137/\" target=\"_blank\" rel=\"external\">markdown入门</a><br>虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如<a href=\"http://markdownpad.com\" target=\"_blank\" rel=\"external\">MarkdownPad</a>,来编辑,可以方便的实现边编辑边预览,非常方便.<br>文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.</p>\n<p>打开goodDay.md,我们可以看到如下的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: xxx</div><div class=\"line\">date: xxx</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>这些以—开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为”好天气”,文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:”前端知识”,方便以后管理.<br>goodDay.md修改如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>在—下方我们可以编辑我们文章的正文了,我们简单写两句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">## 好天气啊</div><div class=\"line\">### What a Good Day!</div><div class=\"line\">真是适合春游的好天气</div></pre></td></tr></table></figure></p>\n<p>保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure></p>\n<p>这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~(^o^)/~<br><img src=\"/image/20170224163724.png\" alt=\"\"></p>\n<p>好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.</p>\n<p>由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.</p>\n<p>感谢各位能看到这里.希望大家都能玩的开心.</p>\n","excerpt":"","more":"<h2 id=\"为什么要写个人博客\"><a href=\"#为什么要写个人博客\" class=\"headerlink\" title=\"为什么要写个人博客?\"></a>为什么要写个人博客?</h2><p>这一阵子是项目间隙,略闲,之前的项目中学到了很多东西,一直没有时间整理沉淀,现在终于有时间了,列了个计划打算把各种遇到问题和解决经验沉淀到文字里,方便自己今后查看,同时也可以分享给别人,利人利己.</p>\n<p>之前工作之余有些零碎经验都是写到网易云笔记之类的笔记应用里,这样虽然比较方便,但是不分享的话别人就不能看,不如博客这种形式,谁都可以搜到,更加便于传播.而且作为一个码农,拥有一个高大上的技术博客,也是一件高逼格的事不是吗 ^_^</p>\n<h2 id=\"为什么要自己搭建博客系统\"><a href=\"#为什么要自己搭建博客系统\" class=\"headerlink\" title=\"为什么要自己搭建博客系统?\"></a>为什么要自己搭建博客系统?</h2><p>想要写一个技术博客,有很多种途径,比较快速简单的方法是找一个像CSDN blog这样的博客平台,申请一个账号直接就可以写,但是总觉得作为程序员,这样还不够酷.那么为什么尝试不自己搭建一个博客试试呢?既可以满足写博客的需求,也可以在搭建的过程中学习web相关的知识,一举两得.而且自己搭建博客可以不用被博客平台的框架束缚,博客的可定制性更强,我们想加什么就可以加什么,那不是更爽?</p>\n<p>所以,我果断放弃了博客平台,自己搭架子!开干!</p>\n<h2 id=\"大体上需要做什么工作\"><a href=\"#大体上需要做什么工作\" class=\"headerlink\" title=\"大体上需要做什么工作?\"></a>大体上需要做什么工作?</h2><p>博主毕业以后一直是从事Android App的开发,对web前端的工作接触的比较少,除了计算机和网络的基础知识,几乎是0基础.在查了很多资料以后,大致了解到搭建博客系统主要需要解决两个问题.</p>\n<ol>\n<li>怎样便捷的把我们文章中的文字编码成网页文件,并且组织分类建立一个博客网站?</li>\n<li>我们的博客网页文件放在什么地方?</li>\n</ol>\n<h3 id=\"博客框架介绍\"><a href=\"#博客框架介绍\" class=\"headerlink\" title=\"博客框架介绍\"></a>博客框架介绍</h3><p>以博主的web开发能力,每篇文章都自己写网页是不现实的,而即使是web开发大神,也不会所有网页都自己写,因为太麻烦太繁琐了.<br>那么有没有什么自动化的整理排版网页生成工具可以用呢?当然有!我们需要利用博客框架来自动生成网页文件.</p>\n<p>博客框架是指一个自动化的程序,我们只需要以框架要求的语法(如markdown)提供我们博客文章的材料,它就会自动帮我们排版文字,转换成网页文件,生成网页层级组织,生成网站首页,一切都是全自动的,我们只需要关心我们文章的内容就够了.自动化万岁!</p>\n<p>而博客框架一般分为<strong>动态页面框架</strong>和<strong>静态页面框架</strong>两种.</p>\n<h4 id=\"动态框架\"><a href=\"#动态框架\" class=\"headerlink\" title=\"动态框架\"></a>动态框架</h4><p>动态页面框架是指用户在访问我们的网站的时候,所有的网页都是在访问的时候动态生成的,平时没有,访问的时候现场生成,这种框架的好处是搭建简单,现用现做,支持评论互动,功能比较强大.但是需要服务器支持php和数据库.这一类的框架比较著名的是WordPress.<br>由于这类框架要求服务器有数据库和php支持,本篇文章暂时不讨论,我会在今后的文章中写一写如何使用vps+wordpress搭建个人博客.</p>\n<h4 id=\"静态框架\"><a href=\"#静态框架\" class=\"headerlink\" title=\"静态框架\"></a>静态框架</h4><p>这一类的框架是指我们每次在写完文章后启动框架为我们生成一套网页文件，这套文件部署在服务器上供别人访问，其中的内容是不会变动的，直到我们下次修改或写新的文章后再生成一套新的文件部署到服务器后，网站的内容才会改变．网站上的内容是静态的，因此成为静态博客框架．这类框架比较有名的就是今天要介绍的Hexo.<br>这类框架的好处是对服务器要求简单,不需要php和数据库支持.但是比如文章评论等动态改变网页内容的功能,在这种框架中生成的网页中就无法实现了(事实上,如果一定要使用评论功能,可以使用Disque之类的第三方服务集成到Hexo生成的网站中来实现评论,原理还是利用第三方的服务商的数据库和服务器来存放评论数据,本文就不多介绍了).</p>\n<h3 id=\"网页存放空间介绍\"><a href=\"#网页存放空间介绍\" class=\"headerlink\" title=\"网页存放空间介绍\"></a>网页存放空间介绍</h3><p>我们的网页生成了以后,我们还要找地方去存放它们,这时候我们就有了很多选择.</p>\n<h4 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h4><p>VPS是虚拟服务器的简写,相当于一台完整的计算机,可以安装软件,存放数据,下载上传,但是它不在我们面前,而是在VPS服务商的机房里,我们只能通过远程去操作这台计算机.<br>由于VPS就相当于一台完整的计算机,所以我们在上面的可操作性比较大,我们可以安装服务器程序用来提供网页下载服务,安装php提供后端处理能力,安装mysql提供数据库服务.非常灵活.因此VPS可以同时支持动态博客框架和静态博客框架.</p>\n<h4 id=\"使用Github-pages\"><a href=\"#使用Github-pages\" class=\"headerlink\" title=\"使用Github pages\"></a>使用Github pages</h4><p>GitHub Pages是GitHub提供的一项免费服务.每个GitHub账号可以申请一个pages仓库用来存放网页文件.而GitHub在已经安装好了服务器程序以便于浏览器访问这些网页.由于GitHub Pages不支持php和数据库,因此只能在上面部署静态博客框架.</p>\n<h2 id=\"为什么选择GitHub-pages-Hexo\"><a href=\"#为什么选择GitHub-pages-Hexo\" class=\"headerlink\" title=\"为什么选择GitHub pages + Hexo?\"></a>为什么选择GitHub pages + Hexo?</h2><p>看起来GitHub pages比起VPS限制很多,但是Github pages有一个巨大的优势——免费!没错,它是免费的!<br>一般国外的VPS像Vurtl、Linode这样的便宜的也要35-40/月,稍微靠谱点的就100+/月了,国内的就更贵,带宽流量限制不说,最便宜的也得60+大洋,这个成本对于个人博客来说太高了.而使用GitHub page,可以免费获得每个账号300M的网页存放空间.对于个人来说足够了,而且GitHub也是程序员牛人聚集的地方,很多大牛也是用GitHub pages搭建自己的博客,因此这也是一件很有逼格的事!<br>对于博客框架,动态框架由于需要数据库和php支持,因此就不能使用了,但是静态框架还是可以用的.而Hexo也是现在使用比较广的,也比较简单部署的静态框架.所以我们选择GitHub pages + Hexo来部署我们的博客.</p>\n<p>那么,既然方案确定了,那就剩实施了,我们一步一步来完成:</p>\n<h2 id=\"如何获得github-page网页空间\"><a href=\"#如何获得github-page网页空间\" class=\"headerlink\" title=\"如何获得github page网页空间?\"></a>如何获得github page网页空间?</h2><p>使用github我们当然需要先安装git,如果你没有用过git,请先学习一下<a href=\"http://www.cnblogs.com/tugenhua0707/p/4050072.html\">Git使用教程</a>.<br>获得github page空间非常简单.首先,你得有一个女朋…啊不对,是github账号,如果你已经有了,那非常好!如果没有,快去<a href=\"https://github.com/join?source=header-home\">注册一个</a>,这个网站对程序员非常有用,真的!</p>\n<p>有了github账号之后我们需要按照特定的规则申请github page的数据仓库(repository).</p>\n<p>第一步我们点击sign in登录github.<br><img src=\"/image/20170223175427.png\" alt=\"\"></p>\n<p>第二步我们点击New repository建立一个新的仓库<br><img src=\"/image/20170223174812.png\" alt=\"\"></p>\n<p>第三步在仓库名称里面输入<strong>我们的用户名.github.io</strong>.<br>注意!必须是这个名字,其他的名字不行!<br>比如我们的用户名是aaa,我们的仓库名就必须是aaa.github.io<br><img src=\"/image/20170223175801.png\" alt=\"\"></p>\n<p>第四步选择public,并且点击create repository建立仓库</p>\n<p>建立好之后我们就已经有了自己的网页存放空间啦!对!就这么简单!今后通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://我们的用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>就能访问我们的博客啦.</p>\n<p>今后我们部署网页的时候只要先clone我们的仓库,然后修改其中的内容(例如添加网页删除网页等),最后commit + push到github上就可以了.当然,这也很麻烦,所以Hexo为我们提供了一键生成+发布的功能,今后连commit+push也可以省去啦,这个我们后面会说.</p>\n<h2 id=\"如何部署Hexo框架\"><a href=\"#如何部署Hexo框架\" class=\"headerlink\" title=\"如何部署Hexo框架?\"></a>如何部署Hexo框架?</h2><p>Hexo需要部署在我们自己的计算机上,由于Hexo是基于Nodejs编写的,所以我们首先需要安装Nodejs</p>\n<p>在<a href=\"https://nodejs.org/en/\">Nodejs官网</a>上下载并安装Nodejs.</p>\n<p>安装完毕后在我们的电脑里建立一个新的文件夹来存放我们的博客工程文件,例如D:/blog</p>\n<p>在文件夹里右键选择git bash 打开命令行</p>\n<p>使用npm安装Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<p>-g参数是要求全局安装,这样我们以后就可以直接在命令行里使用hexo命令了.<br>由于npm安装在国内速度简直是龟速,在使用npm install安装的时候建议使用vpn代理加快安装.</p>\n<p>由于我们要提交到github上,我们还需要安装hexo git提交插件.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>下面初始化博客工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init &lt;folder&gt;</div><div class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>上面的folder为博客的工程名,我们可以自己起,例如testBlog</p>\n<p>完毕以后我们可以进入我们之前初始化好的文件夹,例如D:/blog/testBlog中,修改_config.yml文件来调整hexo的设置.</p>\n<blockquote>\n<p>title: 这里填写博客的标题<br>subtitle: 这里填写博客的副标题<br>description: 这里填写博客的描述<br>author: 这里填写博客的作者<br>language: 这里填写博客的语言,如果是中文填写”zh”<br>url: 这里填写我们之前申请的博客网页存放空间的网址,例如我们的github用户名为”aaa”,这里就填写”<a href=\"http://aaa.github.io\">http://aaa.github.io</a>“<br>deploy:<br>type: 这里填写”git”<br>repo: 这里填写我们之前申请的git仓库的地址,例如我们的用户名为”aaa”,则此处填写”git@github.com:aaa/aaa.github.io.git”</p>\n</blockquote>\n<p>暂时就填写这么多就够了,其他的部分暂时先不做修改,保存,退出.<br>如果需要了解更多hexo的配置或者想要做更高级的定制,可以查看<a href=\"https://hexo.io/docs/configuration.html\">官方配置说明</a></p>\n<p>此时我们的Hexo基本已经假设好了,现在生成一下我们的博客看看效果.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<p>这个命令的意思是使用hexo生成整个博客的网页文件,并且上传到我们刚才repo里面填写的git仓库里.hexo会自动检索我们博客文章的改动,删除,增加,并生成一套新的网页.<br>等待命令执行完毕.</p>\n<p>好了,现在我们访问我们的博客试一下,打开浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://你的github用户名.github.io</div></pre></td></tr></table></figure></p>\n<p>然后回车.<br><img src=\"/image/20170224160822.png\" alt=\"\"><br>哈哈!博客架好了!这就是我们博客的主页,并且Hexo还为我们自动生成了一篇示例文章Hello World.</p>\n<h2 id=\"如何写文章\"><a href=\"#如何写文章\" class=\"headerlink\" title=\"如何写文章?\"></a>如何写文章?</h2><p>博客架好了,可是我们怎么写文章呢?<br>也很简单,回到我们刚才的git bash命令行模式,进入我们的博客文件夹.使用new命令建立一篇新的文章,.以D:\\blog\\testBlog\\为例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /d/blog/testBlog</div><div class=\"line\">hexo new goodDay</div></pre></td></tr></table></figure></p>\n<p>这样我们就建立了一篇名叫goodDay的新文章.</p>\n<p>此时,我们打开资源管理器,进入 D:\\blog\\testBlog\\source\\_posts.<br>我们会发现自动生成了一个goodDay.md文件.我们就需要在这里进行文章的写作.<br>从文件的后缀名.md可以看出,这是一个markdown文件,我们需要使用markdown的语法编写,这非常容易,通过不多的文字即可实现文章\\标题\\正文\\代码\\图片的排版,而且非常美观,如果你不了解markdown的语法,可以查看<a href=\"http://sspai.com/25137/\">markdown入门</a><br>虽然使用系统的记事本就能编辑.mk文件,但是还是强烈建议使用专业的markdown编辑软件,例如<a href=\"http://markdownpad.com\">MarkdownPad</a>,来编辑,可以方便的实现边编辑边预览,非常方便.<br>文件夹中还有一个hello-world.md,这就是我们刚才在网站上看到的示例文章.我们也可以参考其中的语法进行我们自己文章的写作.如果我们要这边示例文章了,可以直接删除hello-world.md文件即可,在下次使用hexo生成博客网页后,这边示例文章就会从我们的博客中被删除.</p>\n<p>打开goodDay.md,我们可以看到如下的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: xxx</div><div class=\"line\">date: xxx</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>这些以—开始和结尾的内容叫做Front-Matter,负责设置本篇文章的一些属性,此部分的内容不会显示在文章正文中,我们简单的修改一下,文章的标题我们设为”好天气”,文章写作时间我们设为2017-02-24 15:00,我们再给文章加两个tag:t1和t2,再加一个分类:”前端知识”,方便以后管理.<br>goodDay.md修改如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div></pre></td></tr></table></figure></p>\n<p>在—下方我们可以编辑我们文章的正文了,我们简单写两句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: 好天气</div><div class=\"line\">date: 2017-02-24 15:00</div><div class=\"line\">tags: [t1,t2]</div><div class=\"line\">categories: 前端知识</div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">## 好天气啊</div><div class=\"line\">### What a Good Day!</div><div class=\"line\">真是适合春游的好天气</div></pre></td></tr></table></figure></p>\n<p>保存,退出.好了我们的文章写完了,可以生成网页并且发布了,还记得命令吗?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure></p>\n<p>这样我们的一遍文章就已经写好并发布了,去我们的博客上查看一下吧~(^o^)/~<br><img src=\"/image/20170224163724.png\" alt=\"\"></p>\n<p>好了.到这里,我们已经成功的搭建起了一个自己的技术博客,今后我们需要写文章的时候只需要按照之前写的方式新建.md文件,修改,使用hexo生成网页并发布即可.</p>\n<p>由于博主也是才开始玩这一套框架,自己也有很多还没有摸透的地方,今后在使用中如果还有什么进阶的玩法,我会再开一篇文章写出来.</p>\n<p>感谢各位能看到这里.希望大家都能玩的开心.</p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译(一)","date":"2017-04-25T02:58:01.000Z","_content":"\n欢迎转载,转载请标明出处.\n\n今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.\n听起来很牛逼啊,网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.\n\n# 介绍Lithos\n\n### Litho是什么?\nLitho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架主要是被设计用来实现在RecyclerView上构建复杂的可滚动的UI的.\n\n通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.\n\n``` java\n@LayoutSpec\nclass HelloComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String name) {\n\n    return Text.create(c)\n        .text(\"Hello, \" + name)\n        .textSizeRes(R.dimen.my_text_size)\n        .textColor(Color.BLACK)\n        .withLayout()\n        .paddingDip(ALL, 10)\n        .build();\n  }\n}\n```\n\n你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——使用后台线程计算布局参数、自动扁平化层级结构、还有使用增量式挂载机制处理复杂的component。\n\n我们的【教程】可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读【快速开始】来学习如何编写和使用Litho的Component。\n\n### 编写Litho的动机\n在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。\n\n当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。\n\n你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.\n\n如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的\"坑\",但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.\n\n你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.\n\nLitho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。\n\n### 使用\nLitho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.\n\n你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.\n\n高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.\n\n","source":"_posts/2017-04-25-Facebook出品的Android声明式开源新框架Litho文档翻译(一).md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译(一)\ndate: 2017-04-25 10:58:01\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n欢迎转载,转载请标明出处.\n\n今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.\n听起来很牛逼啊,网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.\n\n# 介绍Lithos\n\n### Litho是什么?\nLitho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架主要是被设计用来实现在RecyclerView上构建复杂的可滚动的UI的.\n\n通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.\n\n``` java\n@LayoutSpec\nclass HelloComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String name) {\n\n    return Text.create(c)\n        .text(\"Hello, \" + name)\n        .textSizeRes(R.dimen.my_text_size)\n        .textColor(Color.BLACK)\n        .withLayout()\n        .paddingDip(ALL, 10)\n        .build();\n  }\n}\n```\n\n你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——使用后台线程计算布局参数、自动扁平化层级结构、还有使用增量式挂载机制处理复杂的component。\n\n我们的【教程】可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读【快速开始】来学习如何编写和使用Litho的Component。\n\n### 编写Litho的动机\n在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。\n\n当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。\n\n你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.\n\n如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的\"坑\",但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.\n\n你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.\n\nLitho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。\n\n### 使用\nLitho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.\n\n你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.\n\n高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.\n\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译(一)","published":1,"updated":"2017-04-27T02:12:01.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj21nzol700081srl0kvzeysi","content":"<p>欢迎转载,转载请标明出处.</p>\n<p>今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.<br>听起来很牛逼啊,网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.</p>\n<h1 id=\"介绍Lithos\"><a href=\"#介绍Lithos\" class=\"headerlink\" title=\"介绍Lithos\"></a>介绍Lithos</h1><h3 id=\"Litho是什么\"><a href=\"#Litho是什么\" class=\"headerlink\" title=\"Litho是什么?\"></a>Litho是什么?</h3><p>Litho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架主要是被设计用来实现在RecyclerView上构建复杂的可滚动的UI的.</p>\n<p>通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String name) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> Text.create(c)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello, \"</span> + name)</div><div class=\"line\">        .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">        .textColor(Color.BLACK)</div><div class=\"line\">        .withLayout()</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">10</span>)</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——使用后台线程计算布局参数、自动扁平化层级结构、还有使用增量式挂载机制处理复杂的component。</p>\n<p>我们的【教程】可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读【快速开始】来学习如何编写和使用Litho的Component。</p>\n<h3 id=\"编写Litho的动机\"><a href=\"#编写Litho的动机\" class=\"headerlink\" title=\"编写Litho的动机\"></a>编写Litho的动机</h3><p>在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。</p>\n<p>当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。</p>\n<p>你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.</p>\n<p>如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的”坑”,但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.</p>\n<p>你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.</p>\n<p>Litho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>Litho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.</p>\n<p>你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.</p>\n<p>高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.</p>\n","excerpt":"","more":"<p>欢迎转载,转载请标明出处.</p>\n<p>今天逛github发现facebook开源了一个新框架Litho,大概看了一下介绍,这是一个声明式UI框架,最初是用于为RecyclerView生成复杂的可滚动的UI而做的.<br>听起来很牛逼啊,网上搜了一下,暂时还没有中文的文档什么的,所以为了提升英语水平我也来边学边翻译吧,如果翻译有问题的地方,欢迎指出.</p>\n<h1 id=\"介绍Lithos\"><a href=\"#介绍Lithos\" class=\"headerlink\" title=\"介绍Lithos\"></a>介绍Lithos</h1><h3 id=\"Litho是什么\"><a href=\"#Litho是什么\" class=\"headerlink\" title=\"Litho是什么?\"></a>Litho是什么?</h3><p>Litho是一个为在Android系统上高效的构建用户界面(UI)的声明式框架.它允许你通过使用一套基于Java注解的简单的API来编写最优化的Android views.这个框架主要是被设计用来实现在RecyclerView上构建复杂的可滚动的UI的.</p>\n<p>通过Litho,你可以使用Litho的Components(组件)代替传统的Android Views来构建UI.一个Component本质上是一个带有不可变输入(我们称之为props)并且返回component hierachy(组件层级结构)来描述UI的方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String name)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> Text.create(c)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello, \"</span> + name)</div><div class=\"line\">        .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">        .textColor(Color.BLACK)</div><div class=\"line\">        .withLayout()</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">10</span>)</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你只需要简单的声明你想要展示的元素,然后Litho就会自动的渲染他们,并且以一种高效的方式——使用后台线程计算布局参数、自动扁平化层级结构、还有使用增量式挂载机制处理复杂的component。</p>\n<p>我们的【教程】可以指导你一步一步的在你的APP里使用Litho，或者你也可以阅读【快速开始】来学习如何编写和使用Litho的Component。</p>\n<h3 id=\"编写Litho的动机\"><a href=\"#编写Litho的动机\" class=\"headerlink\" title=\"编写Litho的动机\"></a>编写Litho的动机</h3><p>在Android上构建一个列表式界面相当的简单，虽然大多数app要更加复杂一点，但是大体上你只需要编写一个列表中Item的layout，然后再将其挂载到RecytclerView的adapter上去就完成了。</p>\n<p>当你的adapter拥有许多类型的view的时候，你就不得不去考虑一种更健壮的方法来回收view。如果你有很多很多种类型的view时，每次一个新的类型的view被显示的时候，RecyclerView都会不断的inflate新的view，这很可能导致滚动时帧数的下降。</p>\n<p>你可以通过回收和重复利用,在多个item之前共享一些view实例,来达到减少view的类型的目的,但是随着你添加了更多的逻辑到你的产品中去,bug往往会越来越容易发生.</p>\n<p>如果列表的item比较复杂,你很可能会优化你的layouts.对于简单的情况,你可以直接使用Android库里的layout来避免许多的”坑”,但是情况往往比较复杂.在这种情况下,一个通用的做法是特别为你的需求定制特殊的Custom view(客制化view).使用Custom view可以有效的提升UI的效率,但是由于它们会增添项目的复杂度并且维护成本也很高,所以会拖慢项目进度.</p>\n<p>你也可以通过分解一个复杂的item为多个小的item,来把滚动时计算布局和绘制每一帧的花费的时间分解开来,从而优化RecyclerView的item.这种方法在一些情况下效果不错,但是它通常会导致adapter中view类型的爆炸式增长,并且有可能仍然需要花费代价去创建Custom Views,这就依然导致了我们上面所讲到的问题.</p>\n<p>Litho主要工作就是把优化RecyclerView的复杂工作打包起来.在使用Litho时,没有view类型的区别,你可以在后台线程中提前、无缝的构建你的UI,并且自动地把他们渲染成更加扁平化的层级结构。这些梦幻的特性，你都可以免费的通过一套非常简单的编程模式来获得。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>Litho的首要使用场景为:具有复杂内容的RecyclerView.因为它甚至在具有复杂的item和多种类型的内容RecyclerView上也表现出了极好的滚动特性.这在使用传统的android view的情况下是非常具有挑战性的工作.</p>\n<p>你也可以因为Litho简单的声明式的API来选择采用Litho来构建UI,Litho的基于单向数据流函数式编程模型会在你的产品变得复杂的时候也很容易理解.</p>\n<p>高动态化的UI动画和复杂手势现在还很难用Litho实现,新的针对layout专场和手势的API将会很快推出.</p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译(二)","date":"2017-04-27T08:05:10.000Z","_content":"\n# 快速开始\n\n### 入门指南\n\n#### gradle\n\n##### 集成Litho至你的工程\n你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.\n``` gradle\ndependencies {\n  // ...\n  // Litho\n  compile 'com.facebook.litho:litho-core:0.2.0'\n  compile 'com.facebook.litho:litho-widget:0.2.0'\n  provided 'com.facebook.litho:litho-annotations:0.2.0'\n\n  annotationProcessor 'com.facebook.litho:litho-processor:0.2.0'\n  \n  // SoLoader \n  compile 'com.facebook.soloader:soloader:0.2.0'\n\n  // 调试选项\n  debugCompile 'com.facebook.litho:litho-stetho:0.2.0'\n\n  // 集成Fresco的支持\n  compile 'com.facebook.litho:litho-fresco:0.2.0'\n\n  // 供测试\n  testCompile 'com.facebook.litho:litho-testing:0.2.0'\n}\n```\n#### Buck\n你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.\n``` buck\nandroid_prebuilt_aar(\n    name = \"litho\",\n    aar = \":litho.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-core.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-core:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-annotation\",\n    binary_jar = \":litho-annotation.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-processor.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-processor:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-processor\",\n    binary_jar = \":litho-processor.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-annotation.jar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-annotation:jar:0.2.0\",\n)\n\nandroid_prebuilt_aar(\n    name = \"litho-widget\",\n    aar = \":litho-widget.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-widget.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-widget:aar:0.2.0\",\n)\n\nlitho_android_library(\n    ...\n    # Your target here\n    ...\n    annotation_processor_deps = [\n        \":litho-annotation\",\n        \":litho-processor\",\n    ],\n    annotation_processors = [\n        \"com.facebook.litho.processor.ComponentsProcessor\",\n    ],\n    deps = [\n        \":litho\",\n        \":litho-widget\",\n        ...\n    ]\n)\n```\n\n##### 测试集成情况\n你可以通过添加一个由Litho创建的view至activity来测试集成情况\n\n首先,初始化SoLoader.Litho依赖SoLoader来加载底层布局引擎所需的本地库.在Application中进行这个操作比较合适.\n\n``` java\n[MyApplication.java]\npublic class MyApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\n然后,添加一个预定义的Litho Text组件至activity来显示\"Hello world\".\n\n``` java \n[MyActivity.java]\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.LithoView;\n\npublic class MyActivity extends Activity {\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    \n    final ComponentContext c = new ComponentContext(this);\n\n    final LithoView lithoView = LithoView.create(\n    \tthis /* context */, \n    \tText.create(c)\n            .text(\"Hello, World!\")\n            .textSizeDip(50)\n            .build());\n    \t\n    setContentView(lithoView);\n  }\n}\n\n```\n\n现在,当你运行app的时候,你就可以看到\"Hello World\"显示在屏幕上.\n\n### 教程\n本教程已经假定你已经按照入门指南正确设置了Litho.\n\n在本教程中，你将首先使用Litho在屏幕上构建一个基本的\"Hello World！\"，然后再构建一个\"Hello World！\" item组成的列表。在这个过程中,你将了解到Litho的构建块：Component和LithoView。你将学习如何设置Component的属性。\n\n##### 1.Hello World\n在最初的步骤中,你将显示一个带有\"Hello World\"的View.\n\n首先,在Application中初始化SoLoader.\n``` java\npublic class SampleApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\nLitho在后台使用Yoga加载布局.Yoga需要依赖本地库,而我们引入SoLoader来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.\n\n另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装[Stetho]().\n\n下一步,添加一个Litho中预定义好的Text Component到activity中:\n``` java \n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    final ComponentContext context = new ComponentContext(this);\n\n    final Component component = Text.create(context)\n        .text(\"Hello World\")\n        .textSizeDip(50)\n        .build();\n\n    setContentView(LithoView.create(context, component));\n}\n```\nLithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.\n\n那么component如何发挥作用呢?让我们看一下这段代码:\n``` java\nText.create(context)\n    .text(\"Hello World\")\n    .textSizeDip(50)\n    .build();\n```\n\nText是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从React中获得灵感,这些属性我们称之为props.\n\n稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.\n\n在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.\n\n完成了!让我们运行app,你可以在屏幕上看到这样的显示.\n\n![](/image/20170428092530.png)\n\n虽然并不漂亮,但是这已经是一个好的开端了!\n\n##### 2.你的第一个自定义Component\n在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!\n\n在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.\n\n准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。\n\n您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.\n\n``` java\n@LayoutSpec\npublic class ListItemSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(ComponentContext c) {\n  \n    return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(Color.WHITE)\n        .child(\n            Text.create(c)\n                .text(\"Hello world\")\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(\"Litho tutorial\")\n                .textSizeSp(20))\n        .build();\n  }\n}\n```\n\n你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个Column中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用Yoga,捏可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.\n\n你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:\n\n``` java \nfinal Component text = ListItem.create(context).build();\n```\n注意:你使用的是ListItem,而不是ListItemSpec.\n\n这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.\n\n在入门指南中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).\n\n就这么简单。运行你的app,你应该看到如下的画面:\n\n![](/image/20170428102947.png)\n\n##### 3.创建一个列表\n你可以使用Litho的核心组件Recycler Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个RecyclerBinder来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.\n首先,在你的activity中,像下面这样定义Component:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(\n    context,\n    new LinearLayoutInfo(this, OrientationHelper.VERTICAL, false));\n\nfinal Component component = Recycler.create(context)\n    .binder(recyclerBinder)\n    .build();\n```\n这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.\n\n然后再创建Recycler并且把它传递给LithoView.\n\n现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:\n``` java\nprivate static void addContent(RecyclerBinder recyclerBinder, ComponentContext context) {\n    for (int i = 0; i < 32; i++) {\n      recyclerBinder.insertItemAt(\n          i,\n          ComponentInfo.create()\n              .component(ListItem.create(context).build())\n              .build());\n    }\n}    \n```\n\n在代码中,我们需要创建一个ComponentInfo来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.\n\n最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.\n``` java\naddContent(recyclerBinder, context);\n```\n运行app,你会看见一个可以滚动的具有32个ListItem的列表.\n\n![](/image/20170428105417.png)\n\n##### 4.定义Component的属性\n列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.\n\n为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.\n\n像下面这样修改ListItemSpec:\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @Prop int color,\n    @Prop String title,\n    @Prop String subtitle) {\n    \n  return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(color)\n        .child(\n            Text.create(c)\n                .text(title)\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(subtitle)\n                .textSizeSp(20))\n        .build();\n}\n```\n\n这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.\n\n神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:\n``` java\nprivate void addContent(\n    RecyclerBinder recyclerBinder, \n    ComponentContext context) {\n  for (int i = 0; i < 32; i++) {\n    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();\n    componentInfoBuilder.component(\n        ListItem.create(context)\n            .color(i % 2 == 0 ? Color.WHITE : Color.LTGRAY)\n            .title(\"Hello, world!\")\n            .subtitle(\"Litho tutorial\")\n            .build());\n    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());\n  }\n}\n```\n\n现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.\n\n运行app,你可以看到如下画面:\n\n![](/image/20170428111627.png)\n\n你可以为@Prop注释指定更多的选项.例如下面的属性:\n``` java \n@Prop(optional = true, resType = ResType.DIMEN_OFFSET) int shadowRadius,\n```\n\n它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。\n\n恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在com.facebook.litho.widgets包中找到可以使用的预定义好的组件Component。你可以在[这里]()找到完整的教程。请务必查看[此示例]()和Litho API文档以获取更深入的代码。\n\n### 编写Component\n\n##### Component Specs\n\n一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:\n- Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.\n- Mount spec: 一个可以渲染view或者drawable的的组件.\n\n现在，我们来看一下布局spec的整体结构：\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String title,\n      @Prop Uri imageUri) {\n    ...\n  }\n}\n```\n有几件事需要注意:\n- Component Spec只是有着特殊注释的普通java类.\n- Component Spec是完全无状态的,并且不包含任何的成员变量.\n- 带有@Prop注释的参数将会自动的添加到Component构造器中.\n- 为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅[入门指南](),了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.\n\n##### Spec,生命周期和Component类\n一个Component Spec子类将被处理用于生成一个ComponentLifecycle的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.\n\n这个生成的ComponentLifeCycle类就是今后你会在你的产品中使用的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.\n\n生成的新类暴露出来的唯一的API是一个create（...）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。\n\n在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.\n\n### 使用Component\n生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个LithoView,它是一个Android ViewGroup并且可以渲染component.\\\n\n你可以通过以下的代码制定一个LithoView来渲染一个Component.\n``` java\nfinal Component component = MyComponent.create()\n    .title(\"My title\")\n    .imageUri(Uri.parse(\"http://example.com/myimage\")\n    .build();\nLithoView view = LithoView.create(context, component);\n```\n\n在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在[教程]()里看到如何在一个Acitivity中使用这个LithoView.\n\n重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅[异步布局]().\n\n","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译(二).md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译(二)\ndate: 2017-04-27 16:05:10\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n# 快速开始\n\n### 入门指南\n\n#### gradle\n\n##### 集成Litho至你的工程\n你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.\n``` gradle\ndependencies {\n  // ...\n  // Litho\n  compile 'com.facebook.litho:litho-core:0.2.0'\n  compile 'com.facebook.litho:litho-widget:0.2.0'\n  provided 'com.facebook.litho:litho-annotations:0.2.0'\n\n  annotationProcessor 'com.facebook.litho:litho-processor:0.2.0'\n  \n  // SoLoader \n  compile 'com.facebook.soloader:soloader:0.2.0'\n\n  // 调试选项\n  debugCompile 'com.facebook.litho:litho-stetho:0.2.0'\n\n  // 集成Fresco的支持\n  compile 'com.facebook.litho:litho-fresco:0.2.0'\n\n  // 供测试\n  testCompile 'com.facebook.litho:litho-testing:0.2.0'\n}\n```\n#### Buck\n你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.\n``` buck\nandroid_prebuilt_aar(\n    name = \"litho\",\n    aar = \":litho.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-core.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-core:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-annotation\",\n    binary_jar = \":litho-annotation.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-processor.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-processor:aar:0.2.0\",\n)\n\nprebuilt_jar(\n    name = \"litho-processor\",\n    binary_jar = \":litho-processor.jar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-annotation.jar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-annotation:jar:0.2.0\",\n)\n\nandroid_prebuilt_aar(\n    name = \"litho-widget\",\n    aar = \":litho-widget.aar\",\n    visibility = [\"PUBLIC\"],\n)\n\nremote_file(\n    name = \"litho-widget.aar\",\n    sha1 = \"sha1here\",\n    url = \"mvn:com.facebook.litho:litho-widget:aar:0.2.0\",\n)\n\nlitho_android_library(\n    ...\n    # Your target here\n    ...\n    annotation_processor_deps = [\n        \":litho-annotation\",\n        \":litho-processor\",\n    ],\n    annotation_processors = [\n        \"com.facebook.litho.processor.ComponentsProcessor\",\n    ],\n    deps = [\n        \":litho\",\n        \":litho-widget\",\n        ...\n    ]\n)\n```\n\n##### 测试集成情况\n你可以通过添加一个由Litho创建的view至activity来测试集成情况\n\n首先,初始化SoLoader.Litho依赖SoLoader来加载底层布局引擎所需的本地库.在Application中进行这个操作比较合适.\n\n``` java\n[MyApplication.java]\npublic class MyApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\n然后,添加一个预定义的Litho Text组件至activity来显示\"Hello world\".\n\n``` java \n[MyActivity.java]\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.LithoView;\n\npublic class MyActivity extends Activity {\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    \n    final ComponentContext c = new ComponentContext(this);\n\n    final LithoView lithoView = LithoView.create(\n    \tthis /* context */, \n    \tText.create(c)\n            .text(\"Hello, World!\")\n            .textSizeDip(50)\n            .build());\n    \t\n    setContentView(lithoView);\n  }\n}\n\n```\n\n现在,当你运行app的时候,你就可以看到\"Hello World\"显示在屏幕上.\n\n### 教程\n本教程已经假定你已经按照入门指南正确设置了Litho.\n\n在本教程中，你将首先使用Litho在屏幕上构建一个基本的\"Hello World！\"，然后再构建一个\"Hello World！\" item组成的列表。在这个过程中,你将了解到Litho的构建块：Component和LithoView。你将学习如何设置Component的属性。\n\n##### 1.Hello World\n在最初的步骤中,你将显示一个带有\"Hello World\"的View.\n\n首先,在Application中初始化SoLoader.\n``` java\npublic class SampleApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    \n    SoLoader.init(this, false);\n  }\n}\n```\n\nLitho在后台使用Yoga加载布局.Yoga需要依赖本地库,而我们引入SoLoader来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.\n\n另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装[Stetho]().\n\n下一步,添加一个Litho中预定义好的Text Component到activity中:\n``` java \n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    final ComponentContext context = new ComponentContext(this);\n\n    final Component component = Text.create(context)\n        .text(\"Hello World\")\n        .textSizeDip(50)\n        .build();\n\n    setContentView(LithoView.create(context, component));\n}\n```\nLithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.\n\n那么component如何发挥作用呢?让我们看一下这段代码:\n``` java\nText.create(context)\n    .text(\"Hello World\")\n    .textSizeDip(50)\n    .build();\n```\n\nText是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从React中获得灵感,这些属性我们称之为props.\n\n稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.\n\n在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.\n\n完成了!让我们运行app,你可以在屏幕上看到这样的显示.\n\n![](/image/20170428092530.png)\n\n虽然并不漂亮,但是这已经是一个好的开端了!\n\n##### 2.你的第一个自定义Component\n在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!\n\n在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.\n\n准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。\n\n您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.\n\n``` java\n@LayoutSpec\npublic class ListItemSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(ComponentContext c) {\n  \n    return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(Color.WHITE)\n        .child(\n            Text.create(c)\n                .text(\"Hello world\")\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(\"Litho tutorial\")\n                .textSizeSp(20))\n        .build();\n  }\n}\n```\n\n你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个Column中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用Yoga,捏可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.\n\n你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:\n\n``` java \nfinal Component text = ListItem.create(context).build();\n```\n注意:你使用的是ListItem,而不是ListItemSpec.\n\n这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.\n\n在入门指南中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).\n\n就这么简单。运行你的app,你应该看到如下的画面:\n\n![](/image/20170428102947.png)\n\n##### 3.创建一个列表\n你可以使用Litho的核心组件Recycler Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个RecyclerBinder来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.\n首先,在你的activity中,像下面这样定义Component:\n``` java\nfinal RecyclerBinder recyclerBinder = new RecyclerBinder(\n    context,\n    new LinearLayoutInfo(this, OrientationHelper.VERTICAL, false));\n\nfinal Component component = Recycler.create(context)\n    .binder(recyclerBinder)\n    .build();\n```\n这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.\n\n然后再创建Recycler并且把它传递给LithoView.\n\n现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:\n``` java\nprivate static void addContent(RecyclerBinder recyclerBinder, ComponentContext context) {\n    for (int i = 0; i < 32; i++) {\n      recyclerBinder.insertItemAt(\n          i,\n          ComponentInfo.create()\n              .component(ListItem.create(context).build())\n              .build());\n    }\n}    \n```\n\n在代码中,我们需要创建一个ComponentInfo来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.\n\n最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.\n``` java\naddContent(recyclerBinder, context);\n```\n运行app,你会看见一个可以滚动的具有32个ListItem的列表.\n\n![](/image/20170428105417.png)\n\n##### 4.定义Component的属性\n列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.\n\n为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.\n\n像下面这样修改ListItemSpec:\n``` java\n@OnCreateLayout\nstatic ComponentLayout onCreateLayout(\n    ComponentContext c,\n    @Prop int color,\n    @Prop String title,\n    @Prop String subtitle) {\n    \n  return Column.create(c)\n        .paddingDip(ALL, 16)\n        .backgroundColor(color)\n        .child(\n            Text.create(c)\n                .text(title)\n                .textSizeSp(40))\n        .child(\n            Text.create(c)\n                .text(subtitle)\n                .textSizeSp(20))\n        .build();\n}\n```\n\n这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.\n\n神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:\n``` java\nprivate void addContent(\n    RecyclerBinder recyclerBinder, \n    ComponentContext context) {\n  for (int i = 0; i < 32; i++) {\n    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();\n    componentInfoBuilder.component(\n        ListItem.create(context)\n            .color(i % 2 == 0 ? Color.WHITE : Color.LTGRAY)\n            .title(\"Hello, world!\")\n            .subtitle(\"Litho tutorial\")\n            .build());\n    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());\n  }\n}\n```\n\n现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.\n\n运行app,你可以看到如下画面:\n\n![](/image/20170428111627.png)\n\n你可以为@Prop注释指定更多的选项.例如下面的属性:\n``` java \n@Prop(optional = true, resType = ResType.DIMEN_OFFSET) int shadowRadius,\n```\n\n它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。\n\n恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在com.facebook.litho.widgets包中找到可以使用的预定义好的组件Component。你可以在[这里]()找到完整的教程。请务必查看[此示例]()和Litho API文档以获取更深入的代码。\n\n### 编写Component\n\n##### Component Specs\n\n一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:\n- Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.\n- Mount spec: 一个可以渲染view或者drawable的的组件.\n\n现在，我们来看一下布局spec的整体结构：\n\n``` java\n@LayoutSpec\nclass MyComponentSpec {\n\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop String title,\n      @Prop Uri imageUri) {\n    ...\n  }\n}\n```\n有几件事需要注意:\n- Component Spec只是有着特殊注释的普通java类.\n- Component Spec是完全无状态的,并且不包含任何的成员变量.\n- 带有@Prop注释的参数将会自动的添加到Component构造器中.\n- 为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅[入门指南](),了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.\n\n##### Spec,生命周期和Component类\n一个Component Spec子类将被处理用于生成一个ComponentLifecycle的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.\n\n这个生成的ComponentLifeCycle类就是今后你会在你的产品中使用的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.\n\n生成的新类暴露出来的唯一的API是一个create（...）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。\n\n在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.\n\n### 使用Component\n生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个LithoView,它是一个Android ViewGroup并且可以渲染component.\\\n\n你可以通过以下的代码制定一个LithoView来渲染一个Component.\n``` java\nfinal Component component = MyComponent.create()\n    .title(\"My title\")\n    .imageUri(Uri.parse(\"http://example.com/myimage\")\n    .build();\nLithoView view = LithoView.create(context, component);\n```\n\n在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在[教程]()里看到如何在一个Acitivity中使用这个LithoView.\n\n重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅[异步布局]().\n\n","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译(二)","published":1,"updated":"2017-04-28T06:01:30.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj21nzola00091srl78ka44pa","content":"<h1 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h1><h3 id=\"入门指南\"><a href=\"#入门指南\" class=\"headerlink\" title=\"入门指南\"></a>入门指南</h3><h4 id=\"gradle\"><a href=\"#gradle\" class=\"headerlink\" title=\"gradle\"></a>gradle</h4><h5 id=\"集成Litho至你的工程\"><a href=\"#集成Litho至你的工程\" class=\"headerlink\" title=\"集成Litho至你的工程\"></a>集成Litho至你的工程</h5><p>你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  <span class=\"comment\">// Litho</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-core:0.2.0'</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-widget:0.2.0'</span></div><div class=\"line\">  provided <span class=\"string\">'com.facebook.litho:litho-annotations:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  annotationProcessor <span class=\"string\">'com.facebook.litho:litho-processor:0.2.0'</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// SoLoader </span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.soloader:soloader:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 调试选项</span></div><div class=\"line\">  debugCompile <span class=\"string\">'com.facebook.litho:litho-stetho:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 集成Fresco的支持</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-fresco:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 供测试</span></div><div class=\"line\">  testCompile <span class=\"string\">'com.facebook.litho:litho-testing:0.2.0'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Buck\"><a href=\"#Buck\" class=\"headerlink\" title=\"Buck\"></a>Buck</h4><p>你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho&quot;,</div><div class=\"line\">    aar = &quot;:litho.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-core.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-core:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-annotation&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-annotation.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-processor.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-processor:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-processor&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-processor.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-annotation.jar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-annotation:jar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho-widget&quot;,</div><div class=\"line\">    aar = &quot;:litho-widget.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-widget.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-widget:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">litho_android_library(</div><div class=\"line\">    ...</div><div class=\"line\">    # Your target here</div><div class=\"line\">    ...</div><div class=\"line\">    annotation_processor_deps = [</div><div class=\"line\">        &quot;:litho-annotation&quot;,</div><div class=\"line\">        &quot;:litho-processor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    annotation_processors = [</div><div class=\"line\">        &quot;com.facebook.litho.processor.ComponentsProcessor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    deps = [</div><div class=\"line\">        &quot;:litho&quot;,</div><div class=\"line\">        &quot;:litho-widget&quot;,</div><div class=\"line\">        ...</div><div class=\"line\">    ]</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h5 id=\"测试集成情况\"><a href=\"#测试集成情况\" class=\"headerlink\" title=\"测试集成情况\"></a>测试集成情况</h5><p>你可以通过添加一个由Litho创建的view至activity来测试集成情况</p>\n<p>首先,初始化SoLoader.Litho依赖SoLoader来加载底层布局引擎所需的本地库.在Application中进行这个操作比较合适.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyApplication.java]</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后,添加一个预定义的Litho Text组件至activity来显示”Hello world”.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyActivity.java]</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.ComponentContext;</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.LithoView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> LithoView lithoView = LithoView.create(</div><div class=\"line\">    \t<span class=\"keyword\">this</span> <span class=\"comment\">/* context */</span>, </div><div class=\"line\">    \tText.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"Hello, World!\"</span>)</div><div class=\"line\">            .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    \t</div><div class=\"line\">    setContentView(lithoView);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在,当你运行app的时候,你就可以看到”Hello World”显示在屏幕上.</p>\n<h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p>本教程已经假定你已经按照入门指南正确设置了Litho.</p>\n<p>在本教程中，你将首先使用Litho在屏幕上构建一个基本的”Hello World！”，然后再构建一个”Hello World！” item组成的列表。在这个过程中,你将了解到Litho的构建块：Component和LithoView。你将学习如何设置Component的属性。</p>\n<h5 id=\"1-Hello-World\"><a href=\"#1-Hello-World\" class=\"headerlink\" title=\"1.Hello World\"></a>1.Hello World</h5><p>在最初的步骤中,你将显示一个带有”Hello World”的View.</p>\n<p>首先,在Application中初始化SoLoader.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Litho在后台使用Yoga加载布局.Yoga需要依赖本地库,而我们引入SoLoader来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.</p>\n<p>另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装<a href=\"\">Stetho</a>.</p>\n<p>下一步,添加一个Litho中预定义好的Text Component到activity中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext context = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component component = Text.create(context)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">        .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    setContentView(LithoView.create(context, component));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>LithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.</p>\n<p>那么component如何发挥作用呢?让我们看一下这段代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(context)</div><div class=\"line\">    .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">    .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>Text是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从React中获得灵感,这些属性我们称之为props.</p>\n<p>稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.</p>\n<p>在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.</p>\n<p>完成了!让我们运行app,你可以在屏幕上看到这样的显示.</p>\n<p><img src=\"/image/20170428092530.png\" alt=\"\"></p>\n<p>虽然并不漂亮,但是这已经是一个好的开端了!</p>\n<h5 id=\"2-你的第一个自定义Component\"><a href=\"#2-你的第一个自定义Component\" class=\"headerlink\" title=\"2.你的第一个自定义Component\"></a>2.你的第一个自定义Component</h5><p>在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!</p>\n<p>在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.</p>\n<p>准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。</p>\n<p>您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItemSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(Color.WHITE)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Hello world\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个Column中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用Yoga,捏可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.</div></p>\n<p>你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component text = ListItem.create(context).build();</div></pre></td></tr></table></figure>\n<p>注意:你使用的是ListItem,而不是ListItemSpec.</p>\n<p>这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.</p>\n<p>在入门指南中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).</p>\n<p>就这么简单。运行你的app,你应该看到如下的画面:</p>\n<p><img src=\"/image/20170428102947.png\" alt=\"\"></p>\n<h5 id=\"3-创建一个列表\"><a href=\"#3-创建一个列表\" class=\"headerlink\" title=\"3.创建一个列表\"></a>3.创建一个列表</h5><p>你可以使用Litho的核心组件Recycler Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个RecyclerBinder来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.<br>首先,在你的activity中,像下面这样定义Component:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(</div><div class=\"line\">    context,</div><div class=\"line\">    <span class=\"keyword\">new</span> LinearLayoutInfo(<span class=\"keyword\">this</span>, OrientationHelper.VERTICAL, <span class=\"keyword\">false</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> Component component = Recycler.create(context)</div><div class=\"line\">    .binder(recyclerBinder)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.</p>\n<p>然后再创建Recycler并且把它传递给LithoView.</p>\n<p>现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(RecyclerBinder recyclerBinder, ComponentContext context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">      recyclerBinder.insertItemAt(</div><div class=\"line\">          i,</div><div class=\"line\">          ComponentInfo.create()</div><div class=\"line\">              .component(ListItem.create(context).build())</div><div class=\"line\">              .build());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在代码中,我们需要创建一个ComponentInfo来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.</p>\n<p>最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addContent(recyclerBinder, context);</div></pre></td></tr></table></figure></p>\n<p>运行app,你会看见一个可以滚动的具有32个ListItem的列表.</p>\n<p><img src=\"/image/20170428105417.png\" alt=\"\"></p>\n<h5 id=\"4-定义Component的属性\"><a href=\"#4-定义Component的属性\" class=\"headerlink\" title=\"4.定义Component的属性\"></a>4.定义Component的属性</h5><p>列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.</p>\n<p>为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.</p>\n<p>像下面这样修改ListItemSpec:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">    @Prop String title,</div><div class=\"line\">    @Prop String subtitle) &#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(color)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(title)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(subtitle)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.</p>\n<p>神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(</span></span></div><div class=\"line\">    RecyclerBinder recyclerBinder, </div><div class=\"line\">    ComponentContext context) &#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();</div><div class=\"line\">    componentInfoBuilder.component(</div><div class=\"line\">        ListItem.create(context)</div><div class=\"line\">            .color(i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? Color.WHITE : Color.LTGRAY)</div><div class=\"line\">            .title(<span class=\"string\">\"Hello, world!\"</span>)</div><div class=\"line\">            .subtitle(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.</p>\n<p>运行app,你可以看到如下画面:</p>\n<p><img src=\"/image/20170428111627.png\" alt=\"\"></p>\n<p>你可以为@Prop注释指定更多的选项.例如下面的属性:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Prop</span>(optional = <span class=\"keyword\">true</span>, resType = ResType.DIMEN_OFFSET) <span class=\"keyword\">int</span> shadowRadius,</div></pre></td></tr></table></figure></p>\n<p>它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。</p>\n<p>恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在com.facebook.litho.widgets包中找到可以使用的预定义好的组件Component。你可以在<a href=\"\">这里</a>找到完整的教程。请务必查看<a href=\"\">此示例</a>和Litho API文档以获取更深入的代码。</p>\n<h3 id=\"编写Component\"><a href=\"#编写Component\" class=\"headerlink\" title=\"编写Component\"></a>编写Component</h3><h5 id=\"Component-Specs\"><a href=\"#Component-Specs\" class=\"headerlink\" title=\"Component Specs\"></a>Component Specs</h5><p>一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:</p>\n<ul>\n<li>Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.</li>\n<li>Mount spec: 一个可以渲染view或者drawable的的组件.</li>\n</ul>\n<p>现在，我们来看一下布局spec的整体结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String title,</div><div class=\"line\">      @Prop Uri imageUri) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有几件事需要注意:</p>\n<ul>\n<li>Component Spec只是有着特殊注释的普通java类.</li>\n<li>Component Spec是完全无状态的,并且不包含任何的成员变量.</li>\n<li>带有@Prop注释的参数将会自动的添加到Component构造器中.</li>\n<li>为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅<a href=\"\">入门指南</a>,了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.</li>\n</ul>\n<h5 id=\"Spec-生命周期和Component类\"><a href=\"#Spec-生命周期和Component类\" class=\"headerlink\" title=\"Spec,生命周期和Component类\"></a>Spec,生命周期和Component类</h5><p>一个Component Spec子类将被处理用于生成一个ComponentLifecycle的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.</p>\n<p>这个生成的ComponentLifeCycle类就是今后你会在你的产品中使用的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.</p>\n<p>生成的新类暴露出来的唯一的API是一个create（…）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。</p>\n<p>在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.</p>\n<h3 id=\"使用Component\"><a href=\"#使用Component\" class=\"headerlink\" title=\"使用Component\"></a>使用Component</h3><p>生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个LithoView,它是一个Android ViewGroup并且可以渲染component.\\</p>\n<p>你可以通过以下的代码制定一个LithoView来渲染一个Component.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component component = MyComponent.create()</div><div class=\"line\">    .title(<span class=\"string\">\"My title\"</span>)</div><div class=\"line\">    .imageUri(Uri.parse(<span class=\"string\">\"http://example.com/myimage\"</span>)</div><div class=\"line\">    .build();</div><div class=\"line\">LithoView view = LithoView.create(context, component);</div></pre></td></tr></table></figure></p>\n<p>在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在<a href=\"\">教程</a>里看到如何在一个Acitivity中使用这个LithoView.</p>\n<p>重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅<a href=\"\">异步布局</a>.</p>\n","excerpt":"","more":"<h1 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h1><h3 id=\"入门指南\"><a href=\"#入门指南\" class=\"headerlink\" title=\"入门指南\"></a>入门指南</h3><h4 id=\"gradle\"><a href=\"#gradle\" class=\"headerlink\" title=\"gradle\"></a>gradle</h4><h5 id=\"集成Litho至你的工程\"><a href=\"#集成Litho至你的工程\" class=\"headerlink\" title=\"集成Litho至你的工程\"></a>集成Litho至你的工程</h5><p>你可以通过在你的Gradle的build.gradle文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  <span class=\"comment\">// Litho</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-core:0.2.0'</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-widget:0.2.0'</span></div><div class=\"line\">  provided <span class=\"string\">'com.facebook.litho:litho-annotations:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  annotationProcessor <span class=\"string\">'com.facebook.litho:litho-processor:0.2.0'</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// SoLoader </span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.soloader:soloader:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 调试选项</span></div><div class=\"line\">  debugCompile <span class=\"string\">'com.facebook.litho:litho-stetho:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 集成Fresco的支持</span></div><div class=\"line\">  <span class=\"keyword\">compile</span> <span class=\"string\">'com.facebook.litho:litho-fresco:0.2.0'</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 供测试</span></div><div class=\"line\">  testCompile <span class=\"string\">'com.facebook.litho:litho-testing:0.2.0'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Buck\"><a href=\"#Buck\" class=\"headerlink\" title=\"Buck\"></a>Buck</h4><p>你可以通过在你的Buck的BUCK文件中添加以下代码来把Litho添加至你的Android工程中.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho&quot;,</div><div class=\"line\">    aar = &quot;:litho.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-core.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-core:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-annotation&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-annotation.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-processor.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-processor:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">prebuilt_jar(</div><div class=\"line\">    name = &quot;litho-processor&quot;,</div><div class=\"line\">    binary_jar = &quot;:litho-processor.jar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-annotation.jar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-annotation:jar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">android_prebuilt_aar(</div><div class=\"line\">    name = &quot;litho-widget&quot;,</div><div class=\"line\">    aar = &quot;:litho-widget.aar&quot;,</div><div class=\"line\">    visibility = [&quot;PUBLIC&quot;],</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">remote_file(</div><div class=\"line\">    name = &quot;litho-widget.aar&quot;,</div><div class=\"line\">    sha1 = &quot;sha1here&quot;,</div><div class=\"line\">    url = &quot;mvn:com.facebook.litho:litho-widget:aar:0.2.0&quot;,</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">litho_android_library(</div><div class=\"line\">    ...</div><div class=\"line\">    # Your target here</div><div class=\"line\">    ...</div><div class=\"line\">    annotation_processor_deps = [</div><div class=\"line\">        &quot;:litho-annotation&quot;,</div><div class=\"line\">        &quot;:litho-processor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    annotation_processors = [</div><div class=\"line\">        &quot;com.facebook.litho.processor.ComponentsProcessor&quot;,</div><div class=\"line\">    ],</div><div class=\"line\">    deps = [</div><div class=\"line\">        &quot;:litho&quot;,</div><div class=\"line\">        &quot;:litho-widget&quot;,</div><div class=\"line\">        ...</div><div class=\"line\">    ]</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<h5 id=\"测试集成情况\"><a href=\"#测试集成情况\" class=\"headerlink\" title=\"测试集成情况\"></a>测试集成情况</h5><p>你可以通过添加一个由Litho创建的view至activity来测试集成情况</p>\n<p>首先,初始化SoLoader.Litho依赖SoLoader来加载底层布局引擎所需的本地库.在Application中进行这个操作比较合适.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyApplication.java]</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后,添加一个预定义的Litho Text组件至activity来显示”Hello world”.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">[MyActivity.java]</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.ComponentContext;</div><div class=\"line\"><span class=\"keyword\">import</span> com.facebook.litho.LithoView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext c = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> LithoView lithoView = LithoView.create(</div><div class=\"line\">    \t<span class=\"keyword\">this</span> <span class=\"comment\">/* context */</span>, </div><div class=\"line\">    \tText.create(c)</div><div class=\"line\">            .text(<span class=\"string\">\"Hello, World!\"</span>)</div><div class=\"line\">            .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    \t</div><div class=\"line\">    setContentView(lithoView);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在,当你运行app的时候,你就可以看到”Hello World”显示在屏幕上.</p>\n<h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p>本教程已经假定你已经按照入门指南正确设置了Litho.</p>\n<p>在本教程中，你将首先使用Litho在屏幕上构建一个基本的”Hello World！”，然后再构建一个”Hello World！” item组成的列表。在这个过程中,你将了解到Litho的构建块：Component和LithoView。你将学习如何设置Component的属性。</p>\n<h5 id=\"1-Hello-World\"><a href=\"#1-Hello-World\" class=\"headerlink\" title=\"1.Hello World\"></a>1.Hello World</h5><p>在最初的步骤中,你将显示一个带有”Hello World”的View.</p>\n<p>首先,在Application中初始化SoLoader.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    </div><div class=\"line\">    SoLoader.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Litho在后台使用Yoga加载布局.Yoga需要依赖本地库,而我们引入SoLoader来处理加载这些本地库的工作.在此处初始化SoLoader确保你稍后不会引用到那些未加载的库.</p>\n<p>另外,如果你想要调试你的Component层级结构,你可以按照其中的步骤安装<a href=\"\">Stetho</a>.</p>\n<p>下一步,添加一个Litho中预定义好的Text Component到activity中:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> ComponentContext context = <span class=\"keyword\">new</span> ComponentContext(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Component component = Text.create(context)</div><div class=\"line\">        .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">        .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">        .build();</div><div class=\"line\"></div><div class=\"line\">    setContentView(LithoView.create(context, component));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>LithoView是一个可以渲染Component的Android ViewGroup.它是连接Android view和Litho Component的桥梁.上面的例子就把一个展示Text Component的LithoView设置到了activity中的content中.</p>\n<p>那么component如何发挥作用呢?让我们看一下这段代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(context)</div><div class=\"line\">    .text(<span class=\"string\">\"Hello World\"</span>)</div><div class=\"line\">    .textSizeDip(<span class=\"number\">50</span>)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>Text是在com.facebook.litho.widget中定义的核心组件.如你所见,它有诸如text和textSize这样的一系列的属性.我们从React中获得灵感,这些属性我们称之为props.</p>\n<p>稍后,你将学习到如何编写自己的component,但是值得注意的是,Text类是由TextSpec类生成的,生成的component类提供了一套API方法来设置props的值.</p>\n<p>在示例中,这个Text Component被作为一个单独的子控件添加至LithoView中.你也可以用一个根Component包含许多子Component来替代示例中的做法.在后续的例子中,你将会学习如何这么做.</p>\n<p>完成了!让我们运行app,你可以在屏幕上看到这样的显示.</p>\n<p><img src=\"/image/20170428092530.png\" alt=\"\"></p>\n<p>虽然并不漂亮,但是这已经是一个好的开端了!</p>\n<h5 id=\"2-你的第一个自定义Component\"><a href=\"#2-你的第一个自定义Component\" class=\"headerlink\" title=\"2.你的第一个自定义Component\"></a>2.你的第一个自定义Component</h5><p>在本教程的末尾,你将会拥有一个可以滚动的列表,这个列表将循环的显示一个包含标题和副标题的item.简直激动人心!</p>\n<p>在教程的本部分中,你将编写一个简单的component作为列表的item.当然,现实世界中的app的item会更加复杂,但是你会在这个示例中学到你今后需要所有基础的知识.</p>\n<p>准备好了吗？是时候深入探索并构建该Component了。在Litho中，你可以编写Spec类来声明Component的布局。框架随后会生成底层的Component类供您在代码中创建实例。</p>\n<p>您的自定义component将被称为ListItem,它将包含一个标题,和一个在其下方的稍小的副标题.因此,你需要创建一个包含以下内容的ListItemSpec类.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItemSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(Color.WHITE)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Hello world\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你应该已经认出了之前教程中使用过的Text Component.在这个例子中,你要将其作为一个子属性添加至一个Column中.你可以把Column等同于HTML中的<div>标签.它是一个包装器,用于把组件整合在一起,并且可能会添加一些背景样式.由于Litho使用Yoga,捏可以添加flexbox属性来设置Column或Row的子项的布局.在此处,你只需简单设置padding(填充大小)和背景颜色.</p>\n<p>你如何渲染这个Component呢?在你的activity中,简单的修改Component定义为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component text = ListItem.create(context).build();</div></pre></td></tr></table></figure>\n<p>注意:你使用的是ListItem,而不是ListItemSpec.</p>\n<p>这个ListItem是哪里来的呢?create方法和build方法是在哪里定义的呢?这是Litho Specs的魔力所在.</p>\n<p>在入门指南中,我们学习了如何添加依赖至项目中,来使代码生成器能够工作.这会在你的代码上运行一个注释处理器.它会自动查找FooSpec的类名,并且自动生成根据Spec类在同一个包下生成Foo类.Litho将会为这些类自动添加所需的所有方法.此外,根据规则,注释处理器还将生成的额外方法(例如Text的textSizeSp方法或者Column/Row的backgroundColor方法).</p>\n<p>就这么简单。运行你的app,你应该看到如下的画面:</p>\n<p><img src=\"/image/20170428102947.png\" alt=\"\"></p>\n<h5 id=\"3-创建一个列表\"><a href=\"#3-创建一个列表\" class=\"headerlink\" title=\"3.创建一个列表\"></a>3.创建一个列表</h5><p>你可以使用Litho的核心组件Recycler Component来处理列表相关的工作.这个component在概念上类似于Android的RecyclerView,然而,使用Litho,所有的布局计算都是在一个子线程中处理的,这带来了显著的性能提升.在教程的本部分中,你将使用一个RecyclerBinder来为Recycler提供Component,方式与使用LayoutManager与Adapter配合向RecyclerView提供View的方式相同.<br>首先,在你的activity中,像下面这样定义Component:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> RecyclerBinder recyclerBinder = <span class=\"keyword\">new</span> RecyclerBinder(</div><div class=\"line\">    context,</div><div class=\"line\">    <span class=\"keyword\">new</span> LinearLayoutInfo(<span class=\"keyword\">this</span>, OrientationHelper.VERTICAL, <span class=\"keyword\">false</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">final</span> Component component = Recycler.create(context)</div><div class=\"line\">    .binder(recyclerBinder)</div><div class=\"line\">    .build();</div></pre></td></tr></table></figure></p>\n<p>这些代码构造了一个RecyclerBinder并且连接它到了一个Recycler上.新的RecyclerBinder使用context和layoutInfo作为构造参数.</p>\n<p>然后再创建Recycler并且把它传递给LithoView.</p>\n<p>现在,将重点放在使用item填充binder上.让我们定义一个helper方法来做这件事:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(RecyclerBinder recyclerBinder, ComponentContext context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">      recyclerBinder.insertItemAt(</div><div class=\"line\">          i,</div><div class=\"line\">          ComponentInfo.create()</div><div class=\"line\">              .component(ListItem.create(context).build())</div><div class=\"line\">              .build());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在代码中,我们需要创建一个ComponentInfo来描述Recycler需要展示的component.在本例中,我们需要展示ListItem.</p>\n<p>最后,在组件定义工作完成后,在activity的onCreate回调中调用addContent方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">addContent(recyclerBinder, context);</div></pre></td></tr></table></figure></p>\n<p>运行app,你会看见一个可以滚动的具有32个ListItem的列表.</p>\n<p><img src=\"/image/20170428105417.png\" alt=\"\"></p>\n<h5 id=\"4-定义Component的属性\"><a href=\"#4-定义Component的属性\" class=\"headerlink\" title=\"4.定义Component的属性\"></a>4.定义Component的属性</h5><p>列表如果只是简单的包含同一个component的拷贝就没有意义了.在这个部分,你需要把目光集中到属性,或者说props上.你可以设置很多的属性到Component上来改变它的外观和行为.</p>\n<p>为一个component添加props非常的简单.props是componentSpec的方法的参数,使用@Prop定义.</p>\n<p>像下面这样修改ListItemSpec:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext c,</div><div class=\"line\">    @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">    @Prop String title,</div><div class=\"line\">    @Prop String subtitle)</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">  <span class=\"keyword\">return</span> Column.create(c)</div><div class=\"line\">        .paddingDip(ALL, <span class=\"number\">16</span>)</div><div class=\"line\">        .backgroundColor(color)</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(title)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">40</span>))</div><div class=\"line\">        .child(</div><div class=\"line\">            Text.create(c)</div><div class=\"line\">                .text(subtitle)</div><div class=\"line\">                .textSizeSp(<span class=\"number\">20</span>))</div><div class=\"line\">        .build();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就添加了3个props:title,subtitle和color.注意现在背景颜色和Text的文字内容不再是写死的了,而是取决于onCreateLayout方法的参数了.</p>\n<p>神奇的事就发生在@Prop和注释处理器中,处理器以正确的方法生成符合props的component构造器.你现在可以修改你的binder构造方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addContent</span><span class=\"params\">(</div><div class=\"line\">    RecyclerBinder recyclerBinder, </div><div class=\"line\">    ComponentContext context)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</div><div class=\"line\">    ComponentInfo.Builder componentInfoBuilder = ComponentInfo.create();</div><div class=\"line\">    componentInfoBuilder.component(</div><div class=\"line\">        ListItem.create(context)</div><div class=\"line\">            .color(i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? Color.WHITE : Color.LTGRAY)</div><div class=\"line\">            .title(<span class=\"string\">\"Hello, world!\"</span>)</div><div class=\"line\">            .subtitle(<span class=\"string\">\"Litho tutorial\"</span>)</div><div class=\"line\">            .build());</div><div class=\"line\">    recyclerBinder.insertItemAt(i, componentInfoBuilder.build());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现在,当ListItem被构建出来时,color,title和subtitle 这些props就被传递进去了来改变每一行的背景颜色.</p>\n<p>运行app,你可以看到如下画面:</p>\n<p><img src=\"/image/20170428111627.png\" alt=\"\"></p>\n<p>你可以为@Prop注释指定更多的选项.例如下面的属性:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Prop</span>(optional = <span class=\"keyword\">true</span>, resType = ResType.DIMEN_OFFSET) <span class=\"keyword\">int</span> shadowRadius,</div></pre></td></tr></table></figure></p>\n<p>它告诉注释处理器构造一些函数，如shadowRadiusPx，shadowRadiusDip，shadowRadiusSp以及shadowRadiusRes。</p>\n<p>恭喜完成本教程！这个基础教程向你介绍了开始使用Litho所需要的所有基础构建块,并且教你构建了自己的Component。你可以在com.facebook.litho.widgets包中找到可以使用的预定义好的组件Component。你可以在<a href=\"\">这里</a>找到完整的教程。请务必查看<a href=\"\">此示例</a>和Litho API文档以获取更深入的代码。</p>\n<h3 id=\"编写Component\"><a href=\"#编写Component\" class=\"headerlink\" title=\"编写Component\"></a>编写Component</h3><h5 id=\"Component-Specs\"><a href=\"#Component-Specs\" class=\"headerlink\" title=\"Component Specs\"></a>Component Specs</h5><p>一个Component Spec可以生成一个你在UI中使用的Component.有两种类型的Component Spec:</p>\n<ul>\n<li>Layout spec: 可以结合其他component至一个特定的布局中.类似于Android中的ViewGroup.</li>\n<li>Mount spec: 一个可以渲染view或者drawable的的组件.</li>\n</ul>\n<p>现在，我们来看一下布局spec的整体结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop String title,</div><div class=\"line\">      @Prop Uri imageUri)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有几件事需要注意:</p>\n<ul>\n<li>Component Spec只是有着特殊注释的普通java类.</li>\n<li>Component Spec是完全无状态的,并且不包含任何的成员变量.</li>\n<li>带有@Prop注释的参数将会自动的添加到Component构造器中.</li>\n<li>为了能从Component Spec自动生成Component,你需要添加Litho注释处理器至你的BUCK或者Gradle文件中.请参阅<a href=\"\">入门指南</a>,了解如何做到这一点.你可以通过向类注释添加isPublic=false来使生成的类变为private的.</li>\n</ul>\n<h5 id=\"Spec-生命周期和Component类\"><a href=\"#Spec-生命周期和Component类\" class=\"headerlink\" title=\"Spec,生命周期和Component类\"></a>Spec,生命周期和Component类</h5><p>一个Component Spec子类将被处理用于生成一个ComponentLifecycle的子类,这个子类的名字将会是Spec的名字去掉soec后缀.例如,MyComponentSpec将会生成MyComponent类.</p>\n<p>这个生成的ComponentLifeCycle类就是今后你会在你的产品中使用的类.而Spec类将在运行的时候在新生成的代码里被用作一个代表类.</p>\n<p>生成的新类暴露出来的唯一的API是一个create（…）方法，它为您在Spec类中声明的@Props返回相应的Component.Builder。</p>\n<p>在运行的时候,同一种类型的component的所有实例都共享相同的componentLifecycle引用.这意味着一个spec实例对应的是一种component类型,而不是一个component实例.</p>\n<h3 id=\"使用Component\"><a href=\"#使用Component\" class=\"headerlink\" title=\"使用Component\"></a>使用Component</h3><p>生成的Component类为你在spec中定义的props提供了一个简单的构造器.为了在你的UI中使用生成的Component,你需要一个LithoView,它是一个Android ViewGroup并且可以渲染component.\\</p>\n<p>你可以通过以下的代码制定一个LithoView来渲染一个Component.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> Component component = MyComponent.create()</div><div class=\"line\">    .title(<span class=\"string\">\"My title\"</span>)</div><div class=\"line\">    .imageUri(Uri.parse(<span class=\"string\">\"http://example.com/myimage\"</span>)</div><div class=\"line\">    .build();</div><div class=\"line\">LithoView view = LithoView.create(context, component);</div></pre></td></tr></table></figure></p>\n<p>在这个例子中,MyComponent将被托管给LithoView,你可以在你的程序中像使用一个普通的Android View一样去使用这个LithoView.你可以在<a href=\"\">教程</a>里看到如何在一个Acitivity中使用这个LithoView.</p>\n<p>重要提醒:示例中的LithoView,如果你在你的View层级中直接使用,将会在主线程中同步的执行布局任务.有关在主线程之外执行布局任务的更多信息,请参阅<a href=\"\">异步布局</a>.</p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译(八)","date":"2017-04-27T02:09:23.000Z","_content":"\n# 架构\n\n### 代码生成器\n正如在【编写Conponent】中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——SpecModel，作为中间件。\n\n代码生成过程分为三个步骤：\n- 从ComponentSpec中生成一个SpecModel。\n- 验证SpecModel的合法性\n- 从SpecModel中生成Component。\n\n##### 创建SpecModel\nSpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.\n未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.\n\n##### SpecModel验证\nSpecModel有一个方法叫做validate(),它返回一个包含SpecModelValidationError(SpecModel验证错误)的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.\n\n##### Component生成\n如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个Javapoet TypeSpec(用它能够很容易的创建一个Component的class 文件).\n\n##### 给你的工程设置代码生成器\n如果你根据【开始工作】中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。\n\n### 异步布局(layout)\n\n##### 不可变性和线程安全\n大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:\n``` java\n public class SomeExampleClass {\n    private int mCounter;\n\n    public String getThisOrThat() {\n      if (mCounter > 10) {\n        return \"this\":\n      } else {\n        mCounter++;\n        return \"that\";\n      }\n    }\n  }\n```\n如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.\n\n而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.\n\n让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:\n``` java\npublic static class Result {\n    public final int mCounter;\n    public final String mValue;\n\n    public Result(int counter, int value) {\n      mCounter = counter;\n      mValue = value;\n    }\n  }\n\n  public class SomeExampleClass {\n    public static Result getThisOrThat(int counterValue) {\n      if (counterValue > 10) {\n        return new Result(counterValue, \"this\"):\n      } else {\n        return new Result(counterValue + 1, \"that\");\n      }\n    }\n  }\n\n```\n我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为\"纯净方法(pure function)\",因为它的输出结果只取决于输入值并且这么做没有任何副作用.\n\n在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为\"纯净方法\"的性质.\n\n在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和代码生成的概念来自动优化对象内存分配,使得内存分配花费降到最小.\n\n##### 同步和异步操作\nLitho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.\n\n同步的布局计算能够确保一旦在ComponentTree中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到LithoView上.\n\n而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.\n\n异步的布局计算将会使用Litho的\"布局线程\"来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于RecyclerBinder的示例中.\n\n### 增量式挂载\n虽然Component提供了扁平化的view层级结构和主线程外的布局计算功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.\n\nLitho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.\n\n使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.\n\n![](/image/20170426150321.png)\n如果你使用Litho的异步RecyclerView支持,框架将会无缝的支持增量式挂载.\n\n### View的扁平化\n让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.\n\n![](/image/20170426150749.png)\n\nLitho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。\n\n我们使用两种途径来实现:\n首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。\n第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。\n\n这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点(启用了开发者选项中的显示布局边界).\n\n![](/image/20170426150806.png)\n\n虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构\"去扁平化\"。例如，如果要在示例中启用单击图像或文本，如果设置了点击处理器,框架将自动把文字或图像包装在view一个新的view中。\n\n### 回收机制\n\n设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。\nAndroid使用RecyclerView解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。\n\n![](/image/20170426171157.gif)\n\nRecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。\n\n![](/image/20170426172051.gif)\n\n##### Litho增量式回收\n\n我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。\n\n![](/image/20170426172130.gif)\n\n回收利用像Text这样的\"原始item\"能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的\"原始item\"来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。","source":"_posts/2017-04-27-Facebook出品的Android声明式开源新框架Litho文档翻译(八).md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译(八)\ndate: 2017-04-27 10:09:23\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n# 架构\n\n### 代码生成器\n正如在【编写Conponent】中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——SpecModel，作为中间件。\n\n代码生成过程分为三个步骤：\n- 从ComponentSpec中生成一个SpecModel。\n- 验证SpecModel的合法性\n- 从SpecModel中生成Component。\n\n##### 创建SpecModel\nSpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.\n未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.\n\n##### SpecModel验证\nSpecModel有一个方法叫做validate(),它返回一个包含SpecModelValidationError(SpecModel验证错误)的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.\n\n##### Component生成\n如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个Javapoet TypeSpec(用它能够很容易的创建一个Component的class 文件).\n\n##### 给你的工程设置代码生成器\n如果你根据【开始工作】中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。\n\n### 异步布局(layout)\n\n##### 不可变性和线程安全\n大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:\n``` java\n public class SomeExampleClass {\n    private int mCounter;\n\n    public String getThisOrThat() {\n      if (mCounter > 10) {\n        return \"this\":\n      } else {\n        mCounter++;\n        return \"that\";\n      }\n    }\n  }\n```\n如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.\n\n而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.\n\n让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:\n``` java\npublic static class Result {\n    public final int mCounter;\n    public final String mValue;\n\n    public Result(int counter, int value) {\n      mCounter = counter;\n      mValue = value;\n    }\n  }\n\n  public class SomeExampleClass {\n    public static Result getThisOrThat(int counterValue) {\n      if (counterValue > 10) {\n        return new Result(counterValue, \"this\"):\n      } else {\n        return new Result(counterValue + 1, \"that\");\n      }\n    }\n  }\n\n```\n我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为\"纯净方法(pure function)\",因为它的输出结果只取决于输入值并且这么做没有任何副作用.\n\n在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为\"纯净方法\"的性质.\n\n在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和代码生成的概念来自动优化对象内存分配,使得内存分配花费降到最小.\n\n##### 同步和异步操作\nLitho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.\n\n同步的布局计算能够确保一旦在ComponentTree中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到LithoView上.\n\n而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.\n\n异步的布局计算将会使用Litho的\"布局线程\"来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于RecyclerBinder的示例中.\n\n### 增量式挂载\n虽然Component提供了扁平化的view层级结构和主线程外的布局计算功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.\n\nLitho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.\n\n使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.\n\n![](/image/20170426150321.png)\n如果你使用Litho的异步RecyclerView支持,框架将会无缝的支持增量式挂载.\n\n### View的扁平化\n让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.\n\n![](/image/20170426150749.png)\n\nLitho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。\n\n我们使用两种途径来实现:\n首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。\n第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。\n\n这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点(启用了开发者选项中的显示布局边界).\n\n![](/image/20170426150806.png)\n\n虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构\"去扁平化\"。例如，如果要在示例中启用单击图像或文本，如果设置了点击处理器,框架将自动把文字或图像包装在view一个新的view中。\n\n### 回收机制\n\n设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。\nAndroid使用RecyclerView解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。\n\n![](/image/20170426171157.gif)\n\nRecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。\n\n![](/image/20170426172051.gif)\n\n##### Litho增量式回收\n\n我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。\n\n![](/image/20170426172130.gif)\n\n回收利用像Text这样的\"原始item\"能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的\"原始item\"来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译(八)","published":1,"updated":"2017-04-27T08:04:53.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj21nzolc000c1srl5p6udrup","content":"<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><h3 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h3><p>正如在【编写Conponent】中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——SpecModel，作为中间件。</p>\n<p>代码生成过程分为三个步骤：</p>\n<ul>\n<li>从ComponentSpec中生成一个SpecModel。</li>\n<li>验证SpecModel的合法性</li>\n<li>从SpecModel中生成Component。</li>\n</ul>\n<h5 id=\"创建SpecModel\"><a href=\"#创建SpecModel\" class=\"headerlink\" title=\"创建SpecModel\"></a>创建SpecModel</h5><p>SpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.<br>未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.</p>\n<h5 id=\"SpecModel验证\"><a href=\"#SpecModel验证\" class=\"headerlink\" title=\"SpecModel验证\"></a>SpecModel验证</h5><p>SpecModel有一个方法叫做validate(),它返回一个包含SpecModelValidationError(SpecModel验证错误)的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.</p>\n<h5 id=\"Component生成\"><a href=\"#Component生成\" class=\"headerlink\" title=\"Component生成\"></a>Component生成</h5><p>如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个Javapoet TypeSpec(用它能够很容易的创建一个Component的class 文件).</p>\n<h5 id=\"给你的工程设置代码生成器\"><a href=\"#给你的工程设置代码生成器\" class=\"headerlink\" title=\"给你的工程设置代码生成器\"></a>给你的工程设置代码生成器</h5><p>如果你根据【开始工作】中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。</p>\n<h3 id=\"异步布局-layout\"><a href=\"#异步布局-layout\" class=\"headerlink\" title=\"异步布局(layout)\"></a>异步布局(layout)</h3><h5 id=\"不可变性和线程安全\"><a href=\"#不可变性和线程安全\" class=\"headerlink\" title=\"不可变性和线程安全\"></a>不可变性和线程安全</h5><p>大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getThisOrThat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (mCounter &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"this\"</span>:</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       mCounter++;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"that\"</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.</p>\n<p>而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.</p>\n<p>让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Result</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String mValue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Result</span><span class=\"params\">(<span class=\"keyword\">int</span> counter, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">      mCounter = counter;</div><div class=\"line\">      mValue = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title\">getThisOrThat</span><span class=\"params\">(<span class=\"keyword\">int</span> counterValue)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (counterValue &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue, <span class=\"string\">\"this\"</span>):</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue + <span class=\"number\">1</span>, <span class=\"string\">\"that\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为”纯净方法(pure function)”,因为它的输出结果只取决于输入值并且这么做没有任何副作用.</p>\n<p>在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为”纯净方法”的性质.</p>\n<p>在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和代码生成的概念来自动优化对象内存分配,使得内存分配花费降到最小.</p>\n<h5 id=\"同步和异步操作\"><a href=\"#同步和异步操作\" class=\"headerlink\" title=\"同步和异步操作\"></a>同步和异步操作</h5><p>Litho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.</p>\n<p>同步的布局计算能够确保一旦在ComponentTree中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到LithoView上.</p>\n<p>而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.</p>\n<p>异步的布局计算将会使用Litho的”布局线程”来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于RecyclerBinder的示例中.</p>\n<h3 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a>增量式挂载</h3><p>虽然Component提供了扁平化的view层级结构和主线程外的布局计算功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.</p>\n<p>Litho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.</p>\n<p>使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.</p>\n<p><img src=\"/image/20170426150321.png\" alt=\"\"><br>如果你使用Litho的异步RecyclerView支持,框架将会无缝的支持增量式挂载.</p>\n<h3 id=\"View的扁平化\"><a href=\"#View的扁平化\" class=\"headerlink\" title=\"View的扁平化\"></a>View的扁平化</h3><p>让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.</p>\n<p><img src=\"/image/20170426150749.png\" alt=\"\"></p>\n<p>Litho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。</p>\n<p>我们使用两种途径来实现:<br>首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。<br>第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。</p>\n<p>这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点(启用了开发者选项中的显示布局边界).</p>\n<p><img src=\"/image/20170426150806.png\" alt=\"\"></p>\n<p>虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构”去扁平化”。例如，如果要在示例中启用单击图像或文本，如果设置了点击处理器,框架将自动把文字或图像包装在view一个新的view中。</p>\n<h3 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a>回收机制</h3><p>设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。<br>Android使用RecyclerView解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。</p>\n<p><img src=\"/image/20170426171157.gif\" alt=\"\"></p>\n<p>RecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。</p>\n<p><img src=\"/image/20170426172051.gif\" alt=\"\"></p>\n<h5 id=\"Litho增量式回收\"><a href=\"#Litho增量式回收\" class=\"headerlink\" title=\"Litho增量式回收\"></a>Litho增量式回收</h5><p>我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。</p>\n<p><img src=\"/image/20170426172130.gif\" alt=\"\"></p>\n<p>回收利用像Text这样的”原始item”能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的”原始item”来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。</p>\n","excerpt":"","more":"<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><h3 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h3><p>正如在【编写Conponent】中写道的，Litho依赖代码生成器来从ComponentSpec生成Component.这个过程需要用到一个不可变的java对象——SpecModel，作为中间件。</p>\n<p>代码生成过程分为三个步骤：</p>\n<ul>\n<li>从ComponentSpec中生成一个SpecModel。</li>\n<li>验证SpecModel的合法性</li>\n<li>从SpecModel中生成Component。</li>\n</ul>\n<h5 id=\"创建SpecModel\"><a href=\"#创建SpecModel\" class=\"headerlink\" title=\"创建SpecModel\"></a>创建SpecModel</h5><p>SpecModel是在编译时，由注解处理器(一个扫描和处理注解的javac工具)生成的.Litho的注解处理器将会扫描你的ComponentSpec中的方法,变量和注释,为每一个ComponentSpec创建SpecModel.<br>未来,我们将会支持使用其他方法创建SpecModel.举个例子:我们考虑支持直接在Android Studio/Intellij中创建SpecModel,这样可以允许我们不用build源码就可以生成Component.</p>\n<h5 id=\"SpecModel验证\"><a href=\"#SpecModel验证\" class=\"headerlink\" title=\"SpecModel验证\"></a>SpecModel验证</h5><p>SpecModel有一个方法叫做validate(),它返回一个包含SpecModelValidationError(SpecModel验证错误)的list.如果这个list为空,说明这个Spec是格式合法的,可以用它来创建一个合法的component.如果不是,这个list则会包含一系列需要在Component生成前修复的错误.</p>\n<h5 id=\"Component生成\"><a href=\"#Component生成\" class=\"headerlink\" title=\"Component生成\"></a>Component生成</h5><p>如果SpecModel验证步骤成功了,接着generate方法将会被调用,它将会生成一个Javapoet TypeSpec(用它能够很容易的创建一个Component的class 文件).</p>\n<h5 id=\"给你的工程设置代码生成器\"><a href=\"#给你的工程设置代码生成器\" class=\"headerlink\" title=\"给你的工程设置代码生成器\"></a>给你的工程设置代码生成器</h5><p>如果你根据【开始工作】中的说明设置了你的工程代码，那么代码生成器就被自动设置好了。</p>\n<h3 id=\"异步布局-layout\"><a href=\"#异步布局-layout\" class=\"headerlink\" title=\"异步布局(layout)\"></a>异步布局(layout)</h3><h5 id=\"不可变性和线程安全\"><a href=\"#不可变性和线程安全\" class=\"headerlink\" title=\"不可变性和线程安全\"></a>不可变性和线程安全</h5><p>大多数线程安全的问题都是由对可变对象的并发读写造成的.在Java中,一个典型的此类问题是这样的:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getThisOrThat</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (mCounter &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"this\"</span>:</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       mCounter++;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"that\"</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>如果有多个线程都调用一个共享的SomeExampleClass中的的getThisOrThat方法,这就构成了一个最经典的竞争情况.当第二个线程进入这个方法尝试获取mCounter时,第一个线程可能正在执行mCounter++,因此我们不能确定第二个线程从mCounter中读到的值是什么.出现这个问题的原因是在我们的代码中存在一个可变的状态变量(mCounter),并且有多个线程尝试去读写它.竞争情况是我们在使用多线程编程去处理任务时最常遇到的问题.</p>\n<p>而这就是为什么传统上在多线程上运行UI代码都会变得极其复杂的原因.Android中的view是有状态的和可变的.比如一个TextView,它必须保持追踪现在显示的文字,并且暴露一个setText()方法给开发者去修改文字.这就意味着Android UI框架如果决定要分流一些工作(例如layout计算)到第二个线程中去做,它就必须解决用户在其他线程中调用setText()而改变了当前正在布局计算中的文字的问题.</p>\n<p>让我们回到我们刚才的示例代码.我们说主要的问题就在我们的getThisOrThat()方法中的可变状态变量mCounter的存取.有没有一种方法能够做到功能上和它一致但是却不用依赖这种可变的状态变量呢?让我们想象一种情况:所有对象在创建后都不能改变其自身的内容.如果没有内容改变,我们也就不会有线程间尝试存取同一个状态变量的竞争问题了.我们可以重新改写一下我们的示例代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Result</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mCounter;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String mValue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Result</span><span class=\"params\">(<span class=\"keyword\">int</span> counter, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">      mCounter = counter;</div><div class=\"line\">      mValue = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeExampleClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Result <span class=\"title\">getThisOrThat</span><span class=\"params\">(<span class=\"keyword\">int</span> counterValue)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (counterValue &gt; <span class=\"number\">10</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue, <span class=\"string\">\"this\"</span>):</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result(counterValue + <span class=\"number\">1</span>, <span class=\"string\">\"that\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>我们的方法现在完全是线程安全的了,因为它从来没有改动过任何SomeExampleClass中的内部状态变量.在这个例子中,getThisOrThat()方法我们称之为”纯净方法(pure function)”,因为它的输出结果只取决于输入值并且这么做没有任何副作用.</p>\n<p>在Litho中我们尝试应用这种概念到布局计算中.Component是一个包含了所有提供给布局方法的输入值的不可变的类.而这些输入值以@Prop和@State的格式提供.这也解释了为什么我们需要@Prop和@State为不可变的.因为如果它们是可变的,我们获取布局的函数就失去了作为”纯净方法”的性质.</p>\n<p>在Java中,不可变性在中通常意味着需要花费时间做更多的内存分配动作.即使在我们的简单的示例中,我们每次调用我们的方法时都需要分配一个新的Result对象内存.而Litho使用池的概念和代码生成的概念来自动优化对象内存分配,使得内存分配花费降到最小.</p>\n<h5 id=\"同步和异步操作\"><a href=\"#同步和异步操作\" class=\"headerlink\" title=\"同步和异步操作\"></a>同步和异步操作</h5><p>Litho同时提供了同步的和异步的API用来做布局计算.两种API都是线程安全的并且都可以在任意线程中调用.最终的布局总是呈现最后使用setRoot()或者setRootAsync()设置的Component.</p>\n<p>同步的布局计算能够确保一旦在ComponentTree中调用了setRoot,布局计算的结果就能立刻准备好,以供挂载到LithoView上.</p>\n<p>而它的主要的缺陷是由于它的布局计算工作发生在调用setRoot()的线程中,因此不建议在主线程中调用它.而在另一方面,在一些情况下,你不能在展示一些东西在屏幕上之前就等待后台进程去计算布局,比如说你要展示的item已经在视窗口了.这种情况下调用setRoot()是最好的选择.使用同步的操作也能是集成Litho至已存在的线程体系变得更加简单.如果你的程序已经拥有了一个复杂并且结构化的线程设计,你可能会不想依赖Litho的内建线程去完成布局计算.</p>\n<p>异步的布局计算将会使用Litho的”布局线程”来计算布局,这意味着当调用布局计算时,布局工作将会立刻进入另一个独立线程的工作队列中而不会立即向它的调用线程返回结果.异步的布局操作被广泛的应用于RecyclerBinder的示例中.</p>\n<h3 id=\"增量式挂载\"><a href=\"#增量式挂载\" class=\"headerlink\" title=\"增量式挂载\"></a>增量式挂载</h3><p>虽然Component提供了扁平化的view层级结构和主线程外的布局计算功能,但是装载操作(包括对view和drawable的创建,回收和附加工作)在复杂的component中依然花费主线程的大量资源,尤其是那些包含很多view的component.</p>\n<p>Litho可以把装载component的花费平均分配至每一个UI帧来避免卡顿,并且对开发者来说是透明的.</p>\n<p>使用增量式挂载(默认支持),LithoView将只会挂载与当前可见区域大小相适应的内容并且卸载(并且回收)那些已经看不见了的component.</p>\n<p><img src=\"/image/20170426150321.png\" alt=\"\"><br>如果你使用Litho的异步RecyclerView支持,框架将会无缝的支持增量式挂载.</p>\n<h3 id=\"View的扁平化\"><a href=\"#View的扁平化\" class=\"headerlink\" title=\"View的扁平化\"></a>View的扁平化</h3><p>让我们看看下方的例子.它包含一个图片一个标题和一个副标题.在传统的Android View 系统里,你可以使用几个view来包含这些元素,再用一个viewGroup来包裹它们.</p>\n<p><img src=\"/image/20170426150749.png\" alt=\"\"></p>\n<p>Litho会自动减少最终UI层级结构所包含的View数量。布局计算这一步产生的布局树只是你的UI的蓝图，与Android的View没有直接的耦合。这允许框架在挂载组件之前处理布局树以获得最佳渲染性能。</p>\n<p>我们使用两种途径来实现:<br>首先，Litho能在布局计算后完全忽略容器类，因为它们在挂载步骤中不会被用到。拿我们的例子来说，在挂载时，不会有单独包含标题和子标题的View。<br>第二，Litho可以选择挂载一个view或者挂载一个drawable。事实上，对于Litho框架里的大多数核心组件，如Text和Image，挂载的是drawable，而不是view。</p>\n<p>这些优化的结果是,示例中UI的组件实际上将被渲染为一个独立,扁平的视图。你可以在下面的屏幕截图中看到这一点(启用了开发者选项中的显示布局边界).</p>\n<p><img src=\"/image/20170426150806.png\" alt=\"\"></p>\n<p>虽然扁平化的view对于减少内存使用和缩短绘制时间有相当大的好处，但它并不是一颗银弹(译者注:即它不是一个对所有情况都能用的万用方案)。当我们希望依赖Android view的特定功能时（例如触摸事件处理，可访问性或局部无效化），Litho提供一个非常通用的系统来自动对挂载Component的视图层次结构”去扁平化”。例如，如果要在示例中启用单击图像或文本，如果设置了点击处理器,框架将自动把文字或图像包装在view一个新的view中。</p>\n<h3 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a>回收机制</h3><p>设备屏幕通常以每秒60帧的速率刷新。为了能提供流畅的UI效果，应用程序需要能够每16ms一帧的速度持续渲染我们的UI。如果达不到这个时间标准，就会导致丢帧和不佳的用户体验。随着UI变得越来越复杂，在限制的时间内越来越难以完成所有的渲染工作。特别是在动态滚动的界面上,因为新的UI块的不断被添加到屏幕上，完成渲染就变得尤其有挑战性。<br>Android使用RecyclerView解决了这个问题，RecyclerView是一个动态UI容器，可以通过创建足够的视图来填充屏幕，然后在UI滚动中回收和重用它们，以显示大量数据中的元素。</p>\n<p><img src=\"/image/20170426171157.gif\" alt=\"\"></p>\n<p>RecyclerView支持异构的内容的显示。为此，它会根据item的不同的类型将其保留在不同的池中。虽然这个方法在简单情况下工作正常，但是对于具有许多不同item类型的UI，这种方法已经被证明是有问题的。在具有许多item类型的场景中，如果一个item随着滚动事件进入视窗,则它这种类型的item是RecyclerView第一次显示可能性非常大。如果发生这种情况，RecyclerView必须为这个item进行内存分配。在短短的16ms中,RecyclerView必须为新的item进行绑定，测量和布局工作。</p>\n<p><img src=\"/image/20170426172051.gif\" alt=\"\"></p>\n<h5 id=\"Litho增量式回收\"><a href=\"#Litho增量式回收\" class=\"headerlink\" title=\"Litho增量式回收\"></a>Litho增量式回收</h5><p>我们希望为Litho建立一个更具可扩展性和更高效率的回收系统，同时我们希望从API中消除item类型的复杂性。在Litho中，布局的描述与实际用于在屏幕上呈现UI的Views和Drawable完全不相关。这意味着当我们需要在屏幕上放置一个新的RecyclerView item时，我们已经完全知道了该item的内容和该item与其余UI的相对位置。这允许Litho完全摆脱item类型的概念。在recyclerview滚动时,比起重复利用view来表示item,我们选择了增量式的利用例如Text或者Image这样的构建块.这种做法在传统的Android view上是不可能的，因为在传统的Android中,我们需要在完整的view tree上进行布局计算,当我们算出所有view的位置时，一切都已经被实例化了。</p>\n<p><img src=\"/image/20170426172130.gif\" alt=\"\"></p>\n<p>回收利用像Text这样的”原始item”能够大大增加应用程序的内存效率，比如你可以回收list中的任何一个Text的给其他需要显示的Text来用。最重要的是，由于我们的布局是提前计算的，所以我们能够确切地知道一个新的item什么时候会变得可见，这意味着，我们可以在屏幕上引入非常少量的”原始item”来显示每一帧,而不是在一帧中绑定并且绘制一个大的view tree。</p>\n"},{"title":"Facebook出品的Android声明式开源新框架Litho文档翻译(三)","date":"2017-04-28T06:12:50.000Z","_content":"\n# 参考\n\n### Layout Specs\nLayout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.\n\n实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的[ComponentLayout]()对象的树.\n\n让我们从一个简单的例子开始:\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop int color,\n      @Prop String title) {\n\n      return Row.create(c)\n          .alignItems(CENTER)\n          .child(\n              SolidColor.create(c)\n                  .colorRes(color)\n                  .withLayout()\n                  .widthDip(40)\n                  .heightDip(40))\n          .child(\n              Text.create(c)\n                  .text(title)\n                  .textSizeRes(R.dimen.my_text_size)\n                  .withLayout()\n                  .flexGrow(1f))\n          .build();\n  }\n}\n```\n\n正如你所见,layout spec类使用@LayoutSpec注释.\n\n用@OnCreateLayout注释标注的方法必须以[ComponentContext]()作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.\n\n在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.\n\n第一个子节点是一个[SolidColor]() component,它拥有一个colorRes的Prop和40dp的宽和高.\n\n``` java\nSolidColor.create(c)\n    .uri(imageUri)\n    .withLayout()\n    .width(40)\n    .height(40)\n```\n\n第二个子节点是一个Text Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.\n``` java\nText.create(c)\n    .text(title)\n    .textSizeRes(R.dimen.my_text_size)\n    .withLayout()\n    .grow(1f)\n```\n\n你可以查看完整的[Yoga]()文档来获取所有框架开放出的布局特性.\n\n\n### Mount Specs\n一个Mount Spec定义了一个可以渲染Views或者drawables的component.\n\nMount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.\n\nMount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.\n\nmount spec component的生命周期如下:\n- 在布局计算之前,运行@OnPrepare一次\n- 在布局计算过程中,可选择的运行OnMeasure.\n- 在布局计算之后,运行@OnBoundsDefined一次.\n- 在component添加到托管视图之前,运行@OnCreateMountContent\n- 在component添加到托管视图之前,运行@OnMount\n- 在component添加到托管视图之后,运行@OnBind\n- 在从托管视图移除component之前,运行@OnUnBind\n- 在从托管视图移除component之前,可选择的运行@OnUnmount\n\n##### 挂载\n让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @Prop String colorName) {\n    colorDrawable.setColor(Color.parseColor(colorName));\n  }\n}\n```\n- 挂载操作的API与Android的RecyclerView Adapter非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.\n- onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。\n- 挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).\n- onCreateMountContent不能使用@Prop或任何其他带注释的参数。\n- 鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。\n\n##### 阶段之间的输入和输出\n你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.\n\n假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.\n\n让我们看看ColorComponent的@OnPrepare方法:\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnPrepare\n  static void onPrepare(\n      Context context,\n      @Prop String colorName,\n      Output<Integer> color) {\n    color.set(Color.parseColor(colorName));\n  }\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @FromPrepare int color) {\n    convertDrawable.setColor(color);\n  }\n}\n```\n在@MountSpec方法中使用Output<?>会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.\n\n在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.\n\n##### 测量\n如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.\n\n现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.\n``` java\n@OnMeasure\nstatic void onMeasure(\n    ComponentContext context,\n    ComponentLayout layout,\n    int widthSpec,\n    int heightSpec,\n    Size size) {\n\n  // If width is undefined, set default size.\n  if (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) {\n    size.width = 40;\n  } else {\n    size.width = SizeSpec.getSize(widthSpec);\n  }\n\n  // If height is undefined, use 1.5 aspect ratio.\n  if (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) {\n    size.height = width * 1.5;\n  } else {\n    size.height = SizeSpec.getSize(heightSpec);\n  }\n}\n```\n在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的[MeasureSpec]().\n\n就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.\n\n##### ShouldUpdate\n\nMount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。\n@ShouldUpdate的调用的前提是component是\"纯渲染函数\"。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。\n一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为\"纯渲染的\"。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：\n\n``` java\n@ShouldUpdate(onMount = true)\npublic boolean shouldUpdate(Diff<String> someStringProp) {\n  return !someStringProp.getPrevious().equals(someStringProp.getNext());\n}\n```\n\nshouldUpdate中的参数是prop或状态的对比差异。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<String>，以便能够比较此@Prop的旧值和新值。\nshouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。\n\n@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。\n\n@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。","source":"_posts/2017-04-28-Facebook出品的Android声明式开源新框架Litho文档翻译(三).md","raw":"---\ntitle: Facebook出品的Android声明式开源新框架Litho文档翻译(三)\ndate: 2017-04-28 14:12:50\ntags: [Android,实用库,Litho]\ncategory: Android知识\n---\n\n# 参考\n\n### Layout Specs\nLayout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.\n\n实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的[ComponentLayout]()对象的树.\n\n让我们从一个简单的例子开始:\n``` java\n@LayoutSpec\npublic class MyComponentSpec {\n  @OnCreateLayout\n  static ComponentLayout onCreateLayout(\n      ComponentContext c,\n      @Prop int color,\n      @Prop String title) {\n\n      return Row.create(c)\n          .alignItems(CENTER)\n          .child(\n              SolidColor.create(c)\n                  .colorRes(color)\n                  .withLayout()\n                  .widthDip(40)\n                  .heightDip(40))\n          .child(\n              Text.create(c)\n                  .text(title)\n                  .textSizeRes(R.dimen.my_text_size)\n                  .withLayout()\n                  .flexGrow(1f))\n          .build();\n  }\n}\n```\n\n正如你所见,layout spec类使用@LayoutSpec注释.\n\n用@OnCreateLayout注释标注的方法必须以[ComponentContext]()作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.\n\n在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.\n\n第一个子节点是一个[SolidColor]() component,它拥有一个colorRes的Prop和40dp的宽和高.\n\n``` java\nSolidColor.create(c)\n    .uri(imageUri)\n    .withLayout()\n    .width(40)\n    .height(40)\n```\n\n第二个子节点是一个Text Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.\n``` java\nText.create(c)\n    .text(title)\n    .textSizeRes(R.dimen.my_text_size)\n    .withLayout()\n    .grow(1f)\n```\n\n你可以查看完整的[Yoga]()文档来获取所有框架开放出的布局特性.\n\n\n### Mount Specs\n一个Mount Spec定义了一个可以渲染Views或者drawables的component.\n\nMount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.\n\nMount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.\n\nmount spec component的生命周期如下:\n- 在布局计算之前,运行@OnPrepare一次\n- 在布局计算过程中,可选择的运行OnMeasure.\n- 在布局计算之后,运行@OnBoundsDefined一次.\n- 在component添加到托管视图之前,运行@OnCreateMountContent\n- 在component添加到托管视图之前,运行@OnMount\n- 在component添加到托管视图之后,运行@OnBind\n- 在从托管视图移除component之前,运行@OnUnBind\n- 在从托管视图移除component之前,可选择的运行@OnUnmount\n\n##### 挂载\n让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @Prop String colorName) {\n    colorDrawable.setColor(Color.parseColor(colorName));\n  }\n}\n```\n- 挂载操作的API与Android的RecyclerView Adapter非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.\n- onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。\n- 挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).\n- onCreateMountContent不能使用@Prop或任何其他带注释的参数。\n- 鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。\n\n##### 阶段之间的输入和输出\n你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.\n\n假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.\n\n让我们看看ColorComponent的@OnPrepare方法:\n``` java\n@MountSpec\npublic class ColorComponentSpec {\n\n  @OnPrepare\n  static void onPrepare(\n      Context context,\n      @Prop String colorName,\n      Output<Integer> color) {\n    color.set(Color.parseColor(colorName));\n  }\n\n  @OnCreateMountContent\n  static ColorDrawable onCreateMountContent(ComponentContext c) {\n    return new ColorDrawable();\n  }\n\n  @OnMount\n  static void onMount(\n      ComponentContext context,\n      ColorDrawable colorDrawable,\n      @FromPrepare int color) {\n    convertDrawable.setColor(color);\n  }\n}\n```\n在@MountSpec方法中使用Output<?>会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.\n\n在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.\n\n##### 测量\n如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.\n\n现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.\n``` java\n@OnMeasure\nstatic void onMeasure(\n    ComponentContext context,\n    ComponentLayout layout,\n    int widthSpec,\n    int heightSpec,\n    Size size) {\n\n  // If width is undefined, set default size.\n  if (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) {\n    size.width = 40;\n  } else {\n    size.width = SizeSpec.getSize(widthSpec);\n  }\n\n  // If height is undefined, use 1.5 aspect ratio.\n  if (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) {\n    size.height = width * 1.5;\n  } else {\n    size.height = SizeSpec.getSize(heightSpec);\n  }\n}\n```\n在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的[MeasureSpec]().\n\n就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.\n\n##### ShouldUpdate\n\nMount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。\n@ShouldUpdate的调用的前提是component是\"纯渲染函数\"。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。\n一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为\"纯渲染的\"。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：\n\n``` java\n@ShouldUpdate(onMount = true)\npublic boolean shouldUpdate(Diff<String> someStringProp) {\n  return !someStringProp.getPrevious().equals(someStringProp.getNext());\n}\n```\n\nshouldUpdate中的参数是prop或状态的对比差异。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<String>，以便能够比较此@Prop的旧值和新值。\nshouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。\n\n@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。\n\n@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。","slug":"Facebook出品的Android声明式开源新框架Litho文档翻译(三)","published":1,"updated":"2017-05-02T02:50:26.151Z","_id":"cj21nzold000e1srlk0lhm8gt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><h3 id=\"Layout-Specs\"><a href=\"#Layout-Specs\" class=\"headerlink\" title=\"Layout Specs\"></a>Layout Specs</h3><p>Layout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.</p>\n<p>实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的<a href=\"\">ComponentLayout</a>对象的树.</p>\n<p>让我们从一个简单的例子开始:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">      @Prop String title) &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">          .alignItems(CENTER)</div><div class=\"line\">          .child(</div><div class=\"line\">              SolidColor.create(c)</div><div class=\"line\">                  .colorRes(color)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .widthDip(<span class=\"number\">40</span>)</div><div class=\"line\">                  .heightDip(<span class=\"number\">40</span>))</div><div class=\"line\">          .child(</div><div class=\"line\">              Text.create(c)</div><div class=\"line\">                  .text(title)</div><div class=\"line\">                  .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .flexGrow(<span class=\"number\">1f</span>))</div><div class=\"line\">          .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>正如你所见,layout spec类使用@LayoutSpec注释.</p>\n<p>用@OnCreateLayout注释标注的方法必须以<a href=\"\">ComponentContext</a>作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.</p>\n<p>在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.</p>\n<p>第一个子节点是一个<a href=\"\">SolidColor</a> component,它拥有一个colorRes的Prop和40dp的宽和高.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SolidColor.create(c)</div><div class=\"line\">    .uri(imageUri)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .width(<span class=\"number\">40</span>)</div><div class=\"line\">    .height(<span class=\"number\">40</span>)</div></pre></td></tr></table></figure>\n<p>第二个子节点是一个Text Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .grow(<span class=\"number\">1f</span>)</div></pre></td></tr></table></figure></p>\n<p>你可以查看完整的<a href=\"\">Yoga</a>文档来获取所有框架开放出的布局特性.</p>\n<h3 id=\"Mount-Specs\"><a href=\"#Mount-Specs\" class=\"headerlink\" title=\"Mount Specs\"></a>Mount Specs</h3><p>一个Mount Spec定义了一个可以渲染Views或者drawables的component.</p>\n<p>Mount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.</p>\n<p>Mount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.</p>\n<p>mount spec component的生命周期如下:</p>\n<ul>\n<li>在布局计算之前,运行@OnPrepare一次</li>\n<li>在布局计算过程中,可选择的运行OnMeasure.</li>\n<li>在布局计算之后,运行@OnBoundsDefined一次.</li>\n<li>在component添加到托管视图之前,运行@OnCreateMountContent</li>\n<li>在component添加到托管视图之前,运行@OnMount</li>\n<li>在component添加到托管视图之后,运行@OnBind</li>\n<li>在从托管视图移除component之前,运行@OnUnBind</li>\n<li>在从托管视图移除component之前,可选择的运行@OnUnmount</li>\n</ul>\n<h5 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h5><p>让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @Prop String colorName) &#123;</div><div class=\"line\">    colorDrawable.setColor(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>挂载操作的API与Android的RecyclerView Adapter非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.</li>\n<li>onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。</li>\n<li>挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).</li>\n<li>onCreateMountContent不能使用@Prop或任何其他带注释的参数。</li>\n<li>鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。</li>\n</ul>\n<h5 id=\"阶段之间的输入和输出\"><a href=\"#阶段之间的输入和输出\" class=\"headerlink\" title=\"阶段之间的输入和输出\"></a>阶段之间的输入和输出</h5><p>你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.</p>\n<p>假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.</p>\n<p>让我们看看ColorComponent的@OnPrepare方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnPrepare</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepare</span><span class=\"params\">(</span></span></div><div class=\"line\">      Context context,</div><div class=\"line\">      @Prop String colorName,</div><div class=\"line\">      Output&lt;Integer&gt; color) &#123;</div><div class=\"line\">    color.set(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</span></span></div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @FromPrepare <span class=\"keyword\">int</span> color) &#123;</div><div class=\"line\">    convertDrawable.setColor(color);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@MountSpec方法中使用Output&lt;?&gt;会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.</p>\n<p>在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.</p>\n<h5 id=\"测量\"><a href=\"#测量\" class=\"headerlink\" title=\"测量\"></a>测量</h5><p>如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.</p>\n<p>现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnMeasure</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(</span></span></div><div class=\"line\">    ComponentContext context,</div><div class=\"line\">    ComponentLayout layout,</div><div class=\"line\">    <span class=\"keyword\">int</span> widthSpec,</div><div class=\"line\">    <span class=\"keyword\">int</span> heightSpec,</div><div class=\"line\">    Size size) &#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If width is undefined, set default size.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.width = <span class=\"number\">40</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.width = SizeSpec.getSize(widthSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If height is undefined, use 1.5 aspect ratio.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.height = width * <span class=\"number\">1.5</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.height = SizeSpec.getSize(heightSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的<a href=\"\">MeasureSpec</a>.</p>\n<p>就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.</p>\n<h5 id=\"ShouldUpdate\"><a href=\"#ShouldUpdate\" class=\"headerlink\" title=\"ShouldUpdate\"></a>ShouldUpdate</h5><p>Mount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。<br>@ShouldUpdate的调用的前提是component是”纯渲染函数”。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。<br>一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为”纯渲染的”。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@ShouldUpdate</span>(onMount = <span class=\"keyword\">true</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldUpdate</span><span class=\"params\">(Diff&lt;String&gt; someStringProp)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> !someStringProp.getPrevious().equals(someStringProp.getNext());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>shouldUpdate中的参数是prop或状态的对比差异。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<string>，以便能够比较此@Prop的旧值和新值。<br>shouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。</string></p>\n<p>@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。</p>\n<p>@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。</p>\n","excerpt":"","more":"<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><h3 id=\"Layout-Specs\"><a href=\"#Layout-Specs\" class=\"headerlink\" title=\"Layout Specs\"></a>Layout Specs</h3><p>Layout Spec在逻辑上等同于Android的View的组合.它简单的把一些已经存在的component组合到一个不可变的布局树中.</p>\n<p>实现一个layout spec非常简单:你只需要写一个标注为@OnCreateLayout的方法,并且让它返回一个不可变的<a href=\"\">ComponentLayout</a>对象的树.</p>\n<p>让我们从一个简单的例子开始:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@LayoutSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponentSpec</span> </span>&#123;</div><div class=\"line\">  <span class=\"meta\">@OnCreateLayout</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ComponentLayout <span class=\"title\">onCreateLayout</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext c,</div><div class=\"line\">      @Prop <span class=\"keyword\">int</span> color,</div><div class=\"line\">      @Prop String title)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> Row.create(c)</div><div class=\"line\">          .alignItems(CENTER)</div><div class=\"line\">          .child(</div><div class=\"line\">              SolidColor.create(c)</div><div class=\"line\">                  .colorRes(color)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .widthDip(<span class=\"number\">40</span>)</div><div class=\"line\">                  .heightDip(<span class=\"number\">40</span>))</div><div class=\"line\">          .child(</div><div class=\"line\">              Text.create(c)</div><div class=\"line\">                  .text(title)</div><div class=\"line\">                  .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">                  .withLayout()</div><div class=\"line\">                  .flexGrow(<span class=\"number\">1f</span>))</div><div class=\"line\">          .build();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>正如你所见,layout spec类使用@LayoutSpec注释.</p>\n<p>用@OnCreateLayout注释标注的方法必须以<a href=\"\">ComponentContext</a>作为第一个参数,并且在它后面有以@Prop标注的其他参数.注释处理器将会在编译的时候对它们和其他API的不变性进行验证.</p>\n<p>在上面的示例中,布局树中有一个根容器,容器中有两个水平堆叠(Row.create)且垂直居中(Align.CENTER)的子节点.</p>\n<p>第一个子节点是一个<a href=\"\">SolidColor</a> component,它拥有一个colorRes的Prop和40dp的宽和高.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SolidColor.create(c)</div><div class=\"line\">    .uri(imageUri)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .width(<span class=\"number\">40</span>)</div><div class=\"line\">    .height(<span class=\"number\">40</span>)</div></pre></td></tr></table></figure>\n<p>第二个子节点是一个Text Component,它拥有一个名叫text的prop,并且使用grow(1f)填充了Myconponent中的剩余的水平空间(等同于Android LinearLayout中的layoutWeight).文字大小实在my_text_size尺寸文件中定义的.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Text.create(c)</div><div class=\"line\">    .text(title)</div><div class=\"line\">    .textSizeRes(R.dimen.my_text_size)</div><div class=\"line\">    .withLayout()</div><div class=\"line\">    .grow(<span class=\"number\">1f</span>)</div></pre></td></tr></table></figure></p>\n<p>你可以查看完整的<a href=\"\">Yoga</a>文档来获取所有框架开放出的布局特性.</p>\n<h3 id=\"Mount-Specs\"><a href=\"#Mount-Specs\" class=\"headerlink\" title=\"Mount Specs\"></a>Mount Specs</h3><p>一个Mount Spec定义了一个可以渲染Views或者drawables的component.</p>\n<p>Mount Spec只有在你需要把自己的view/drawable集成到Component 框架中的时候才应当被创建.这里的Mount的意思是指布局树中所有的component执行的操作,用于提取它们的渲染状态(一个View或者一个Drawable)以供显示.</p>\n<p>Mount spec类应该使用@MountSpec去注释,并且至少实现一个@OnCreateMountContent方法.下方其他列出的方法是可选择实现的.</p>\n<p>mount spec component的生命周期如下:</p>\n<ul>\n<li>在布局计算之前,运行@OnPrepare一次</li>\n<li>在布局计算过程中,可选择的运行OnMeasure.</li>\n<li>在布局计算之后,运行@OnBoundsDefined一次.</li>\n<li>在component添加到托管视图之前,运行@OnCreateMountContent</li>\n<li>在component添加到托管视图之前,运行@OnMount</li>\n<li>在component添加到托管视图之后,运行@OnBind</li>\n<li>在从托管视图移除component之前,运行@OnUnBind</li>\n<li>在从托管视图移除component之前,可选择的运行@OnUnmount</li>\n</ul>\n<h5 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h5><p>让我们从一个简单的ColorComponent开始,它有一个prop表示颜色名,并且装载它自己的ColorDrawable.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @Prop String colorName)</span> </span>&#123;</div><div class=\"line\">    colorDrawable.setColor(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>挂载操作的API与Android的RecyclerView Adapter非常相似.它有一个onCreateMountContent方法在回收池为空的时候创建和初始化View/Drawable内容,以及一个onMount方法能够根据当前的信息更新回收内容.</li>\n<li>onCreateMountContent的返回类型应该始终和onMount的第二个参数的类型相一致。它必须为View或Drawable的子类。这在编译时由注释处理器去验证。</li>\n<li>挂载总是发生在主线程中因为它可能需要处理Android Views(它们被绑定在主线程中).</li>\n<li>onCreateMountContent不能使用@Prop或任何其他带注释的参数。</li>\n<li>鉴于@OnMount方法始终在UI线程中运行，因此不应执行耗时的操作。</li>\n</ul>\n<h5 id=\"阶段之间的输入和输出\"><a href=\"#阶段之间的输入和输出\" class=\"headerlink\" title=\"阶段之间的输入和输出\"></a>阶段之间的输入和输出</h5><p>你可以通过把重操作(耗时操作)移动到@OnPrepare方法中,来减轻UI线程的压力.这个方法只会在布局计算前执行一次,并且可以在后台线程中执行.</p>\n<p>假设现在我们需要将在UI线程之外解析得到的颜色名称应用到ColorComponent中.为了做到这一点,我们需要一种将@OnPrepare方法中生成的值传递给@OnMount方法的途径.Component框架提供了阶段间的输入和输出,使你能够做到这一点.</p>\n<p>让我们看看ColorComponent的@OnPrepare方法:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MountSpec</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorComponentSpec</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnPrepare</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepare</span><span class=\"params\">(</div><div class=\"line\">      Context context,</div><div class=\"line\">      @Prop String colorName,</div><div class=\"line\">      Output&lt;Integer&gt; color)</span> </span>&#123;</div><div class=\"line\">    color.set(Color.parseColor(colorName));</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnCreateMountContent</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> ColorDrawable <span class=\"title\">onCreateMountContent</span><span class=\"params\">(ComponentContext c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ColorDrawable();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@OnMount</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMount</span><span class=\"params\">(</div><div class=\"line\">      ComponentContext context,</div><div class=\"line\">      ColorDrawable colorDrawable,</div><div class=\"line\">      @FromPrepare <span class=\"keyword\">int</span> color)</span> </span>&#123;</div><div class=\"line\">    convertDrawable.setColor(color);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@MountSpec方法中使用Output&lt;?&gt;会自动的创建一个输入在下一个阶段中.在这种情况下,一个@OnPrepare的输出就会在@OnMount中创建一个输入.</p>\n<p>在编译期间,注释处理器将会确保阶段间的不变性,例如你不能在@OnPrepare中使用@OnMeasure的输出,因为@OnPrepare总是在@OnMeasure之前执行.</p>\n<h5 id=\"测量\"><a href=\"#测量\" class=\"headerlink\" title=\"测量\"></a>测量</h5><p>如果你需要在布局计算阶段定义如何测量你的component,那么你就需要实现@OnMeasure方法.</p>\n<p>现在,让我们假设我们需要我们的ColorComponent有一个默认的宽度,并且当它的高度未定义的时候,能够强制执行一定的宽高比.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnMeasure</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(</div><div class=\"line\">    ComponentContext context,</div><div class=\"line\">    ComponentLayout layout,</div><div class=\"line\">    <span class=\"keyword\">int</span> widthSpec,</div><div class=\"line\">    <span class=\"keyword\">int</span> heightSpec,</div><div class=\"line\">    Size size)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If width is undefined, set default size.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(widthSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.width = <span class=\"number\">40</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.width = SizeSpec.getSize(widthSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// If height is undefined, use 1.5 aspect ratio.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (SizeSpec.getMode(heightSpec) == SizeSpec.UNSPECIFIED) &#123;</div><div class=\"line\">    size.height = width * <span class=\"number\">1.5</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    size.height = SizeSpec.getSize(heightSpec);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在@OnMeasure方法中,你可以像以前一样使用@Prop注释访问Component props.SizeSpec的API类似于Android中的<a href=\"\">MeasureSpec</a>.</p>\n<p>就像@OnPrepare一样,@OnMeasure方法也能生成阶段间的输出(能够使用@FromMeasure注释的参数来访问),并且可以在后台线程中执行.</p>\n<h5 id=\"ShouldUpdate\"><a href=\"#ShouldUpdate\" class=\"headerlink\" title=\"ShouldUpdate\"></a>ShouldUpdate</h5><p>Mount Spec可以使用@ShouldUpdate注释定义一个方法来避免在更新时进行重新测试和重新挂载。<br>@ShouldUpdate的调用的前提是component是”纯渲染函数”。一个组件如果是纯渲染函数,那么它的渲染结果只取决于它的prop和状态.这意味着在@OnMount期间，组件不应该访问任何可变的全局变量。<br>一个@MountSpec可以通过使用@MountSpec注释的pureRender参数来定自己为”纯渲染的”。只有纯渲染的Component可以假设当prop不更改时就不需要重新挂载。@ShouldUpdate函数可以定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@ShouldUpdate</span>(onMount = <span class=\"keyword\">true</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldUpdate</span><span class=\"params\">(Diff&lt;String&gt; someStringProp)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> !someStringProp.getPrevious().equals(someStringProp.getNext());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>shouldUpdate中的参数是prop或状态的对比差异。Diff是一个包含旧Component层级结构中@Prop或@State的值以及新Component层级结构中相同的@Prop或@State值的类。在这个示例中，我们将someStringProp定义为一个String类型的@Prop。shouldUpdate方法将收到一个Diff<String>，以便能够比较此@Prop的旧值和新值。<br>shouldUpdate必须考虑在@OnMount时使用的任何prop和状态。它可以安全地忽略仅在“@OnMount/@OnUnbind”时间使用的prop和状态，因为这两个方法无论如何都会被执行。</p>\n<p>@ShouldUpdate注释上的onMount属性可以控制是否在挂载时进行shouldUpdate检查。默认情况下，Litho将尝试在layout的时候执行检查，但是在检查布局差异功能被关闭的时候,作为替代方案,将onMount设置为true,在挂载时执行此检查就变得很有用了。默认情况下，onMount属性被设置为false，因为相等检查本身可能很耗时,这会使挂载性能变得更差。</p>\n<p>@ShouldUpdate注释方法目前仅支持在@MountSpec中使用。我们计划在未来在更复杂的布局中也支持它，但目前在@LayoutSpec中用@ShouldUpdate注释的方法将不起作用。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj21nzol700081srl0kvzeysi","category_id":"cj21nzol300051srl4agx23sj","_id":"cj21nzold000d1srl2n058gsl"},{"post_id":"cj21nzokx00031srlcm48esv2","category_id":"cj21nzol300051srl4agx23sj","_id":"cj21nzole000h1srlc8ws89on"},{"post_id":"cj21nzola00091srl78ka44pa","category_id":"cj21nzol300051srl4agx23sj","_id":"cj21nzolg000j1srlg2m2kfvz"},{"post_id":"cj21nzolc000c1srl5p6udrup","category_id":"cj21nzol300051srl4agx23sj","_id":"cj21nzolg000m1srl9zqs2fdi"},{"post_id":"cj21nzol000041srlcdpe48vy","category_id":"cj21nzolb000a1srl91sc4ad3","_id":"cj21nzolh000o1srlv3kpebkz"},{"post_id":"cj21nzold000e1srlk0lhm8gt","category_id":"cj21nzol300051srl4agx23sj","_id":"cj21nzolh000p1srlxiobtxe6"},{"post_id":"cj21nzol600071srlnd05g2rf","category_id":"cj21nzole000f1srl83wem1mb","_id":"cj21nzoli000r1srl60jwcz8o"}],"PostTag":[{"post_id":"cj21nzokx00031srlcm48esv2","tag_id":"cj21nzol600061srlneu9uhxj","_id":"cj21nzolf000i1srlz9k7sios"},{"post_id":"cj21nzokx00031srlcm48esv2","tag_id":"cj21nzolb000b1srlflquhmln","_id":"cj21nzolg000k1srlnbgwp6eo"},{"post_id":"cj21nzol000041srlcdpe48vy","tag_id":"cj21nzole000g1srlszxggafi","_id":"cj21nzolh000n1srlnftygwj2"},{"post_id":"cj21nzol600071srlnd05g2rf","tag_id":"cj21nzolg000l1srlj7vnv7q6","_id":"cj21nzolj000u1srlkaxjqoid"},{"post_id":"cj21nzol600071srlnd05g2rf","tag_id":"cj21nzolh000q1srlpqid6zgh","_id":"cj21nzolk000v1srlm17ujf80"},{"post_id":"cj21nzol600071srlnd05g2rf","tag_id":"cj21nzole000g1srlszxggafi","_id":"cj21nzolm000x1srlw8tx791f"},{"post_id":"cj21nzol700081srl0kvzeysi","tag_id":"cj21nzol600061srlneu9uhxj","_id":"cj21nzolm000z1srljgjzxf1g"},{"post_id":"cj21nzol700081srl0kvzeysi","tag_id":"cj21nzolb000b1srlflquhmln","_id":"cj21nzolm00101srl3hf8j44m"},{"post_id":"cj21nzol700081srl0kvzeysi","tag_id":"cj21nzoll000w1srl0hyaz2z7","_id":"cj21nzoln00121srlygz4lla8"},{"post_id":"cj21nzola00091srl78ka44pa","tag_id":"cj21nzol600061srlneu9uhxj","_id":"cj21nzolo00141srlopxc83hd"},{"post_id":"cj21nzola00091srl78ka44pa","tag_id":"cj21nzolb000b1srlflquhmln","_id":"cj21nzolo00151srlj2mol758"},{"post_id":"cj21nzola00091srl78ka44pa","tag_id":"cj21nzoll000w1srl0hyaz2z7","_id":"cj21nzolo00171srlkidostsn"},{"post_id":"cj21nzolc000c1srl5p6udrup","tag_id":"cj21nzol600061srlneu9uhxj","_id":"cj21nzolo00181srli5goggxd"},{"post_id":"cj21nzolc000c1srl5p6udrup","tag_id":"cj21nzolb000b1srlflquhmln","_id":"cj21nzolo00191srlgt4bl9jx"},{"post_id":"cj21nzolc000c1srl5p6udrup","tag_id":"cj21nzoll000w1srl0hyaz2z7","_id":"cj21nzolp001a1srl24807jzx"},{"post_id":"cj21nzold000e1srlk0lhm8gt","tag_id":"cj21nzol600061srlneu9uhxj","_id":"cj21nzolp001b1srlcq9fb78o"},{"post_id":"cj21nzold000e1srlk0lhm8gt","tag_id":"cj21nzolb000b1srlflquhmln","_id":"cj21nzolp001c1srlc5058chq"},{"post_id":"cj21nzold000e1srlk0lhm8gt","tag_id":"cj21nzoll000w1srl0hyaz2z7","_id":"cj21nzolp001d1srltu94puqt"}],"Tag":[{"name":"Android","_id":"cj21nzol600061srlneu9uhxj"},{"name":"实用库","_id":"cj21nzolb000b1srlflquhmln"},{"name":"github","_id":"cj21nzole000g1srlszxggafi"},{"name":"Hexo","_id":"cj21nzolg000l1srlj7vnv7q6"},{"name":"Web","_id":"cj21nzolh000q1srlpqid6zgh"},{"name":"Litho","_id":"cj21nzoll000w1srl0hyaz2z7"}]}}